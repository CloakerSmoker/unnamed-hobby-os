i64 PAGE_TABLE_BASE := 0x20_0000

i64**** PML4T 		:= PAGE_TABLE_BASE As i64****
i64*** PDPT 		:= PAGE_TABLE_BASE + 0x1000 As i64***
i64** PDT 			:= PAGE_TABLE_BASE + 0x2000 As i64**

i64* PAGE_TABLES 	:= PAGE_TABLE_BASE + 0x3000 As i64*

i32 PAGE_TABLE_SIZE 		:= 0x20_0000
i32 PAGE_SIZE 				:= 0x1000
i32 RESERVED_PAGE_FRAMES 	:= 3
i32 PAGES_PER_TABLE 		:= 0x200

i32 PAGE_FRAME_COUNT 	:= (PAGE_TABLE_SIZE / PAGE_SIZE) - RESERVED_PAGE_FRAMES
i32 PAGE_COUNT 			:= PAGE_FRAME_COUNT * PAGES_PER_TABLE

i32 PAGE_COUNT_FOR_1MB := 0x100
i32 PAGE_COUNT_FOR_2MB := 0x200
i32 PAGE_COUNT_FOR_4MB := 0x400
i32 PAGE_COUNT_FOR_6MB := 0x600
i32 PAGE_COUNT_FOR_8MB := 0x800

i32 BYTES_IN_1MB := 0x10_0000
i32 BYTES_IN_2MB := 0x20_0000
i32 BYTES_IN_4MB := 0x40_0000

i64 PAGE_PRESENT := 1
i64 PAGE_WRITE := 2

struct AddressSpaceManager {
	i32 NextFreeVirtualPage
	i32 NextFreePhysicalPage
	
	define void MapPageRange(i64 FromPage, i64 ToPage, i32 Count) {
		i64 StartingPageTable := FromPage
		
		for (i32 Index := 0, Index < Count, Index += 1) {
			i64 Value := ((ToPage + Index) * 0x1000) | PAGE_PRESENT | PAGE_WRITE
			
			PAGE_TABLES[StartingPageTable + Index] := Value
		}
	}
	
	define void Takeover() {
		PML4T[0] := PDPT | PAGE_PRESENT | PAGE_WRITE
		PDPT[0] := PDT | PAGE_PRESENT | PAGE_WRITE
		
		for (i32 Index := 0, Index < PAGE_FRAME_COUNT, Index += 1) {
			; Point 509 entries in the PDT to our 509 PT structures, giving us just under 1gb of continguous address space
			;  (FrameCount * PagesPerFrame * PageSize) * (509 * 512 * 0x1000) = 0x3FA0_0000
			
			PDT[Index] := PAGE_TABLES + (Index * 0x1000) | PAGE_PRESENT | PAGE_WRITE
		}
		
		this->MapPageRange(0, 0, PAGE_COUNT_FOR_4MB)
		
		SetCR3(PML4T)
		
		this->NextFreeVirtualPage := PAGE_COUNT_FOR_4MB
		this->NextFreePhysicalPage := PAGE_COUNT_FOR_4MB
	}
	
	define i64 AllocateContiguousVirtualPages(i32 Count) {
		i32 StartingPageTable := this->NextFreeVirtualPage
		
		this->NextFreeVirtualPage += Count
		
		if (this->NextFreeVirtualPage > PAGE_COUNT) {
			BochsPrintString("OUT OF MEMORY, ATTEMPTED TO ALLOCATE PAGES PAST 2MB PAGE STRUCT BOUNDS")
			loop {}
		}
		
		return StartingPageTable
	}
	define i64 AllocateContiguousPhysicalPages(i32 Count) {
		i32 FirstPage := this->NextFreePhysicalPage
		
		this->NextFreePhysicalPage += Count
		
		return FirstPage
	}
	
	define i32 SizeToPageCount(i32 Size) {
		i32 PageCount := Size / PAGE_SIZE
		
		if (Size % PAGE_SIZE) {
			PageCount += 1
		}
		
		return PageCount
	}
	define void* PageNumberToPointer(i64 PageNumber) {
		return (PageNumber * 0x1000) As void*
	}
	define i64 PointerToPageNumber(void* PageMemory) {
		return (PageMemory / 0x1000) As i64
	}
	
	define void* AllocateMappedPages(i32 Count) {
		i64 VirtualPages := this->AllocateContiguousVirtualPages(Count)
		i64 PhysicalPages := this->AllocateContiguousPhysicalPages(Count)
		
		this->MapPageRange(VirtualPages, PhysicalPages, Count)
		
		return this->PageNumberToPointer(VirtualPages)
	}
}

AddressSpaceManager RawAddressSpace
AddressSpaceManager* AddressSpace := &RawAddressSpace