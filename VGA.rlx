i8 VGA_BLACK := 0
i8 VGA_BLUE := 1
i8 VGA_GREEN := 2
i8 VGA_RED := 4
i8 VGA_BRIGHT := 8
i8 VGA_WHITE := 15

define i16 PackColor(i8 Fore, i8 Back) {
	return (Fore | (Back << 4)) As i16
}
define i16 PackEntry(i8 Character, i16 Color) {
	return (Character | (Color << 8)) As i16
}

i32 VGA_WIDTH := 80
i32 VGA_HEIGHT := 25
i32 TRUE_WIDTH := 79
i32 TRUE_HEIGHT := 24

i16* TerminalBuffer := 0xB8000 As i16*
i32 TerminalRow := 0
i32 TerminalColumn := 0
i16 TerminalColor := PackColor(VGA_WHITE, VGA_BLACK)

define void TerminalClear() {
	for (i32 Y := 0, Y < VGA_HEIGHT, Y += 1) {
		for (i32 X := 0, X < VGA_WIDTH, X += 1) {
			i32 Index := (Y * VGA_WIDTH) + X
			TerminalBuffer[Index] := PackEntry(' ', TerminalColor)
		}
	}
}

define void TerminalScroll() {
	i16 Blank := PackEntry(' ', PackColor(0, 0))
	
	i16* From := TerminalBuffer + (160)
	
	MemoryMove(TerminalBuffer, From, 3840)
	
	i16* LastLine := TerminalBuffer + 3840
	
	MemorySet16(LastLine, Blank, 80)
}

define void TerminalCheckBounds() {
	if (TerminalColumn + 1 >= VGA_WIDTH) {
		TerminalColumn := 0
		TerminalRow += 1
	}
	
	if ((TerminalRow + 1) >= VGA_HEIGHT) {
		TerminalScroll()
		TerminalRow := VGA_HEIGHT - 2
	}
}

define void TerminalWriteCharacter(i8 Character) {
	if (Character = '	') {
		for (i32 I := 0, I < 4, I += 1) {
			TerminalWriteCharacter(' ')
		}
	}
	else if (Character = 10 || Character = 13) {
	 	/* Dummy branch */
	}
	else {
		i32 Index := (TerminalRow * VGA_WIDTH) + TerminalColumn	
		TerminalBuffer[Index] := PackEntry(Character, TerminalColor)
		
		TerminalColumn += 1
		
		TerminalCheckBounds()
	}
}

define void VGACommand(i8 Number, i8 Parameter) asm {
	mov, dx, 0x3D4
	mov, a, di
	outb
	
	inc, dx
	mov, a, si
	outb
	
	ret
}

define void TerminalSetCursor(i32 Y, i32 X) {
	i32 Packed := (Y * VGA_WIDTH) + X
	i8 H := ((Packed >> 8) & 0xFF) As i8
	i8 L := (Packed & 0xFF) As i8
	
	VGACommand(0x0F, L)
	VGACommand(0x0E, H)
}

define void TerminalAWrite(i8* AString) {
	for (i32 Index := 0, AString[Index] != 0, Index += 1) {
		TerminalWriteCharacter(AString[Index])
	}
	
	TerminalSetCursor(TerminalRow, TerminalColumn)
}
define void TerminalWriteNewLine() {
	TerminalRow += 1
	TerminalColumn := 0
	
	TerminalCheckBounds()
	
	TerminalSetCursor(TerminalRow, 0)
}
define void TerminalAWriteLine(i8* AString) {
	TerminalAWrite(AString)
	TerminalWriteNewLine()
}

define void TerminalToggleCursor() {
	asm {
		mov, dx, 0x3D5
		inb
		
		xor, ax, 0x20
		
		dec, dx
		mov, bx, 0x0A
		xchg, ax, bx
		outb
		
		inc, dx
		xchg, ax, bx
		outb
	}
}

define void TerminalWriteNumber(i64 Number) {
	TerminalAWrite(IToA(Number, 10))
}
define void TerminalWriteNumberLine(i64 Number) {
	TerminalWriteNumber(Number)
	TerminalWriteNewLine()
}
define void TerminalWriteHexNumber(i64 Number) {
	TerminalAWrite(IToA(Number, 16))
}
define void TerminalWriteHexNumberLine(i64 Number) {
	TerminalWriteHexNumber(Number)
	TerminalWriteNewLine()
}

define void TerminalPrintFormat(i8* Format, ... Args) {
	i16 StartingColor := TerminalColor
	
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				TerminalWriteNumber(NextArg)
			}
			else if (Next = 'x') {
				TerminalWriteHexNumber(NextArg)
			}
			else if (Next = 'c') {
				TerminalWriteCharacter(NextArg As i8)
			}
			else if (Next = 's') {
				TerminalAWrite(NextArg As i8*)
			}
			
			ArgIndex += 1
		}
		else if (Next = '\') {
			Index += 1
			Next := Format[Index]
			
			if (Next = 'n') {
				TerminalAWriteLine("")
			}
			else if (Next = 't') {
				TerminalWriteCharacter('	')
			}
			else {
				TerminalWriteCharacter(Next)
			}
		}
		else if (Next = '^') {
			Index += 2
			i8 Fore := GetCharacterValue(Format[Index - 1])
			i8 Back := GetCharacterValue(Format[Index])
			
			TerminalColor := PackColor(Fore, Back)
		}
		else {
			TerminalWriteCharacter(Next)
		}
	}
	
	TerminalColor := StartingColor
	TerminalSetCursor(TerminalRow, TerminalColumn)
}
