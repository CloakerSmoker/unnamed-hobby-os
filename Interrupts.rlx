define void _InterruptSetup() asm {
	xchg, rax, {rsp + 0x10} As i64*
	
	push, rbx
	push, rcx
	push, rdx
	push, rbp
	push, r8
	push, r9
	push, r10
	push, r11
	push, r12
	push, r13
	push, r14
	push, r15
	mov, rsi, rsp
	
	jmp, rax
}
define void InterruptCodeSetup() asm {
	push, rdi
	xchg, rsi, {rsp + 0x10} As i64*
	lea, rdi, {rsp + 0x18} As i64*
	jmp, @_InterruptSetup
}
define void InterruptSetup() asm {
	push, rsi
	push, rdi
	lea, rdi, {rsp + 0x18} As i64*  /* Get interrupt context, which is above RDI,RSI,RIP on the stack */ 
	jmp, @_InterruptSetup
}
define void InterruptReturn() asm {
	pop, r15
	pop, r14
	pop, r13
	pop, r12
	pop, r11
	pop, r10
	pop, r9
	pop, r8
	pop, rbp
	pop, rdx
	pop, rcx
	pop, rbx
	pop, rdi
	pop, rsi
	pop, rax
	
	iret
}

struct Registers {
	i64 R15, i64 R14, i64 R13, i64 R12, i64 R11, i64 R10, i64 R9, i64 R8,
	i64 RBP, i64 RDX, i64 RCX, i64 RBX, i64 RDI, i64 RSI, i64 RAX
}
struct InterruptContext {
	i64 RIP, i64 CS, i64 Flags, i64 RSP, i64 SS
}

struct StackFrame {
	StackFrame* LastFrame,
	i64* ReturnAddress
}

define void PrintStackDump(Registers* Registers) {
	BochsPrint("PSD RBP = %x\n", Registers->RBP)
	
	StackFrame* Last := Registers->RBP As StackFrame*
	i32 Index := 1
	
	while (Last) {
		if (Last->LastFrame & 1) {
			StackFrame* Temp := Last->LastFrame - 1
			
			TerminalPrintFormat("	^10Stack[%i]^F0 ^D0Try catch address^F0 = %x\n", Index, Last->ReturnAddress, Temp)
			
			Last := Temp
		}
		else {
			i64* MaybeMagic := Last - 0x8
			i8** MaybeName := (Last - 0x10) As i8**
			
			if (Debug && *MaybeMagic = 0x12345678) {
				TerminalPrintFormat("	^10Stack[%i]^F0 ^B0Fn^F0 = %s\n", Index, *MaybeName)
			}
			else {
				TerminalPrintFormat("	^10Stack[%i]^F0 ^B0Fn callsite^F0 = %x\n", Index, Last->ReturnAddress, Last->LastFrame)
			}
			
			Index += 1
			
			Last := Last->LastFrame
		}
	}
	
	TerminalPrintFormat("Halted\n")
	
	loop {}
}

define void _DefaultHandler() asm {
	call, @InterruptSetup
	call, @PrintStackDump
	jmp, @InterruptReturn
}

struct IDTEntry unaligned {
	i16 OffsetLow16,
	i16 Selector,
	i8 PaddingZero,
	i8 Flags,
	i16 OffsetHigh16,
	i32 OffsetHigh32,
	i32 Padding
}

struct IDT unaligned {
	i16 Size,
	IDTEntry* Start
}

IDT* IDTHeader := 0xFF00
IDTEntry* IDT := 0x10000

define void InsertIDTEntry(i32 Index, void* Function, i8 Present) {
	IDTEntry* E := IDT + (Index * 16)
	
	MemorySet64(E As i64*, 0, 2)
	
	E->OffsetLow16 := (Function & 0xFFFF)
	E->OffsetHigh16 := (Function >> 16) & 0xFFFF
	E->OffsetHigh32 := (Function >> 32) & 0xFFFFFFFF
	
	E->Selector := 0x08
	E->Flags := 0x0E | (Present * 0x80)
}

i16 MASTER_PIC := 0x20
i16 SLAVE_PIC := 0xA0

i16 MASTER_PIC_DATA := 0x21
i16 SLAVE_PIC_DATA  := 0xA1

define void RemapPIC(i8 MasterOffset, i8 SlaveOffset) {
	i8 OldMaster := InB(MASTER_PIC_DATA)
	i8 OldSlave := InB(SLAVE_PIC_DATA)
	
	OutB(MASTER_PIC, 0x11)
	OutB(SLAVE_PIC, 0x11)
	
	OutB(MASTER_PIC_DATA, MasterOffset)
	OutB(SLAVE_PIC_DATA, SlaveOffset)
	
	OutB(MASTER_PIC_DATA, 0x04)
	OutB(SLAVE_PIC_DATA, 0x02)
	
	OutB(MASTER_PIC_DATA, 0x01)
	OutB(SLAVE_PIC_DATA, 0x01)
	
	OutB(MASTER_PIC_DATA, OldMaster)
	OutB(SLAVE_PIC_DATA, OldSlave)
}

define void SendEOI(i8 IRQLine) {
	if (IRQLine >= 8) {
		OutB(SLAVE_PIC, 0x20)
	}
	
	OutB(MASTER_PIC, 0x20)
}

define void EnablePICLine(i8 IRQLine, i8 Enabled) {
	i16 Port := MASTER_PIC_DATA
	
	if (IRQLine >= 8) {
		Port := SLAVE_PIC_DATA
		IRQLine -= 8
	}
	
	i8 Value := InB(Port)
	
	if (Enabled) {
		Value := Value & ~(1 << IRQLine)
	}
	else {
		Value := Value | (1 << IRQLine)
	}
	
	OutB(Port, Value)
}

declare void SetupTime()
declare void AddHandlers()
declare void SetupKeyboard()

define void LIDT(IDT* NewIDT) asm {
	lidt, {rdi} As i64*
	ret
}

define void SetupInterrupts() {
	asm {cli}
	
	IDTHeader->Start := IDT
	IDTHeader->Size := 799
	
	for (i32 Index := 0, Index < 50, Index += 1) {
		InsertIDTEntry(Index, &_DefaultHandler, true)
	}
	
	AddHandlers()
	BootInfo("IDT built")
	
	RemapPIC(0x20, 0x28)
	BootInfo("PIC remapped")
	
	SetupTime()
	SetupKeyboard()
	BootInfo("PIT and PS/2 ready")
	
	asm (rax := IDTHeader) {
		lidt, {rax} As i64*
	}
	
	BootInfo("IDT loaded")
	
	asm {sti}
	
	BochsPrint("After STI\n")
}

#Include ./src/InterruptHandlers.rlx
#Include ./src/Time.rlx
#Include ./src/Keyboard.rlx
