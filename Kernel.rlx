#ImageBase 0x34000

#Require "./src/Utility.rlx"

define void BochsPrintCharacter(i8 Character) {
	asm (rdx := 0xE9, rax := Character) {
		outb
	}
}
define void BochsPrintString(i8* String, i8 Recurse) {
	if !(Recurse) {
		BochsPrintString("OS	|: ", true)
	}
	
	for (i32 Index := 0, Index < StringLength(String), Index += 1) {
		BochsPrintCharacter(String[Index])
	}
}
define void BochsPrintString(i8* String) {
	BochsPrintString(String, false)
}

declare void* KernelHeapAllocate(i64, i32)
declare void* KernelHeapExtendAllocation(void*, i32)
declare void KernelHeapFree(void*)

#Require "./src/Font.rlx"
#Require "./src/Screen.rlx"
#Require "./src/Terminal.rlx"

#Require "./src/Paging.rlx"
#Require "./src/Heap.rlx"

Heap RawKernelHeap
Heap* KernelHeap := &RawKernelHeap

define void* KernelHeapAllocate(i64 Tag, i32 Size) {
	return KernelHeap->Allocate(Tag, Size)
}
define void* KernelHeapExtendAllocation(void* Memory, i32 Size) {
	return KernelHeap->Extend(Memory, Size)
}
define void KernelHeapFree(void* Memory) {
	KernelHeap->Free(Memory)
}

#Require "./src/Interrupts.rlx"
#Require "./src/Shell.rlx"

define void Main(i64 _KernelLimit, void* RawFrameBuffer, UStarHeader* FS) {
	BochsPrintString("Main\n")
	
	AddressSpace->Takeover()
	
	BochsPrintString("Paging initialized, AddressSpaceManager in control\n")
	
	; Identity map 2mb of memory for the kernel heap
	void* HeapMemory := AddressSpace->AllocateMappedPages(PAGE_COUNT_FOR_2MB)
	
	BochsPrintString("Allocated KernelHeap memory\n")
	
	; Remap the next available `FRAMEBUFFER_SIZE / PAGE_SIZE` bytes of virtual memory to 0xE000_0000 (or wherever) 
	i32 FrameBufferPageCount := AddressSpace->SizeToPageCount(FRAMEBUFFER_SIZE)
	i64 FrameBufferPage := AddressSpace->AllocateContiguousVirtualPages(FrameBufferPageCount)
	AddressSpace->MapPageRange(FrameBufferPage, AddressSpace->PointerToPageNumber(RawFrameBuffer), FrameBufferPageCount)
	
	i8* FrameBuffer := AddressSpace->PageNumberToPointer(FrameBufferPage) As i8*
	
	NativeScreen->Adopt(FrameBuffer, SCREEN_WIDTH, SCREEN_HEIGHT, BYTES_PER_PIXEL, 0, 0x00_00_00)
	
	Terminal->Adopt(NativeScreen)
	Terminal->SetColors(0xFF_FF_FF, 0x00_00_00)
	
	NativeScreen->Clear()
	
	Terminal->PrintLine("BOOT: Screen *probably* works")
	
	KernelHeap->Initialize(HeapMemory, BYTES_IN_2MB)
	
	Terminal->Print("BOOT: Kernel Heap Initialized: ")
	KernelHeap->Allocate('Example', 0x222)
	KernelHeap->Print()
	
	SetupInterrupts()
	
	Screen* TerminalWindow := NativeScreen->CreateWindow(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT - 70, 0xFF_FF_FF)
	Screen* TaskbarWindow := NativeScreen->CreateWindow(0, SCREEN_HEIGHT - 70, SCREEN_WIDTH, 70, 0x00_00_00)
	Screen* UptimeWindow := TaskbarWindow->CreateWindow((SCREEN_WIDTH / 2) - 100, 35, 300, 20, 0x00_00_00)
	
	NativeScreen->PrintHierarchy(0)
	NativeScreen->Clear()
	
	UptimeDisplay := UptimeWindow
	
	Terminal->Adopt(TerminalWindow)
	Terminal->SetColors(0x00_00_00, 0xFF_FF_FF)
	
	Print("BOOT: Switched to window system for terminal\n")
	
	Prompt()
	
	loop {}
}