define void MoveMemory(void* RawTo, void* RawFrom, i32 Size) {
	i8* To := RawTo As i8*
	i8* From := RawFrom As i8*
	
	i32 Index := 0
	
	if (To < From) {
		for (Index := 0, Index < Size, Index += 1) {
			To[Index] := From[Index]
		}
	}
	else {
		for (Index := Size, Index != 0, Index -= 1) {
			To[Index - 1] := From[Index - 1]
		}
	}
}
define void MemorySet8(i8* At, i8 Value, i32 Size) {
	for (i32 Index := 0, Index < Size, Index += 1) {
		At[Index] := Value
	}
}
define void MemorySet16(i16* At, i16 Value, i32 Size) {
	for (i32 Index := 0, Index < Size, Index += 1) {
		At[Index] := Value
	}
}
define void MemorySet64(i64* At, i64 Value, i32 Size) {
	for (i32 Index := 0, Index < Size, Index += 1) {
		At[Index] := Value
	}
}

define i32 StringLength(i8* String) {
	for (i32 Length := 0, String[Length] != 0, Length += 1) {}
	
	return Length
}

i8{96} NumberBuffer

define i8 Lower(i8 Character) {
	; Converts A-Z to a-z
	
	if ('A' <= Character && Character <= 'Z') {
		Character += 32
	}
	
	return Character
}
define i16 Lower(i16 Character) {
	return Lower(Character As i8) As i16
}

define i8 NumberToCharacter(i8 Number) {
	if (Number < 10) {
		return (Number + '0') As i8
	}
	else {
		return (Number - 10 + 'A') As i8
	}
}
define i8 GetCharacterValue(i8 Character) {
	Character := Lower(Character)
	
	if (Character >= 'a') {
		return ((Character - 'a') + 10) As i8
	}
	
	return (Character - '0') As i8
}

define void MemoryReverse(i8* Buffer, i32 Length) {
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Temp := Buffer[Index]
		Buffer[Index] := Buffer[Length - 1]
		Buffer[Length - 1] := Temp
		
		Length -= 1
	}
}

define i8* IToA(i64 Number, i64 Base, i8* Buffer, i8 PrintExtra) {
	i8 Sign := 0
	
	if (Number < 0) {
		Sign := true
		
		if (Base = 10) {
			Number := -Number
		}
		else if (Base = 16 || Base = 2) {
			/* Negative hex numbers are printed as unsigned, and get the sign bit individually set in the output string */
			
			Number := Number & 0x7FFFFFFFFFFFFFFF
		}
	}
	
	for (i32 Index := 0, Number != 0, Index += 1) {
		Buffer[Index] := NumberToCharacter((Number % Base) As i8)
		Number := Number / Base
	}
	
	if (Index = 0) {
		Buffer[0] := '0'
		Index := 1
	}
	
	if (Sign) {
		if (Base = 10) {
			Buffer[Index] := '-'
			Index += 1
		}
		else if (Base = 16) {
			i8 Last := GetCharacterValue(Buffer[Index - 1])
			Last := Last | 0x8
			Buffer[Index - 1] := NumberToCharacter(Last)
		}
	}
	
	if (Base = 16 && PrintExtra) {
		Buffer[Index] := 'x'
		Buffer[Index + 1] := '0'
		Index += 2
	}
	
	MemoryReverse(Buffer, Index)
	
	return Buffer
}
define i8* IToA(i64 Number, i64 Base, i8* Buffer) {
	return IToA(Number, Base, Buffer, true)
}
define i8* IToA(i64 Number, i8* Buffer) {
	return IToA(Number, 10, Buffer)
}
define i8* IToAH(i64 Number, i8* Buffer) {
	return IToA(Number, 16, Buffer)
}

define i8 InB(i16 Port) asm {
	mov, dx, dix
	inb
	ret
}
define void OutB(i16 Port, i8 Data) asm {
	mov, dx, dix
	mov, a, si
	outb
	ret
}
define i16 InW(i16 Port) asm {
	mov, dx, dix
	inw
	ret
}
define void OutW(i16 Port, i16 Data) asm {
	mov, dx, dix
	mov, ax, six
	outw
	ret
}