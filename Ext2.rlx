i16 EXT2_SUPER_MAGIC := 0xEF53

i16 EXT2_VALID_FS := 1
i16 EXT2_ERROR_FS := 2

i16 EXT2_IGNORE_ERROR := 1

struct SuperBlock {
	i32 TotalINodes,
	i32 TotalBlocks,
	
	i32 ReservedBlocks,
	
	i32 UnallocatedBlocks,
	i32 UnallocatedINodes,
	
	i32 SuperBlockNumber,
	
	i32 BlockSize,
	i32 FragmentSize,
	
	i32 BlocksPerGroup,
	i32 FragmentsPerGroup,
	i32 INodesPerGroup,
	
	i32 LastMountTime,
	i32 LastWriteTime,
	
	i16 MountCount,
	i16 MaxMountCount,
	
	i16 Magic,
	i16 State,
	i16 ErrorMode,
	
	i16 MinorRevision,
	
	i32 LastCheckTime,
	i32 CheckInterval,
	
	i32 CreatorOS,
	
	i32 RevisionLevel,
	
	i16 DefaultUserID,
	i16 DefaultGroupID
	
	define void SetFieldDefaults() {
		this->TotalINodes := 256
		this->TotalBlocks := 2048
		this->ReservedBlocks := 100
		this->UnallocatedBlocks := 2048
		this->UnallocatedINodes := 256
		this->SuperBlockNumber := 1
		this->BlockSize := 0
		this->FragmentSize := 0
		this->BlocksPerGroup := 8192
		this->INodesPerGroup := 256
		
		this->MountCount := 1
		this->MaxMountCount := 0xFFFF
		
		this->Magic := EXT2_SUPER_MAGIC
		this->State := EXT2_VALID_FS
		this->ErrorMode := EXT2_IGNORE_ERROR
		
		this->MinorRevision := 0
		
		this->CheckInterval := 0
		
		this->CreatorOS := 0
		this->RevisionLevel := 0
	}
	define void Print() {
		Print("SuperBlock {\n")
		Print("	TotalINodes: %i\n", this->TotalINodes)
		Print("	TotalBlocks: %i\n", this->TotalBlocks)
		Print("	ReservedBlocks: %i\n", this->ReservedBlocks)
		Print("	UnallocatedBlocks: %i\n", this->UnallocatedBlocks)
		Print("	UnallocatedINodes: %i\n", this->UnallocatedINodes)
		Print("	SuperBlockNumber: %i\n", this->SuperBlockNumber)
		Print("	BlockSize: %i\n", this->BlockSize)
		Print("	FragmentSize: %i\n", this->FragmentSize)
		Print("	BlocksPerGroup: %i\n", this->BlocksPerGroup)
		Print("	FragmentsPerGroup: %i\n", this->FragmentsPerGroup)
		Print("	INodesPerGroup: %i\n", this->INodesPerGroup)
		Print("	MountCount: %i\n", this->MountCount)
		Print("	MaxMountCount: %i\n", this->MaxMountCount)
		Print("	Magic: %x\n", this->Magic)
		Print("	State: %i\n", this->State)
		Print("	ErrorMode: %i\n", this->ErrorMode)
		Print("	MinorRevision: %i\n", this->MinorRevision)
		Print("	CheckInterval: %i\n", this->CheckInterval)
		Print("	CreatorOS: %i\n", this->CreatorOS)
		Print("	RevisionLevel: %i\n", this->RevisionLevel)
		Print("}\n")
	}
}
struct BlockGroupDescriptor {
	i32 BlockBitmap,
	i32 INodeBitmap,
	i32 INodeTable,
	i16 UnallocatedBlocks,
	i16 UnallocatedINodes,
	i16 DirectoryCount,
	i8{14} Padding
	
	define void Print() {
		Print("BlockGroupDescriptor {\n")
		Print("	BlockBitmap: %i\n", this->BlockBitmap)
		Print("	INodeBitmap: %i\n", this->INodeBitmap)
		Print("	INodeTable: %i\n", this->INodeTable)
		Print("	UnallocatedBlocks: %i\n", this->UnallocatedBlocks)
		Print("	UnallocatedINodes: %i\n", this->UnallocatedINodes)
		Print("}\n")
	}
}

i8 INODE_FILE := 0x8
i8 INODE_DIRECTORY := 0x4

struct INode {
	union {
		i16 Permissions,
		i16 Type
	}
	
	i16 UserID,
	i32 FileSizeLow,
	
	i32 LastAccessTime,
	i32 CreationTime,
	i32 LastModificationTime,
	i32 DeletionTime,
	
	i16 GroupID,
	i16 HardLinkCount,
	i32 DiskSectorsUsed,
	i32 Flags,
	
	union {
		i32 OSValue,
		i32 INodeNumber
	}
	
	i32{12} DirectBlocks,
	i32 SingleIndirectBlock,
	i32 DoubleIndirectBlock,
	i32 TripleIndirectBlock,
	
	i32 GenerationNumber,
	i64 Reserved,
	i32 FragmentAddress,
	
	i32{4} OSValues
	
	define void SetFieldDefaults() {
		this->Permissions := 0x1B4 | 0x8000
		this->UserID := 1000
		this->GroupID := 1000
		this->FileSizeLow := 0
		this->HardLinkCount := 1
		this->DiskSectorsUsed := 2
		this->GenerationNumber := 0x981237 ^ this As i32
	}
	
	define i16 GetPermissions() {
		return (this->Flags & 0x0FFF) As i16
	}
	define i16 GetType() {
		return ((this->Type & 0xF000) >> 12) As i16
	}
	
	define void Chmod(i8 Override, i8 User, i8 Group, i8 Other) {
		i16 Type := this->GetType()
		
		this->Permissions := (Type << 12) | (Override << 9) | (User << 6) | (Group << 3) | Other
	}
	
	define void SetType(i8 Type) {
		this->Type := this->GetPermissions() | Type << 12
	}
	define void MakeDirectory() {
		this->SetType(INODE_DIRECTORY)
	}
	define void MakeFile() {
		this->SetType(INODE_FILE)
	}
	define i8 IsDirectory() {
		return this->GetType() = INODE_DIRECTORY
	}
	define i8 IsFile() {
		return this->GetType() = INODE_FILE
	}
}

i8 DIRECTORY_ENTRY_FILE := 1
i8 DIRECTORY_ENTRY_DIRECTORY := 2

struct DirectoryEntry {
	i32 INode,
	i16 EntryLength,
	i8 NameLength,
	i8 Flags,
	i8{1} Name
	
	define i32 TrueSize() {
		i32 Result := this->NameLength + 8
		i32 Remainder := Result % 4
		
		if (Remainder) {
			Result += 4 - Remainder
		}
		
		return Result
	}
	define i32 PaddingSize() {
		return this->EntryLength - this->TrueSize()
	}
	
	define void TrimPadding() {
		this->EntryLength := this->TrueSize()
	}
	define DirectoryEntry* Next() {
		return this + this->EntryLength
	}
	
	define i8 IsDirectory() {
		return this->Flags = DIRECTORY_ENTRY_DIRECTORY
	}
	define i8 IsFile() {
		return this->Flags = DIRECTORY_ENTRY_FILE
	}
	define void MakeDirectory() {
		this->Flags := DIRECTORY_ENTRY_DIRECTORY
	}
	define void MakeFile() {
		this->Flags := DIRECTORY_ENTRY_FILE
	}
	
	define i8 NameEquals(i8* OtherName) {
		if (StringLength(OtherName) != this->NameLength) {
			return false
		}
		
		for (i32 Index := 0, Index < this->NameLength, Index += 1) {
			if (OtherName[Index] != this~>Name[Index]) {
				return false
			}
		}
		
		return true
	}
}

i32 EXT2_SUPERBLOCK_NUMBER := 1
i32 EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER := 2

struct Ext2 {
	SuperBlock* SuperBlock
	BlockGroupDescriptor* BlockGroupTable
	i64 FD
	
	void* TempINode
	
	i32 TempBlockNumber
	void* TempBlock
	
	void* ExtraTempBlock
	
	define void ReadSectors(i32 SectorNumber, i32 SectorCount, void* Buffer) {
		;Print("R %i %i\n", SectorNumber / 2, SectorCount / 2)
		
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileRead(this->FD, Buffer, SectorCount * 512)
	}
	define void* ReadBlock(i32 BlockNumber, void* Buffer) {
		this->ReadSectors(BlockNumber * 2, 2, Buffer)
		
		return Buffer
	}
	
	define void Initialize(i64 FD, void* SuperBlockBuffer, void* TempINode, void* TempBlock, void* ExtraTempBlock) {
		this->FD := FD
		this->TempINode := TempINode
		this->TempBlock := TempBlock
		this->ExtraTempBlock := ExtraTempBlock
		
		this->SuperBlock := SuperBlockBuffer
		this->BlockGroupTable := SuperBlockBuffer + 1024 As BlockGroupDescriptor*
		
		this->ReadBlock(EXT2_SUPERBLOCK_NUMBER, this->SuperBlock As void*)
		this->ReadBlock(EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER, this->BlockGroupTable As void*)
	}
	
	define void SwapTempBlocks() {
		void* Temp := this->TempBlock
		this->TempBlock := this->ExtraTempBlock
		this->ExtraTempBlock := Temp
	}
	
	define void* ReadBlock(i32 BlockNumber) {		
		if (this->TempBlockNumber != BlockNumber) {
			this->ReadSectors(BlockNumber * 2, 2, this->TempBlock)
		}
		
		return this->TempBlock
	}
	
	define void WriteSectors(i32 SectorNumber, i32 SectorCount, void* Data) {
		Print("Writing %x bytes to %x\n", SectorCount * 512, SectorNumber * 512)
		
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileWrite(this->FD, Data, SectorCount * 512)
	}
	define void WriteBlock(i32 BlockNumber, void* Data) {
		this->WriteSectors(BlockNumber * 2, 2, Data)
	}
	
	define BlockGroupDescriptor* GetBlockGroupDescriptor(i32 GroupNumber) {
		return this->BlockGroupTable + (GroupNumber * #BlockGroupDescriptor)
	}
	define void CommitBlockGroupDescriptors() {
		this->WriteBlock(EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER, this->BlockGroupTable)
	}
	define void CommitSuperBlock() {
		this->WriteBlock(EXT2_SUPERBLOCK_NUMBER, this->SuperBlock)
	}
	
	define i32 FindINodeBlock(i32 INodeNumber, i32* OutINodeOffset) {
		INodeNumber -= 1
		
		i32 BlockSize := 1024 << (this->SuperBlock->BlockSize As i8)
		i32 INodeSize := 128
		i32 INodesPerGroup := this->SuperBlock->INodesPerGroup
		
		i32 GroupNumber := INodeNumber / INodesPerGroup
		i32 INodeIndex := INodeNumber % INodesPerGroup
		
		BlockGroupDescriptor* GroupDescriptor := this->GetBlockGroupDescriptor(GroupNumber)
		
		i32 GroupBaseBlock := GroupDescriptor->INodeTable
		
		i32 INodeOffset := INodeIndex * INodeSize
		i32 BlockNumber := INodeOffset / BlockSize
		i32 OffsetInBlock := INodeOffset % BlockSize
		
		OutINodeOffset[0] := OffsetInBlock
		return GroupBaseBlock + BlockNumber
	}
	define INode* ReadINode(i32 INodeNumber) {
		i32 OffsetInBlock := 0
		i32 BlockNumber := this->FindINodeBlock(INodeNumber, &OffsetInBlock)
		
		;Print("Reading INode %i from block %i:%i\n", INodeNumber, BlockNumber, OffsetInBlock + (0 As i64))
		
		INode* Result := this->ReadBlock(BlockNumber, this->TempINode) + OffsetInBlock
		
		Result->INodeNumber := INodeNumber
		
		return Result
	}
	define INode* CloneINode(i32 INodeNumber) {
		return CloneMemory(this->ReadINode(INodeNumber), #INode)
	}
	define void RefreshINode(INode* Node) {
		INode* NewData := this->ReadINode(Node->INodeNumber)
		
		if (Node != NewData) {
			MoveMemory(Node As i8*, NewData As i8*, #INode)
		}
	}
	define void WriteINode(i32 INodeNumber, INode* NewTargetNodeData) {
		i32 OffsetInBlock := 0
		i32 BlockNumber := this->FindINodeBlock(INodeNumber, &OffsetInBlock)
		
		void* OldBlockData := this->ReadBlock(BlockNumber)
		INode* OldTargetNodeData := (OldBlockData + OffsetInBlock) As INode*
		
		MoveMemory(OldTargetNodeData As i8*, NewTargetNodeData As i8*, #INode)
		
		this->WriteBlock(BlockNumber, OldBlockData)
	}
	define void WriteINode(INode* NewNode) {
		this->WriteINode(NewNode->INodeNumber, NewNode)
	}
	
	define i32 CalculateDataBlockPath(i32 DataBlockIndex, i32* BlockPath) {
		if (DataBlockIndex < 12) {
			BlockPath[0] := DataBlockIndex
			return 1
		}
		
		DataBlockIndex -= 12
		
		if (DataBlockIndex < 0x100) {
			BlockPath[0] := 12
			BlockPath[1] := DataBlockIndex
			return 2
		}
		
		DataBlockIndex -= 0x100
		
		if (DataBlockIndex < 0x10000) {
			BlockPath[0] := 13
			BlockPath[1] := DataBlockIndex / 0x100
			BlockPath[2] := DataBlockIndex % 0x100
			return 3
		}
		
		DataBlockIndex -= 0x10000
		
		if (DataBlockIndex < 0x1000000) {
			BlockPath[0] := 14
			BlockPath[1] := DataBlockIndex / 0x10000
			BlockPath[2] := DataBlockIndex % 0x10000
			BlockPath[3] := DataBlockIndex % 0x100
			return 4
		}
	}
	
	declare i32 AllocateBlock()
	
	define i32 FindINodeDataBlock(INode* TargetNode, i32 DataBlockIndex, i8 AllocateIfNeeded) {
		i32{4} BlockPath
		
		i32* BlockCount := this->CalculateDataBlockPath(DataBlockIndex, BlockPath)
		i32* RootBlock := TargetNode~>DirectBlocks
		i32 RootBlockNumber := 0
		
		;Print(" Got path for %i[%i], %i long\n", TargetNodeNumber, DataBlockIndex, BlockCount)
		
		this->SwapTempBlocks()
		
		for (i32 WalkBlockIndex := 0, WalkBlockIndex < BlockCount, WalkBlockIndex += 1) {
			i32 NextBlockOffset := BlockPath[WalkBlockIndex]
			
			;Print("  Path[%i] = %i\n", WalkBlockIndex, NextBlockOffset)
			
			if !(RootBlock[NextBlockOffset]) {
				if (AllocateIfNeeded) {
					RootBlock[NextBlockOffset] := this->AllocateBlock()
					
					TargetNode->DiskSectorsUsed += 2
					
					if (TargetNode->IsDirectory()) {
						TargetNode->FileSizeLow += 1024
					}
					
					this->WriteINode(TargetNode)
					
					if (WalkBlockIndex != 0) {
						this->WriteBlock(RootBlockNumber, RootBlock)
					}
				}
				else {
					return -1
				}
			}
			
			RootBlockNumber := RootBlock[NextBlockOffset]
			
			if (BlockCount != 1) {
				RootBlock := this->ReadBlock(RootBlockNumber)
			}
		}
		
		this->SwapTempBlocks()
		
		return RootBlockNumber
	}
	
	define i32 ReadINodeData(void* IntoBuffer, INode* TargetNode, i32 BlockIndex) {
		i32 TargetBlock := this->FindINodeDataBlock(TargetNode, BlockIndex, false)
		
		this->ReadBlock(TargetBlock, IntoBuffer)
		
		return TargetBlock
	}
	
	define i32 StartWalkDirectory(INode* DirectoryNode) {
		this->ReadINodeData(this->TempBlock, DirectoryNode, 0)
		return 0
	}
	define DirectoryEntry* WalkDirectoryNext(INode* DirectoryNode, i32* pWalkHandle) {
		i32 Offset := *pWalkHandle
		
		;Print("WalkDirectoryNext: %i %i[%i]\n", DirectoryNode->INodeNumber, *pWalkHandle, DirectoryNode->FileSizeLow)
		
		if (Offset >= DirectoryNode->FileSizeLow) {
			return null
		}
		
		i32 BlockNumber := Offset / 1024
		i32 BlockOffset := Offset % 1024
		
		if (this->ReadINodeData(this->TempBlock, DirectoryNode, BlockNumber) = 0) {
			return null
		}
		
		DirectoryEntry* NextEntry := this->TempBlock + BlockOffset
		
		pWalkHandle[0] += NextEntry->EntryLength
		
		return NextEntry
	}
	define DirectoryEntry* FindDirectoryEntryByName(INode* Directory, i8* Name) {
		i32 State := this->StartWalkDirectory(Directory)
		
		loop {
			DirectoryEntry* NextEntry := this->WalkDirectoryNext(Directory, &State)
			
			if (NextEntry = null) {
				return null
			}
			else if (NextEntry->NameEquals(Name)) {
				return NextEntry
			}
		}
	}
	define DirectoryEntry* FindDirectoryEntryBySplitPath(INode* RootDirectory, i8** SplitPath, i32 SplitCount) {
		;Print("Looking up ")
		;
		;for (i32 I := 0, I < SplitCount, I += 1) {
		;	Print("%s", SplitPath[I])
		;	
		;	if (I + 1 != SplitCount) {
		;		Print("%c", '/')
		;	}
		;}
		
		SplitCount -= 1
		
		;Print("\nGot root directory, size = %x\n", RootDirectory->FileSizeLow)
		
		for (i32 Depth := 0, Depth <= SplitCount, Depth += 1) {
			DirectoryEntry* Next := this->FindDirectoryEntryByName(RootDirectory, SplitPath[Depth])
			
			if (Next = null) {
				return null
			}
			
			if (Depth = SplitCount) {
				return Next
			}
			;else {
				;Print("Found at wrong depth/names, %i and %i, '%s' and '%s'\n", Depth, SplitCount, Next~>Name, SplitPath[SplitCount])
			;}
			
			RootDirectory := this->ReadINode(Next->INode)
		}
		
		return null
	}
	define DirectoryEntry* FindDirectoryEntryByPath(INode* RootDirectory, i8* Path) {
		i32 Length := StringLength(Path)
		
		loop {
			for (i32 Index := 0, Index < Length, Index += 1) {
				if (Path[Index] = '/') {
					Path[Index] := 0
					break
				}
			}
			
			;Print("Next '%s' %i\n", Path, Length)
			
			Length -= Index
			
			DirectoryEntry* Next := this->FindDirectoryEntryByName(RootDirectory, Path)
			
			if (Next = null) {
				return null
			}
			else if (Length = 0) {
				return Next
			}
			
			Path[Index] := '/'
			Path += Index + 1
			RootDirectory := this->ReadINode(Next->INode)
		}
	}
	
	define i32 AllocateInBitmap(i8* Bitmap, i32 Max) {
		for (i32 Index := 0, Index < Max, Index += 1) {
			i32 ByteIndex := Index / 8
			i32 BitIndex := Index % 8
			i32 BitMask := 1 << (BitIndex As i8)
			
			i8 TargetByte := Bitmap[ByteIndex]
			
			if !(TargetByte & BitMask) {
				Bitmap[ByteIndex] := TargetByte | BitMask
				
				return Index + 1
			}
		}
		
		return 0
	}
	define i32 Allocate(i8 GetBlock) {
		i32 BlocksPerGroup := this->SuperBlock->BlocksPerGroup
		i32 TotalBlockGroups := this->SuperBlock->TotalBlocks / BlocksPerGroup + 1
		i32 INodesPerGroup := this->SuperBlock->INodesPerGroup
		
		i32 MaxPerGroup := INodesPerGroup
		
		if (GetBlock) {
			MaxPerGroup := BlocksPerGroup
		}
		
		for (i32 BlockGroupIndex := 0, BlockGroupIndex < TotalBlockGroups, BlockGroupIndex += 1) {
			BlockGroupDescriptor* BGD := this->GetBlockGroupDescriptor(BlockGroupIndex)
			
			i32 BitmapBlock := BGD->INodeBitmap
			
			if (GetBlock) {
				BitmapBlock := BGD->BlockBitmap
				
				BGD->UnallocatedBlocks -= 1
				this->SuperBlock->UnallocatedBlocks -= 1
			}
			else {
				BGD->UnallocatedINodes -= 1
				this->SuperBlock->UnallocatedINodes -= 1
			}
			
			this->CommitBlockGroupDescriptors()
			this->CommitSuperBlock()
			
			;Print("Block group %i bitmap%i at %i\n", BlockGroupIndex, GetBlock, BitmapBlock)
			
			i8* Bitmap := this->ReadBlock(BitmapBlock)
			
			i32 Result := this->AllocateInBitmap(Bitmap, MaxPerGroup)
			
			if (Result) {
				/* Commit the allocation to the file system */
				this->WriteBlock(BitmapBlock, Bitmap)
				
				return Result
			}
		}
		
		return 0
	}
	define i32 AllocateINode() {
		return this->Allocate(0)
	}
	define i32 AllocateBlock() {
		return this->Allocate(1)
	}
	
	define void FreeBlock(i32 BlockNumber) {
		BlockNumber -= 1
		
		i32 BlocksPerGroup := this->SuperBlock->BlocksPerGroup
		i32 TotalBlockGroups := this->SuperBlock->TotalBlocks / BlocksPerGroup + 1
		
		i32 TargetGroup := BlockNumber / BlocksPerGroup
		i32 TargetOffset := BlockNumber % BlocksPerGroup
		
		BlockGroupDescriptor* TrueGroup := this->GetBlockGroupDescriptor(TargetGroup)
		
		i32 BlockBitmapBlock := TrueGroup->BlockBitmap
		
		i8* BlockBitmap := this->ReadBlock(BlockBitmapBlock) As i8*
		
		i32 ByteIndex := TargetOffset / 8
		i32 BitIndex := TargetOffset % 8
		i32 BitMask := 1 << (BitIndex As i8)
		
		i8 TargetByte := BlockBitmap[ByteIndex]
		
		if (TargetByte & BitMask) {
			BlockBitmap[ByteIndex] := TargetByte ^ BitMask
		}
		else {
			Print("Attempt to free free block %x\n", BlockNumber)
		}
		
		this->WriteBlock(BlockBitmapBlock, this->TempBlock)
	}
	
	define DirectoryEntry* DirectoryAppendEntry(INode* TargetNode, i8* Name, i32 NewNodeNumber, i8 Flags) {
		i32 NameLength := StringLength(Name)
		i32 RequiredSize := NameLength + #DirectoryEntry - 1
		
		i32 Remainder := RequiredSize % 4
		
		if (Remainder) {
			RequiredSize += 4 - Remainder
		}
		
		; To append a directory entry, we go through each directory entry in a directory and check if
		;  it has enough space between itself and the next directory entry to store a new directory entry
		;   for the info we are appending.
		
		i32 NextEntryOffset := this->StartWalkDirectory(TargetNode)
		DirectoryEntry* TailEntry := null
		i8 AllocatedNewBlock := false
		
		loop {
			DirectoryEntry* NextEntry := this->WalkDirectoryNext(TargetNode, &NextEntryOffset)
			
			if (NextEntry = null) {
				; If we've hit the final entry in the target directory, then we need to allocate a new
				;  data block for this directory, and write it back into the INode's block records
				
				i32 NewDataBlockIndex := NextEntryOffset / 1024
				
				this->FindINodeDataBlock(TargetNode, NewDataBlockIndex, true)
				i32 NewBlockNumber := this->FindINodeDataBlock(TargetNode, NewDataBlockIndex, false)
				
				Print("Allocated block %i for INode %i data block %i\n", NewBlockNumber, TargetNode->INodeNumber, NewDataBlockIndex)
				
				NextEntry := this->ReadBlock(NewBlockNumber)
				AllocatedNewBlock := true
				
				break
			}
			
			i32 Padding := NextEntry->PaddingSize()
			
			if (RequiredSize < Padding) {
				; If true, then we've found an entry which can hold our new entry
				break
			}
		}
		
		if (AllocatedNewBlock) {
			NextEntry->EntryLength := 1024
		}
		else {
			; Remove all padding from the previous entry, since we are inserting (Last->New->Padding->Next)
			;  where (Last->Padding->Next) used to be, meaning any padding is now "owned" by the new entry
			DirectoryEntry* LastEntry := NextEntry
			LastEntry->TrimPadding()
			
			NextEntry := LastEntry->Next()
			NextEntry->EntryLength := Padding
			
			NextEntryOffset -= Padding
		}
		
		NextEntry->INode := NewNodeNumber
		NextEntry->NameLength := NameLength
		NextEntry->Flags := Flags
		
		; Write the name into the entry
		MoveMemory(NextEntry~>Name, Name, NameLength)
		
		; Look up which data block the new entry belongs to, and write it (plus the edited last entry)
		;  into the data block
		i32 DataBlockIndex := NextEntryOffset / 1024
		i32 TrueBlockIndex := this->FindINodeDataBlock(TargetNode, DataBlockIndex, false)
		
		Print("AppendEntry NEO = %i, DBI = %i, TBI = %i\n", NextEntryOffset, DataBlockIndex, TrueBlockIndex)
		
		this->WriteBlock(TrueBlockIndex, this->TempBlock)
		
		return NextEntry
	}
	
	define void WriteINodeBlock(INode* Node, i32 BlockNumber, void* BlockData) {
		i32 NextBlock := Node~>DirectBlocks[BlockNumber]
		
		if !(NextBlock) {
			NextBlock := this->AllocateBlock()
			
			Print("Allocated free block %i\n", NextBlock)
			
			Node~>DirectBlocks[BlockNumber] := NextBlock
		}
		else {
			Print("Used existing block %i\n", NextBlock)
		}
		
		this->WriteBlock(NextBlock, BlockData)
	}
	define void WriteINodeData(i32 NodeNumber, void* Data, i32 DataLength) {
		Print("Finding INode %i for write\n", NodeNumber)
		
		INode* ForNode := this->ReadINode(NodeNumber)
		
		i32* NodeBlocks := ForNode~>DirectBlocks
		
		Print("Allocating and writing blocks\n")
		
		i32 BlockCount := DataLength / 1024
		i32 Remainder := DataLength % 1024
		
		for (i32 Index := 0, Index < BlockCount, Index += 1) {
			this->WriteINodeBlock(ForNode, Index, Data + Index * 1024)
		}
		
		if (Remainder) {
			i8* TempBuffer := this->TempBlock
			
			MoveMemory(TempBuffer, Data + Index * 1024, Remainder)
			
			for (i32 ZeroIndex := Remainder, ZeroIndex < 1024, ZeroIndex += 1) {
				TempBuffer[ZeroIndex] := 0
			}
			
			this->WriteINodeBlock(ForNode, Index, TempBuffer)
			
			Index += 1
		}
		
		NodeBlocks[Index] := 0 /* Signal that the file does not contain any more data */
		
		ForNode->FileSizeLow := DataLength
		ForNode->DiskSectorsUsed := (Index - 1) * 1024
		
		this->WriteINode(NodeNumber, ForNode)
	}
	
	define i32 GetPathTail(i8* Path) {
		i32 Length := StringLength(Path)
		i32 TailIndex := 0
		
		for (i32 Index := 0, Index < Length, Index += 1) {
			i8 NextCharacter := Path[Index]
			
			if (NextCharacter = '/') {
				TailIndex := Index + 1
			}
		}
		
		return TailIndex
	}
	
	define i32 MakeFile(INode* RootDirectory, i8* Path, i8 EntryType, INode** OutNode, i32* OutContainingNodeNumber) {
		i32 NameIndex := this->GetPathTail(Path)
		i8* FileName := &Path[NameIndex]
		
		INode* ContainingNode := RootDirectory
		
		if (NameIndex != 0) {
			i8* PathHead := CloneMemory(Path, NameIndex - 1)
			PathHead[NameIndex] := 0
			
			DirectoryEntry* ContainingEntry := this->FindDirectoryEntryByPath(RootDirectory, PathHead)
			ContainingNode := this->ReadINode(ContainingEntry->INode)
			
			Free(PathHead)
		}
		
		if (OutContainingNodeNumber != null) {
			OutContainingNodeNumber[0] := ContainingNode->INodeNumber
		}
		
		DirectoryEntry* ExistingEntry := this->FindDirectoryEntryByName(ContainingNode, FileName)
		
		if (ExistingEntry != null) {
			return -1
		}
		
		i32 NewFileNodeNumber := this->AllocateINode()
		
		this->DirectoryAppendEntry(ContainingNode, FileName, NewFileNodeNumber, EntryType)
		
		INode* NewNode := this->ReadINode(NewFileNodeNumber)
		NewNode->SetFieldDefaults()
		
		if (EntryType = DIRECTORY_ENTRY_DIRECTORY) {
			NewNode->MakeDirectory()
		}
		else {
			NewNode->MakeFile()
		}
		
		this->WriteINode(NewNode)
		
		if (OutNode != null) {
			OutNode[0] := NewNode
		}
		
		return NewFileNodeNumber
	}
	
	define i32 MakeFile(INode* RootDirectory, i8* Path) {
		return this->MakeFile(RootDirectory, Path, DIRECTORY_ENTRY_FILE, 0 As INode**, null)
	}
	
	define i32 MakeDirectory(INode* RootDirectory, i8* Path) {
		INode* NewNode := null
		i32 ContainingNodeNumber := 0
		
		i32 NewNodeNumber := this->MakeFile(RootDirectory, Path, DIRECTORY_ENTRY_DIRECTORY, &NewNode, &ContainingNodeNumber)
		
		if (NewNodeNumber <= 0) {
			return -1
		}
		
		this->DirectoryAppendEntry(NewNode, ".", NewNodeNumber, DIRECTORY_ENTRY_DIRECTORY)
		this->DirectoryAppendEntry(NewNode, "..", ContainingNodeNumber, DIRECTORY_ENTRY_DIRECTORY)
		
		return NewNodeNumber
	}
}

define i32 SplitPath(i8* Path, i8** Into, i32 Max) {
	i32 Count := 0
	i32 Start := 0
	
	for (i32 Index := 0, Path[Index] != 0, Index += 1) {
		if (Path[Index] = '/') {
			Into[Count] := Path + Start
			Count += 1
			
			if (Count = Max) {
				return Count
			}
			
			Path[Index] := 0
			Start := Index + 1
		}
	}
	
	Into[Count] := Path + Start
	Count += 1
	
	return Count
}

define void Tabs(i32 Count) {
	for (i32 Index := 0, Index < Count, Index += 1) {
		Print("	")
	}
}

define void DirectoryTree(Ext2* FS, INode* Root, i32 TabCount) {
	i32 State := FS->StartWalkDirectory(Root)
	
	loop {
		DirectoryEntry* NextEntry := FS->WalkDirectoryNext(Root, &State)
		
		if (NextEntry = null) {
			break
		}
		
		INode* NextNode := FS->ReadINode(NextEntry->INode)
		
		if (NextEntry->NameLength != 0) {
			Tabs(TabCount)
			Print("%x	%s\n", NextNode->FileSizeLow, NextEntry~>Name)
		}
		
		if (NextNode->GetType() = 0x4 && NextEntry~>Name[0] != '.') {
			INode* NextDirectory := CloneMemory(NextNode, #INode)
			
			DirectoryTree(FS, NextDirectory, TabCount + 1)
			
			Free(NextDirectory)
		}
	}
}

define void Prompt(Ext2* FS) {
	INode* RootINode := CloneMemory(FS->ReadINode(2), #INode)
	
	loop {
		Print("^90->^F0")
		i8* NextLine := ReadLine()
		
		i64 ArgC := 0
		i8** ArgV := null
		
		ParseCommandLine(NextLine, &ArgC, &ArgV)
		i8* Command := ArgV[0]
		i8* Path := ArgV[1]
		
		if (StringEquals(Command, "ls")) {
			i32 NextEntryOffset := FS->StartWalkDirectory(RootINode)
			
			loop {
				DirectoryEntry* NextEntry := FS->WalkDirectoryNext(RootINode, &NextEntryOffset)
				
				if (NextEntry = null) {
					break
				}
				
				INode* NextNode := FS->ReadINode(NextEntry->INode)
				
				if (NextNode->IsDirectory()) {
					Print(" ^20D^F0 ")
				}
				else {
					Print(" ^A0F^F0 ")
				}
				
				Print("%x	%x	%s\n", NextEntry->INode, NextNode->FileSizeLow, NextEntry~>Name)
			}
		}
		else if (StringEquals(Command, "cd")) {
			DirectoryEntry* NewRootEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (NewRootEntry = null || !NewRootEntry->IsDirectory()) {
				Print(" Could not find directory '^C0%s^F0'\n", Path)
			}
			else {
				Print(" CD to '^A0%s^F0', INode ^A0%x^F0\n", Path, NewRootEntry->INode)
				
				Free(RootINode)
				RootINode := FS->CloneINode(NewRootEntry->INode)
			}
		}
		else if (StringEquals(Command, "bi")) {
			DirectoryEntry* FoundNodeEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (FoundNodeEntry = null) {
				Print(" Could not find file/directory '^C0%s^F0'\n", Path)
			}
			else {
				INode* FoundNode := FS->CloneINode(FoundNodeEntry->INode)
				
				i32 BlockCount := FoundNode->FileSizeLow / 1024
				
				if (FoundNode->FileSizeLow % 1024) {
					BlockCount += 1
				}
				
				Print(" ^A0%i^F0 total blocks, ^A0%i^F0 total size\n", BlockCount, FoundNode->FileSizeLow)
				
				for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex += 1) {
					i32 Temp := FS->FindINodeDataBlock(FoundNode, BlockIndex, false)
					
					Print("  ^20%i^F0 = Blocks[^20%i^F0]\n", BlockIndex, Temp)
				}
				
				Free(FoundNode)
			}
		}
		else if (StringEquals(Command, "cat")) {
			DirectoryEntry* FoundFileEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (FoundFileEntry = null || !FoundFileEntry->IsFile()) {
				Print(" Could not find file '^C0%s^F0'\n", Path)
			}
			else {
				INode* FoundFileNode := FS->CloneINode(FoundFileEntry->INode)
				
				i32 FileBlockCount := FoundFileNode->FileSizeLow / 1024
				
				if (FoundFileNode->FileSizeLow % 1024) {
					FileBlockCount += 1
				}
				
				for (i32 FileBlockIndex := 0, FileBlockIndex < FileBlockCount, FileBlockIndex += 1) {
					i32 FileDataBlock := FS->FindINodeDataBlock(FoundFileNode, FileBlockIndex, false)
					Print("%s", FS->ReadBlock(FileDataBlock))
				}
				
				Print("\n Done, ^A0%i^F0 blocks printed\n", FileBlockCount)
				
				Free(FoundFileNode)
			}
		}
		else if (StringEquals(Command, "touch")) {
			i32 CreatedFileNodeNumber := FS->MakeFile(RootINode, Path)
			
			if (CreatedFileNodeNumber = -1) {
				Print(" File '^C0%s^F0' already exists\n", Path)
			}
			else {
				Print(" Created new file at '^A0%s^F0', INode ^A0%i^F0\n", Path, CreatedFileNodeNumber)
			}
		}
		else if (StringEquals(Command, "mkdir")) {
			i32 CreatedDirectoryNodeNumber := FS->MakeDirectory(RootINode, Path)
			
			if (CreatedDirectoryNodeNumber = -1) {
				Print(" Directory '^C0%s^F0' already exists\n", Path)
			}
			else {
				Print(" Created new directory at '^A0%s^F0', INode ^A0%i^F0\n", Path, CreatedDirectoryNodeNumber)
			}
		}
		else if (StringEquals(Command, "bg")) {
			i32 Index := AToI(Path)
			Print("%i = \n", Index)
			BlockGroupDescriptor* BGD := FS->GetBlockGroupDescriptor(Index)
			
			BGD->Print()
		}
		else if (StringEquals(Command, "tree")) {
			DirectoryTree(FS, RootINode, 0)
		}
		else if (StringEquals(Command, "quit")) {
			Free(ArgV)
			break
		}
		
		Free(ArgV)
	}
}