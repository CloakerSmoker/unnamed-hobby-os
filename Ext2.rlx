#Require "./src/lib/Memory.rlx"
#Require "./src/lib/Console.rlx"
#Require "./src/lib/File.rlx"

i16 EXT2_SUPER_MAGIC := 0xEF53 As i16

i16 EXT2_VALID_FS := 1
i16 EXT2_ERROR_FS := 2

i16 EXT2_IGNORE_ERROR := 1

struct SuperBlock {
	i32 TotalINodes,
	i32 TotalBlocks,
	
	i32 ReservedBlocks,
	
	i32 UnallocatedBlocks,
	i32 UnallocatedINodes,
	
	i32 SuperBlockNumber,
	
	i32 BlockSize,
	i32 FragmentSize,
	
	i32 BlocksPerGroup,
	i32 FragmentsPerGroup,
	i32 INodesPerGroup,
	
	i32 LastMountTime,
	i32 LastWriteTime,
	
	i16 MountCount,
	i16 MaxMountCount,
	
	i16 Magic,
	i16 State,
	i16 ErrorMode,
	
	i16 MinorRevision,
	
	i32 LastCheckTime,
	i32 CheckInterval,
	
	i32 CreatorOS,
	
	i32 RevisionLevel,
	
	i16 DefaultUserID,
	i16 DefaultGroupID
	
	define void SetFieldDefaults() {
		this->SuperBlockNumber := 1
		this->BlockSize := 0
		this->FragmentSize := 0
		
		this->MountCount := 1
		this->MaxMountCount := 0xFFFF As i16
		
		this->Magic := EXT2_SUPER_MAGIC
		this->State := EXT2_VALID_FS
		this->ErrorMode := EXT2_IGNORE_ERROR
		
		this->MinorRevision := 0
		
		this->CheckInterval := 0
		
		this->CreatorOS := 0
		this->RevisionLevel := 0
	}
	define void Print() {
		Print("SuperBlock {\n")
		Print("	TotalINodes: %i\n", this->TotalINodes)
		Print("	TotalBlocks: %i\n", this->TotalBlocks)
		Print("	ReservedBlocks: %i\n", this->ReservedBlocks)
		Print("	UnallocatedBlocks: %i\n", this->UnallocatedBlocks)
		Print("	UnallocatedINodes: %i\n", this->UnallocatedINodes)
		Print("	SuperBlockNumber: %i\n", this->SuperBlockNumber)
		Print("	BlockSize: %i\n", this->BlockSize)
		Print("	FragmentSize: %i\n", this->FragmentSize)
		Print("	BlocksPerGroup: %i\n", this->BlocksPerGroup)
		Print("	FragmentsPerGroup: %i\n", this->FragmentsPerGroup)
		Print("	INodesPerGroup: %i\n", this->INodesPerGroup)
		Print("	MountCount: %i\n", this->MountCount)
		Print("	MaxMountCount: %i\n", this->MaxMountCount)
		Print("	Magic: %x\n", this->Magic)
		Print("	State: %i\n", this->State)
		Print("	ErrorMode: %i\n", this->ErrorMode)
		Print("	MinorRevision: %i\n", this->MinorRevision)
		Print("	CheckInterval: %i\n", this->CheckInterval)
		Print("	CreatorOS: %i\n", this->CreatorOS)
		Print("	RevisionLevel: %i\n", this->RevisionLevel)
		Print("}\n")
	}
}
struct BlockGroupDescriptor {
	i32 BlockBitmap,
	i32 INodeBitmap,
	i32 INodeTable,
	i16 UnallocatedBlocks,
	i16 UnallocatedINodes,
	i16 DirectoryCount,
	i8{14} Padding
	
	define void Print() {
		Print("BlockGroupDescriptor {\n")
		Print("	BlockBitmap: %i \t(sector %i | offset %x)\n", this->BlockBitmap, this->BlockBitmap * 2, this->BlockBitmap * 1024)
		Print("	INodeBitmap: %i \t(sector %i | offset %x)\n", this->INodeBitmap, this->INodeBitmap * 2, this->INodeBitmap * 1024)
		Print("	INodeTable: %i \t(sector %i | offset %x)\n", this->INodeTable, this->INodeTable * 2, this->INodeTable * 1024)
		Print("	UnallocatedBlocks: %i\n", this->UnallocatedBlocks)
		Print("	UnallocatedINodes: %i\n", this->UnallocatedINodes)
		Print("}\n")
	}
}

i8 INODE_FILE := 0x8
i8 INODE_DIRECTORY := 0x4

struct INode {
	union {
		i16 Permissions,
		i16 Type
	}
	
	i16 UserID,
	i32 FileSizeLow,
	
	i32 LastAccessTime,
	i32 CreationTime,
	i32 LastModificationTime,
	i32 DeletionTime,
	
	i16 GroupID,
	i16 HardLinkCount,
	i32 DiskSectorsUsed,
	i32 Flags,
	
	union {
		i32 OSValue,
		i32 INodeNumber
	}
	
	i32{12} DirectBlocks,
	i32 SingleIndirectBlock,
	i32 DoubleIndirectBlock,
	i32 TripleIndirectBlock,
	
	i32 GenerationNumber,
	i64 Reserved,
	i32 FragmentAddress,
	
	i32{4} OSValues
	
	define void SetFieldDefaults() {
		this->Permissions := (0x1B4 | 0x8000) As i16
		this->UserID := 1000
		this->GroupID := 1000
		this->FileSizeLow := 0
		this->HardLinkCount := 1
		this->DiskSectorsUsed := 2
		this->GenerationNumber := 0x981237 ^ (this As i32)
	}
	
	define i16 GetPermissions() {
		return (this->Flags & 0x0FFF) As i16
	}
	define i16 GetType() {
		return ((this->Type & 0xF000) >> 12) As i16
	}
	
	define void Chmod(i8 Override, i8 User, i8 Group, i8 Other) {
		i16 Type := this->GetType()
		
		this->Permissions := ((Type << 12) | (Override << 9) | (User << 6) | (Group << 3) | Other) As i16
	}
	
	define void SetType(i8 Type) {
		this->Type := (this->GetPermissions() | Type << 12) As i16
	}
	define void MakeDirectory() {
		this->SetType(INODE_DIRECTORY)
	}
	define void MakeFile() {
		this->SetType(INODE_FILE)
	}
	define i8 IsDirectory() {
		return this->GetType() = INODE_DIRECTORY
	}
	define i8 IsFile() {
		return this->GetType() = INODE_FILE
	}
}

i8 DIRECTORY_ENTRY_FILE := 1
i8 DIRECTORY_ENTRY_DIRECTORY := 2

struct DirectoryEntry {
	i32 INode,
	i16 EntryLength,
	i8 NameLength,
	i8 Flags,
	i8{1} Name
	
	define i16 TrueSize() {
		i32 Result := this->NameLength + 8
		i32 Remainder := Result % 4
		
		if (Remainder) {
			Result += 4 - Remainder
		}
		
		return Result As i16
	}
	define i16 PaddingSize() {
		return this->EntryLength - this->TrueSize()
	}
	
	define void TrimPadding() {
		this->EntryLength := this->TrueSize()
	}
	define DirectoryEntry* Next() {
		return this + (this->EntryLength + 0)
	}
	
	define i8 IsDirectory() {
		return this->Flags = DIRECTORY_ENTRY_DIRECTORY
	}
	define i8 IsFile() {
		return this->Flags = DIRECTORY_ENTRY_FILE
	}
	define void MakeDirectory() {
		this->Flags := DIRECTORY_ENTRY_DIRECTORY
	}
	define void MakeFile() {
		this->Flags := DIRECTORY_ENTRY_FILE
	}
	
	define i8 NameEquals(i8* OtherName) {
		if (StringLength(OtherName) != this->NameLength) {
			return false
		}
		
		for (i32 Index := 0, Index < this->NameLength, Index += 1) {
			if (OtherName[Index] != this~>Name[Index]) {
				return false
			}
		}
		
		return true
	}
}

i32 EXT2_SUPERBLOCK_NUMBER := 1
i32 EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER := 2

struct Ext2DeviceTraits {
	void* State
	void* ReadSector
	void* WriteSector
	
	static void Call(void* State, i32 Paramter, void* Data, void* Function) asm {
		jmp, rcx
	}
	
	define void ReadSectors(i32 StartSectorNumber, i32 SectorCount, void* Buffer) {
		i32 EndSectorNumber := StartSectorNumber + SectorCount
		
		;Print("Read %i-%i, %i total\n", StartSectorNumber, EndSectorNumber, SectorCount)
		
		for (i32 Sector := StartSectorNumber, Sector < EndSectorNumber, Sector++) {
			Ext2DeviceTraits:Call(this->State, Sector, Buffer, this->ReadSector)
			Buffer += 0x200
		}
	}
	define void WriteSectors(i32 StartSectorNumber, i32 SectorCount, void* Buffer) {
		i32 EndSectorNumber := StartSectorNumber + SectorCount
		
		for (i32 Sector := StartSectorNumber, Sector < EndSectorNumber, Sector++) {
			Ext2DeviceTraits:Call(this->State, Sector, Buffer, this->WriteSector)
			Buffer += 0x200
		}
	}
}

i32 EXT2_RESERVED_BLOCKS_PER_GROUP := 4

struct Ext2CreationParameters {
	i32 BlockSize
	i32 BlocksPerGroup
	i32 INodesPerGroup
	
	i32 BlockCount
	i32 BlockGroupCount
	i32 INodeCount
	i32 INodeTableSize
	i32 FinalGroupSize
	
	define void SetDefaults() {
		this->BlockSize := 0x400
		this->BlocksPerGroup := 0x2000
		this->INodesPerGroup := 0x800
	}
	
	
	define void AssumeFromStorageSize(i32 Size) {
		this->BlockCount := Size / this->BlockSize
		this->BlockGroupCount := (this->BlockCount / this->BlocksPerGroup) + 1
		this->INodeCount := this->BlockGroupCount * this->INodesPerGroup
		this->INodeTableSize := (this->INodeCount * #INode) / this->BlockSize
		this->FinalGroupSize := this->BlockCount % this->BlocksPerGroup
	}
	
	
}

#Require "./src/lib/Exception.rlx"

i64 EXT2_EXCEPTION_NO_DATA_BLOCK := 'EXT2_NDB'
i64 EXT2_EXCEPTION_DATA_OUT_OF_RANGE := 'EXT2_DRG'
i64 EXT2_EXCEPTION_BAD_PARAMETER := 'EXT2_BPM'
i64 EXT2_EXCEPTION_DEVICE_READ_ERROR := 'EXT2_DRE'
i64 EXT2_EXCEPTION_DEVICE_WRITE_ERROR := 'EXT2_DWE'

struct Ext2 {
	SuperBlock* SuperBlock
	BlockGroupDescriptor* BlockGroupTable
	
	void* TempINode
	
	i32 TempBlockNumber
	void* TempBlock
	
	void* ExtraTempBlock
	
	Ext2DeviceTraits* Traits
	
	static Ext2* New(Ext2DeviceTraits* Traits) {
		Ext2* this := Alloc(#Ext2)
		
		this->Traits := Traits
		
		return this
	}
	
	define void ReadSectors(i32 SectorNumber, i32 SectorCount, void* Buffer) {
		this->Traits->ReadSectors(SectorNumber, SectorCount, Buffer)
	}
	define void* ReadBlock(i32 BlockNumber, void* Buffer) {
		this->ReadSectors(BlockNumber * 2, 2, Buffer)
		
		return Buffer
	}
	
	define void Initialize(void* SuperBlockBuffer, void* TempINode, void* TempBlock, void* ExtraTempBlock) {
		this->TempINode := TempINode
		this->TempBlock := TempBlock
		this->ExtraTempBlock := ExtraTempBlock
		
		this->SuperBlock := SuperBlockBuffer
		this->BlockGroupTable := SuperBlockBuffer + 1024 As BlockGroupDescriptor*
		
		this->ReadBlock(EXT2_SUPERBLOCK_NUMBER, this->SuperBlock As void*)
		this->ReadBlock(EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER, this->BlockGroupTable As void*)
	}
	
	define void SwapTempBlocks() {
		void* Temp := this->TempBlock
		this->TempBlock := this->ExtraTempBlock
		this->ExtraTempBlock := Temp
	}
	
	define void* ReadBlock(i32 BlockNumber) {		
		if (this->TempBlockNumber != BlockNumber) {
			this->ReadSectors(BlockNumber * 2, 2, this->TempBlock)
		}
		
		return this->TempBlock
	}
	
	define void WriteSectors(i32 SectorNumber, i32 SectorCount, void* Data) {
		;Print("Writing %x bytes to %x\n", SectorCount * 512, SectorNumber * 512)
		
		this->Traits->WriteSectors(SectorNumber, SectorCount, Data)
	}
	define void WriteBlock(i32 BlockNumber, void* Data) {
		this->WriteSectors(BlockNumber * 2, 2, Data)
	}
	
	define BlockGroupDescriptor* GetBlockGroupDescriptor(i32 GroupNumber) {
		return this->BlockGroupTable + (GroupNumber * #BlockGroupDescriptor)
	}
	define void CommitBlockGroupDescriptors() {
		this->WriteBlock(EXT2_BLOCK_GROUP_DESCRIPTOR_TABLE_NUMBER, this->BlockGroupTable)
	}
	define void CommitSuperBlock() {
		this->WriteBlock(EXT2_SUPERBLOCK_NUMBER, this->SuperBlock)
	}
	
	define i32 FindINodeBlock(i32 INodeNumber, i32* OutINodeOffset) {
		INodeNumber -= 1
		
		i32 BlockSize := 1024 << (this->SuperBlock->BlockSize As i8)
		i32 INodeSize := 128
		i32 INodesPerGroup := this->SuperBlock->INodesPerGroup
		
		i32 GroupNumber := INodeNumber / INodesPerGroup
		i32 INodeIndex := INodeNumber % INodesPerGroup
		
		BlockGroupDescriptor* GroupDescriptor := this->GetBlockGroupDescriptor(GroupNumber)
		
		i32 GroupBaseBlock := GroupDescriptor->INodeTable
		
		i32 INodeOffset := INodeIndex * INodeSize
		i32 BlockNumber := INodeOffset / BlockSize
		i32 OffsetInBlock := INodeOffset % BlockSize
		
		OutINodeOffset[0] := OffsetInBlock
		return GroupBaseBlock + BlockNumber
	}
	define INode* ReadINode(i32 INodeNumber) {
		i32 OffsetInBlock := 0
		i32 BlockNumber := this->FindINodeBlock(INodeNumber, &OffsetInBlock)
		
		;Print("Reading INode %i from block %i:%i\n", INodeNumber, BlockNumber, OffsetInBlock + (0 As i64))
		
		INode* Result := this->ReadBlock(BlockNumber, this->TempINode) + OffsetInBlock
		
		Result->INodeNumber := INodeNumber
		
		return Result
	}
	define INode* CloneINode(i32 INodeNumber) {
		return CloneMemory(this->ReadINode(INodeNumber), #INode)
	}
	define void RefreshINode(INode* Node) {
		INode* NewData := this->ReadINode(Node->INodeNumber)
		
		if (Node != NewData) {
			MoveMemory(Node As i8*, NewData As i8*, #INode)
		}
	}
	define void WriteINode(i32 INodeNumber, INode* NewTargetNodeData) {
		i32 OffsetInBlock := 0
		i32 BlockNumber := this->FindINodeBlock(INodeNumber, &OffsetInBlock)
		
		void* OldBlockData := this->ReadBlock(BlockNumber)
		INode* OldTargetNodeData := (OldBlockData + OffsetInBlock) As INode*
		
		MoveMemory(OldTargetNodeData As i8*, NewTargetNodeData As i8*, #INode)
		
		this->WriteBlock(BlockNumber, OldBlockData)
	}
	define void WriteINode(INode* NewNode) {
		this->WriteINode(NewNode->INodeNumber, NewNode)
	}
	
	define i32 CalculateDataBlockPath(i32 DataBlockIndex, i32* BlockPath) {
		if (DataBlockIndex < 12) {
			BlockPath[0] := DataBlockIndex
			return 1
		}
		
		DataBlockIndex -= 12
		
		if (DataBlockIndex < 0x100) {
			BlockPath[0] := 12
			BlockPath[1] := DataBlockIndex
			return 2
		}
		
		DataBlockIndex -= 0x100
		
		if (DataBlockIndex < 0x10000) {
			BlockPath[0] := 13
			BlockPath[1] := DataBlockIndex / 0x100
			BlockPath[2] := DataBlockIndex % 0x100
			return 3
		}
		
		DataBlockIndex -= 0x10000
		
		if (DataBlockIndex < 0x1000000) {
			BlockPath[0] := 14
			BlockPath[1] := DataBlockIndex / 0x10000
			BlockPath[2] := DataBlockIndex % 0x10000
			BlockPath[3] := DataBlockIndex % 0x100
			return 4
		}
		
		Throw(EXT2_EXCEPTION_DATA_OUT_OF_RANGE)
		
		return 0
	}
	
	declare i32 AllocateBlock()
	
	define i32 FindINodeDataBlock(INode* TargetNode, i32 DataBlockIndex, i8 AllocateIfNeeded) {
		;Print("FIDB %i, %i, %i\n", TargetNode->INodeNumber, DataBlockIndex, AllocateIfNeeded)
		
		i32{4} BlockPath
		
		i32 BlockCount := this->CalculateDataBlockPath(DataBlockIndex, BlockPath)
		i32* RootBlock := TargetNode~>DirectBlocks
		i32 RootBlockNumber := 0
		
		;Print(" Got path for node %i block %i, %i long\n", TargetNode->INodeNumber, DataBlockIndex, BlockCount)
		
		this->SwapTempBlocks()
		
		for (i32 WalkBlockIndex := 0, WalkBlockIndex < BlockCount, WalkBlockIndex += 1) {
			i32 NextBlockOffset := BlockPath[WalkBlockIndex]
			
			;Print("  Path[%i] = %i\n", WalkBlockIndex, RootBlock[NextBlockOffset])
			
			if !(RootBlock[NextBlockOffset]) {
				if (AllocateIfNeeded) {
					RootBlock[NextBlockOffset] := this->AllocateBlock()
					
					TargetNode->DiskSectorsUsed += 2
					
					if (TargetNode->IsDirectory()) {
						TargetNode->FileSizeLow += 1024
					}
					
					this->WriteINode(TargetNode)
					
					if (WalkBlockIndex != 0) {
						this->WriteBlock(RootBlockNumber, RootBlock)
					}
				}
				else {
					this->SwapTempBlocks()
					
					Throw(EXT2_EXCEPTION_NO_DATA_BLOCK)
				}
			}
			
			RootBlockNumber := RootBlock[NextBlockOffset]
			
			if (BlockCount != 1) {
				RootBlock := this->ReadBlock(RootBlockNumber)
			}
		}
		
		this->SwapTempBlocks()
		
		return RootBlockNumber
	}
	
	define i32 ReadINodeData(void* IntoBuffer, INode* TargetNode, i32 BlockIndex) {
		i32 TargetBlock := this->FindINodeDataBlock(TargetNode, BlockIndex, false)
		
		this->ReadBlock(TargetBlock, IntoBuffer)
		
		return TargetBlock
	}
	
	define i32 StartWalkDirectory(INode* DirectoryNode) {
		this->ReadINodeData(this->TempBlock, DirectoryNode, 0)
		return 0
	}
	define DirectoryEntry* WalkDirectoryNext(INode* DirectoryNode, i32* pWalkHandle) {
		i32 Offset := *pWalkHandle
		
		;Print("WalkDirectoryNext: %i %i[%i]\n", DirectoryNode->INodeNumber, *pWalkHandle, DirectoryNode->FileSizeLow)
		
		if (Offset >= DirectoryNode->FileSizeLow) {
			return null
		}
		
		i32 BlockNumber := Offset / 1024
		i32 BlockOffset := Offset % 1024
		
		if (this->ReadINodeData(this->TempBlock, DirectoryNode, BlockNumber) = 0) {
			return null
		}
		
		DirectoryEntry* NextEntry := this->TempBlock + BlockOffset
		
		pWalkHandle[0] += NextEntry->EntryLength
		
		return NextEntry
	}
	define DirectoryEntry* FindDirectoryEntryByName(INode* Directory, i8* Name) {
		i32 State := this->StartWalkDirectory(Directory)
		
		loop {
			DirectoryEntry* NextEntry := this->WalkDirectoryNext(Directory, &State)
			
			if (NextEntry = null) {
				return null
			}
			else if (NextEntry->NameEquals(Name)) {
				return NextEntry
			}
		}
		
		return null
	}
	define DirectoryEntry* FindDirectoryEntryBySplitPath(INode* RootDirectory, i8** SplitPath, i32 SplitCount) {
		;Print("Looking up ")
		;
		;for (i32 I := 0, I < SplitCount, I += 1) {
		;	Print("%s", SplitPath[I])
		;	
		;	if (I + 1 != SplitCount) {
		;		Print("%c", '/')
		;	}
		;}
		
		SplitCount -= 1
		
		;Print("\nGot root directory, size = %x\n", RootDirectory->FileSizeLow)
		
		for (i32 Depth := 0, Depth <= SplitCount, Depth += 1) {
			DirectoryEntry* Next := this->FindDirectoryEntryByName(RootDirectory, SplitPath[Depth])
			
			if (Next = null) {
				return null
			}
			
			if (Depth = SplitCount) {
				return Next
			}
			;else {
				;Print("Found at wrong depth/names, %i and %i, '%s' and '%s'\n", Depth, SplitCount, Next~>Name, SplitPath[SplitCount])
			;}
			
			RootDirectory := this->ReadINode(Next->INode)
		}
		
		return null
	}
	define DirectoryEntry* FindDirectoryEntryByPath(INode* RootDirectory, i8* Path) {
		i32 Length := StringLength(Path)
		
		loop {
			for (i32 Index := 0, Index < Length, Index += 1) {
				if (Path[Index] = '/') {
					Path[Index] := 0
					break
				}
			}
			
			;Print("Next '%s' %i\n", Path, Length)
			
			Length -= Index
			
			DirectoryEntry* Next := this->FindDirectoryEntryByName(RootDirectory, Path)
			
			if (Next = null) {
				return null
			}
			else if (Length = 0) {
				return Next
			}
			
			Path[Index] := '/'
			Path += Index + 1
			RootDirectory := this->ReadINode(Next->INode)
		}
		
		return null
	}
	
	define i32 AllocateInBitmap(i8* Bitmap, i32 Max) {
		for (i32 Index := 0, Index < Max, Index += 1) {
			i32 ByteIndex := Index / 8
			i32 BitIndex := Index % 8
			i32 BitMask := 1 << (BitIndex As i8)
			
			i8 TargetByte := Bitmap[ByteIndex]
			
			if !(TargetByte & BitMask) {
				Bitmap[ByteIndex] := (TargetByte | BitMask) As i8
				
				return Index + 1
			}
		}
		
		return 0
	}
	define i32 Allocate(i8 GetBlock) {
		i32 BlocksPerGroup := this->SuperBlock->BlocksPerGroup
		i32 TotalBlockGroups := this->SuperBlock->TotalBlocks / BlocksPerGroup + 1
		i32 INodesPerGroup := this->SuperBlock->INodesPerGroup
		
		i32 MaxPerGroup := INodesPerGroup
		
		if (GetBlock) {
			MaxPerGroup := BlocksPerGroup
		}
		
		for (i32 BlockGroupIndex := 0, BlockGroupIndex < TotalBlockGroups, BlockGroupIndex += 1) {
			BlockGroupDescriptor* BGD := this->GetBlockGroupDescriptor(BlockGroupIndex)
			
			i32 BitmapBlock := BGD->INodeBitmap
			
			if (GetBlock) {
				BitmapBlock := BGD->BlockBitmap
				
				BGD->UnallocatedBlocks -= 1
				this->SuperBlock->UnallocatedBlocks -= 1
			}
			else {
				BGD->UnallocatedINodes -= 1
				this->SuperBlock->UnallocatedINodes -= 1
			}
			
			this->CommitBlockGroupDescriptors()
			this->CommitSuperBlock()
			
			;Print("Block group %i bitmap%i at %i\n", BlockGroupIndex, GetBlock, BitmapBlock)
			
			i8* Bitmap := this->ReadBlock(BitmapBlock)
			
			i32 Result := this->AllocateInBitmap(Bitmap, MaxPerGroup)
			
			if (Result) {
				/* Commit the allocation to the file system */
				this->WriteBlock(BitmapBlock, Bitmap)
				
				return Result
			}
		}
		
		return 0
	}
	define i32 AllocateINode() {
		return this->Allocate(0)
	}
	define i32 AllocateBlock() {
		return this->Allocate(1)
	}
	
	define void FreeBlock(i32 BlockNumber) {
		BlockNumber -= 1
		
		i32 BlocksPerGroup := this->SuperBlock->BlocksPerGroup
		i32 TotalBlockGroups := this->SuperBlock->TotalBlocks / BlocksPerGroup + 1
		
		i32 TargetGroup := BlockNumber / BlocksPerGroup
		i32 TargetOffset := BlockNumber % BlocksPerGroup
		
		BlockGroupDescriptor* TrueGroup := this->GetBlockGroupDescriptor(TargetGroup)
		
		i32 BlockBitmapBlock := TrueGroup->BlockBitmap
		
		i8* BlockBitmap := this->ReadBlock(BlockBitmapBlock) As i8*
		
		i32 ByteIndex := TargetOffset / 8
		i32 BitIndex := TargetOffset % 8
		i32 BitMask := 1 << (BitIndex As i8)
		
		i8 TargetByte := BlockBitmap[ByteIndex]
		
		if (TargetByte & BitMask) {
			BlockBitmap[ByteIndex] := (TargetByte ^ BitMask) As i8
		}
		else {
			Print("Attempt to free free block %x\n", BlockNumber)
		}
		
		this->WriteBlock(BlockBitmapBlock, this->TempBlock)
	}
	
	define DirectoryEntry* DirectoryAppendEntry(INode* TargetNode, i8* Name, i32 NewNodeNumber, i8 Flags) {
		i32 NameLength := StringLength(Name)
		i32 RequiredSize := NameLength + #DirectoryEntry - 1
		
		i32 Remainder := RequiredSize % 4
		
		if (Remainder) {
			RequiredSize += 4 - Remainder
		}
		
		; To append a directory entry, we go through each directory entry in a directory and check if
		;  it has enough space between itself and the next directory entry to store a new directory entry
		;   for the info we are appending.
		
		try {
			i32 NextEntryOffset := this->StartWalkDirectory(TargetNode)
			i8 AllocatedNewBlock := false
			
			loop {
				DirectoryEntry* NextEntry := this->WalkDirectoryNext(TargetNode, &NextEntryOffset)
				
				if (NextEntry = null) {
					; If we've hit the final entry in the target directory, then we need to allocate a new
					;  data block for this directory, and write it back into the INode's block records
					
					i32 NewDataBlockIndex := NextEntryOffset / 1024
					
					i32 NewBlockNumber := this->FindINodeDataBlock(TargetNode, NewDataBlockIndex, true)
					
					Print("Allocated block %i for INode %i data block %i\n", NewBlockNumber, TargetNode->INodeNumber, NewDataBlockIndex)
					
					NextEntry := this->ReadBlock(NewBlockNumber)
					AllocatedNewBlock := true
					
					break
				}
				
				i32 Padding := NextEntry->PaddingSize()
				
				if (RequiredSize < Padding) {
					; If true, then we've found an entry which can hold our new entry
					break
				}
			}
		}
		catch (i64 Exception) {
			if (Exception != EXT2_EXCEPTION_NO_DATA_BLOCK) {
				Throw(Exception)
			}
			
			NextEntryOffset := 0
			
			NewBlockNumber := this->FindINodeDataBlock(TargetNode, 0, true)
			
			Print("Allocated block %i for INode %i data block %i\n", NewBlockNumber, TargetNode->INodeNumber, NewDataBlockIndex)
			
			NextEntry := this->ReadBlock(NewBlockNumber)
			AllocatedNewBlock := true
		}
		
		if (AllocatedNewBlock) {
			NextEntry->EntryLength := 1024
		}
		else {
			; Remove all padding from the previous entry, since we are inserting (Last->New->Padding->Next)
			;  where (Last->Padding->Next) used to be, meaning any padding is now "owned" by the new entry
			
			DirectoryEntry* LastEntry := NextEntry
			LastEntry->TrimPadding()
			
			NextEntry := LastEntry->Next()
			NextEntry->EntryLength := Padding As i16
			
			NextEntryOffset -= Padding
			
			Print("Entry '%s' has space for new entry after it\n", LastEntry~>Name)
		}
		
		
		NextEntry->INode := NewNodeNumber
		NextEntry->NameLength := NameLength As i8
		NextEntry->Flags := Flags
		
		; Write the name into the entry
		MoveMemory(NextEntry~>Name, Name, NameLength)
		
		; Look up which data block the new entry belongs to, and write it (plus the edited last entry)
		;  into the data block
		i32 DataBlockIndex := NextEntryOffset / 1024
		i32 TrueBlockIndex := this->FindINodeDataBlock(TargetNode, DataBlockIndex, false)
		
		Print("AppendEntry NEO = %i, DBI = %i, TBI = %i\n", NextEntryOffset, DataBlockIndex, TrueBlockIndex)
		
		this->WriteBlock(TrueBlockIndex, this->TempBlock)
		
		return NextEntry
	}
	
	define void WriteINodeBlock(INode* Node, i32 BlockNumber, void* BlockData) {
		i32 NextBlock := Node~>DirectBlocks[BlockNumber]
		
		if !(NextBlock) {
			NextBlock := this->AllocateBlock()
			
			Print("Allocated free block %i\n", NextBlock)
			
			Node~>DirectBlocks[BlockNumber] := NextBlock
		}
		else {
			Print("Used existing block %i\n", NextBlock)
		}
		
		this->WriteBlock(NextBlock, BlockData)
	}
	define void WriteINodeData(i32 NodeNumber, void* Data, i32 DataLength) {
		Print("Finding INode %i for write\n", NodeNumber)
		
		INode* ForNode := this->ReadINode(NodeNumber)
		
		i32* NodeBlocks := ForNode~>DirectBlocks
		
		Print("Allocating and writing blocks\n")
		
		i32 BlockCount := DataLength / 1024
		i32 Remainder := DataLength % 1024
		
		for (i32 Index := 0, Index < BlockCount, Index += 1) {
			this->WriteINodeBlock(ForNode, Index, Data + Index * 1024)
		}
		
		if (Remainder) {
			i8* TempBuffer := this->TempBlock
			
			MoveMemory(TempBuffer, Data + Index * 1024, Remainder)
			
			for (i32 ZeroIndex := Remainder, ZeroIndex < 1024, ZeroIndex += 1) {
				TempBuffer[ZeroIndex] := 0
			}
			
			this->WriteINodeBlock(ForNode, Index, TempBuffer)
			
			Index += 1
		}
		
		NodeBlocks[Index] := 0 /* Signal that the file does not contain any more data */
		
		ForNode->FileSizeLow := DataLength
		ForNode->DiskSectorsUsed := (Index - 1) * 1024
		
		this->WriteINode(NodeNumber, ForNode)
	}
	
	define i32 GetPathTail(i8* Path) {
		i32 Length := StringLength(Path)
		i32 TailIndex := 0
		
		for (i32 Index := 0, Index < Length, Index += 1) {
			i8 NextCharacter := Path[Index]
			
			if (NextCharacter = '/') {
				TailIndex := Index + 1
			}
		}
		
		return TailIndex
	}
	
	define i32 MakeFile(INode* RootDirectory, i8* Path, i8 EntryType, INode** OutNode, i32* OutContainingNodeNumber) {
		i32 NameIndex := this->GetPathTail(Path)
		i8* FileName := &Path[NameIndex]
		
		INode* ContainingNode := RootDirectory
		
		if (NameIndex != 0) {
			i8* PathHead := CloneMemory(Path, NameIndex - 1)
			PathHead[NameIndex] := 0
			
			DirectoryEntry* ContainingEntry := this->FindDirectoryEntryByPath(RootDirectory, PathHead)
			ContainingNode := this->ReadINode(ContainingEntry->INode)
			
			Free(PathHead)
		}
		
		if (OutContainingNodeNumber != null) {
			OutContainingNodeNumber[0] := ContainingNode->INodeNumber
		}
		
		DirectoryEntry* ExistingEntry := this->FindDirectoryEntryByName(ContainingNode, FileName)
		
		if (ExistingEntry != null) {
			return -1
		}
		
		i32 NewFileNodeNumber := this->AllocateINode()
		
		this->DirectoryAppendEntry(ContainingNode, FileName, NewFileNodeNumber, EntryType)
		
		INode* NewNode := this->ReadINode(NewFileNodeNumber)
		NewNode->SetFieldDefaults()
		
		if (EntryType = DIRECTORY_ENTRY_DIRECTORY) {
			NewNode->MakeDirectory()
		}
		else {
			NewNode->MakeFile()
		}
		
		this->WriteINode(NewNode)
		
		if (OutNode != null) {
			OutNode[0] := NewNode
		}
		
		return NewFileNodeNumber
	}
	
	define i32 MakeFile(INode* RootDirectory, i8* Path) {
		return this->MakeFile(RootDirectory, Path, DIRECTORY_ENTRY_FILE, 0 As INode**, null)
	}
	
	define i32 MakeDirectory(INode* RootDirectory, i8* Path) {
		INode* NewNode := null
		i32 ContainingNodeNumber := 0
		
		i32 NewNodeNumber := this->MakeFile(RootDirectory, Path, DIRECTORY_ENTRY_DIRECTORY, &NewNode, &ContainingNodeNumber)
		
		if (NewNodeNumber <= 0) {
			return -1
		}
		
		this->DirectoryAppendEntry(NewNode, ".", NewNodeNumber, DIRECTORY_ENTRY_DIRECTORY)
		this->DirectoryAppendEntry(NewNode, "..", ContainingNodeNumber, DIRECTORY_ENTRY_DIRECTORY)
		
		return NewNodeNumber
	}
	
	define i8* StartReserveInBitmap(i32 BitmapBlock) {
		return this->ReadBlock(BitmapBlock)
	}
	define void ReserveInBitmap(i8* Bitmap, i32 BitIndex) {
		i32 Byte := BitIndex / 8
		i8 Bit := (BitIndex % 8) As i8
		
		Bitmap[Byte] |= (1 << Bit) As i8
	}
	define void EndReserveInBitmap(i32 BitmapBlock, i8* Bitmap) {
		this->WriteBlock(BitmapBlock, Bitmap)
	}
	
	define void Format(Ext2CreationParameters* Parameters) {
		; First, write a block of zeros to the final block of the device
		;  (which is only really meaningful with files, since otherwise reads past the end of the actual file will break)
		
		i32 FinalBlock := Parameters->BlockCount - 1
		
		i8* Data := this->ReadBlock(FinalBlock)
		
		for (i32 ZeroIndex := 0, ZeroIndex < Parameters->BlockSize, ZeroIndex++) {
			Data[ZeroIndex] := 0
		}
		
		this->WriteBlock(FinalBlock, Data)
		
		Print("Building super block...\n")
		
		this->SuperBlock->SetFieldDefaults()
		this->SuperBlock->TotalINodes := Parameters->INodeCount
		this->SuperBlock->TotalBlocks := Parameters->BlockCount
		
		; TODO: Actually set these fields, since they are log2 fields, they are left out for now
		;this->SuperBlock->BlockSize := Parameters->BlockSize
		;this->SuperBlock->FragmentSize := Parameters->BlockSize
		
		this->SuperBlock->BlocksPerGroup := Parameters->BlocksPerGroup
		this->SuperBlock->FragmentsPerGroup := Parameters->BlocksPerGroup
		this->SuperBlock->INodesPerGroup := Parameters->INodesPerGroup
		
		Print(" + Total blocks: %i\n", Parameters->INodeCount)
		Print(" + Total INodes: %i\n", Parameters->BlockCount)
		Print(" + Blocks per group: %i\n", Parameters->BlocksPerGroup)
		Print(" + INodes per group: %i\n", Parameters->INodesPerGroup)
		Print(" + Overall FS size: %x\n", Parameters->BlockCount * Parameters->BlockSize)
		
		this->CommitSuperBlock()
		
		Print("Generating preliminary block groups\n")
		
		i32 ReservedBlockCount := Parameters->INodeTableSize + 4 ; Number of blocks each group has reserved for FS stuff
		
		; On the first pass through the block groups, the first and last groups get no special treatment
		;  but since they still need to be initialized just like the other block groups, we handle them afterwards
		
		for (i32 Index := 0, Index < Parameters->BlockGroupCount, Index++) {
			BlockGroupDescriptor* Descriptor := this->GetBlockGroupDescriptor(Index)
			
			i32 DescriptorBaseBlock := Index * Parameters->BlocksPerGroup
			
			Descriptor->BlockBitmap := DescriptorBaseBlock + 3
			Descriptor->INodeBitmap := DescriptorBaseBlock + 4
			Descriptor->INodeTable := DescriptorBaseBlock + 5
			
			Descriptor->UnallocatedBlocks := (Parameters->BlocksPerGroup - ReservedBlockCount) As i16
			Descriptor->UnallocatedINodes := Parameters->INodesPerGroup As i16
			
			Print("    Block group %i contains %i blocks, and %i INodes\n", Index, Descriptor->UnallocatedBlocks, Descriptor->UnallocatedINodes)
			
			; We've initialized the group descriptor well enough that we can build the block bitmap now, with blocks
			;  reserved for the superblock clone, block group descriptor(s) clone, block bitmap, and INode bitmap
			
			i8* BlockBitmap := this->StartReserveInBitmap(Descriptor->BlockBitmap)
			
			for (i32 ReserveIndex := 0, ReserveIndex < ReservedBlockCount, ReserveIndex++) {
				this->ReserveInBitmap(BlockBitmap, ReserveIndex)
			}
			
			this->EndReserveInBitmap(Descriptor->BlockBitmap, BlockBitmap)
			
			Print("    + Done building block bitmap for group\n", Index)
		}
		
		if (Parameters->FinalGroupSize < ReservedBlockCount) {
			; If the final group can't hold an entire INode table, it isn't possible to use it in the FS, so we just
			;  get rid of it
			
			if (Parameters->BlockGroupCount = 1) {
				; Except for if it is the *only* group, in which case we can't format the device at all
				
				Print("ERROR: Only block group is not large enough to hold an INode table, aborting...\n")
				return
			}
			
			Print("WARNING: Final block group is not large enough to hold an INode table, truncating...\n")
			
			Descriptor->BlockBitmap := 0
			Descriptor->INodeBitmap := 0
			Descriptor->INodeTable := 0
			
			Descriptor->UnallocatedBlocks := 0
			Descriptor->UnallocatedINodes := 0
			
			this->SuperBlock->TotalBlocks -= Parameters->FinalGroupSize
			this->SuperBlock->TotalINodes -= Parameters->INodesPerGroup
			
			this->CommitSuperBlock()
		}
		else {
			; The final group is big enough for a INodeTable, calculate how many free blocks it will have with the
			;  reserved ones allocated
			
			Descriptor->UnallocatedBlocks := (Parameters->FinalGroupSize - ReservedBlockCount) As i16
			
			Print("Updated final group to contain %i free blocks\n", Descriptor->UnallocatedBlocks)
			
			; Reserve all blocks past the end of the device, to make sure they aren't allocated
			
			i8* FinalGroupBlocks := this->StartReserveInBitmap(Descriptor->BlockBitmap)
			
			for (Index := Descriptor->UnallocatedBlocks, Index < Parameters->BlocksPerGroup, Index++) {
				this->ReserveInBitmap(FinalGroupBlocks, Index)
			}
			
			this->EndReserveInBitmap(Descriptor->BlockBitmap, FinalGroupBlocks)
			
			Print(" + Reserved all blocks past end of storage medium\n")
		}
		
		; By now, we've got block group descriptors and block/INode bitmaps correctly set up for each descriptor
		;  so we're almost done, we just need to reserve the reserved INodes, and then we can actually build some
		;   files/folders
		
		Print("Reserving INodes in first group\n")
		
		BlockGroupDescriptor* FirstDescriptor := this->GetBlockGroupDescriptor(0)
		
		i8* FirstINodeBitmap := this->StartReserveInBitmap(FirstDescriptor->INodeBitmap)
		
		for (Index := 0, Index < 6, Index++) {
			; Last reserved INode = 6, the "undelete directory"
			
			this->ReserveInBitmap(FirstINodeBitmap, Index)
		}
		
		this->EndReserveInBitmap(FirstDescriptor->INodeBitmap, FirstINodeBitmap)
		
		Print("Reserved all reserved INodes, committing block group descriptors\n")
		
		this->CommitBlockGroupDescriptors()
		
		; Alright, so we've got a functional FS now, but it doesn't have a root INode set, and is pretty useless
		;  so, we just need to grab INode 2 (EXT2_ROOT_INODE) and set it up as a directory, along with creating
		;   directory entries for "." and ".." (which both point back at the root INode)
		
		Print("Building root INode, creating entries\n")
		
		INode* RootNode := this->ReadINode(2)
		
		RootNode->SetFieldDefaults()
		RootNode->MakeDirectory()
		
		this->WriteINode(RootNode)
		
		this->DirectoryAppendEntry(RootNode, ".", 2, DIRECTORY_ENTRY_DIRECTORY)
		this->DirectoryAppendEntry(RootNode, "..", 2, DIRECTORY_ENTRY_DIRECTORY)
		
		; And that's that. Now we've got a functional FS, ready to be used.
		
		Print("Done, format complete\n")
	}
}

define i32 SplitPath(i8* Path, i8** Into, i32 Max) {
	i32 Count := 0
	i32 Start := 0
	
	for (i32 Index := 0, Path[Index] != 0, Index += 1) {
		if (Path[Index] = '/') {
			Into[Count] := Path + Start
			Count += 1
			
			if (Count = Max) {
				return Count
			}
			
			Path[Index] := 0
			Start := Index + 1
		}
	}
	
	Into[Count] := Path + Start
	Count += 1
	
	return Count
}

define void Tabs(i32 Count) {
	for (i32 Index := 0, Index < Count, Index += 1) {
		Print("	")
	}
}

define void DirectoryTree(Ext2* FS, INode* Root, i32 TabCount) {
	i32 State := FS->StartWalkDirectory(Root)
	
	loop {
		DirectoryEntry* NextEntry := FS->WalkDirectoryNext(Root, &State)
		
		if (NextEntry = null) {
			break
		}
		
		INode* NextNode := FS->ReadINode(NextEntry->INode)
		
		if (NextEntry->NameLength != 0) {
			Tabs(TabCount)
			Print("%x	%s\n", NextNode->FileSizeLow, NextEntry~>Name)
		}
		
		if (NextNode->GetType() = 0x4 && NextEntry~>Name[0] != '.') {
			INode* NextDirectory := CloneMemory(NextNode, #INode)
			
			DirectoryTree(FS, NextDirectory, TabCount + 1)
			
			Free(NextDirectory)
		}
	}
}

define void Prompt(Ext2* FS) {
	if (FS->SuperBlock->SuperBlockNumber) {
		INode* RootINode := CloneMemory(FS->ReadINode(2), #INode)
	}
	
	loop {
		Print("^90->^F0")
		i8* NextLine := ReadLine()
		
		i64 ArgC := 0
		i8** ArgV := null
		
		ParseCommandLine(NextLine, &ArgC, &ArgV)
		i8* Command := ArgV[0]
		i8* Path := ArgV[1]
		
		if (StringEquals(Command, "ls")) {
			i32 NextEntryOffset := FS->StartWalkDirectory(RootINode)
			
			loop {
				DirectoryEntry* NextEntry := FS->WalkDirectoryNext(RootINode, &NextEntryOffset)
				
				if (NextEntry = null) {
					break
				}
				
				INode* NextNode := FS->ReadINode(NextEntry->INode)
				
				if (NextNode->IsDirectory()) {
					Print(" ^20D^F0 ")
				}
				else {
					Print(" ^A0F^F0 ")
				}
				
				Print("%x	%x	%s\n", NextEntry->INode, NextNode->FileSizeLow, NextEntry~>Name)
			}
		}
		else if (StringEquals(Command, "cd")) {
			DirectoryEntry* NewRootEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (NewRootEntry = null || !NewRootEntry->IsDirectory()) {
				Print(" Could not find directory '^C0%s^F0'\n", Path)
			}
			else {
				Print(" CD to '^A0%s^F0', INode ^A0%x^F0\n", Path, NewRootEntry->INode)
				
				Free(RootINode)
				RootINode := FS->CloneINode(NewRootEntry->INode)
			}
		}
		else if (StringEquals(Command, "bi")) {
			DirectoryEntry* FoundNodeEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (FoundNodeEntry = null) {
				Print(" Could not find file/directory '^C0%s^F0'\n", Path)
			}
			else {
				INode* FoundNode := FS->CloneINode(FoundNodeEntry->INode)
				
				i32 BlockCount := FoundNode->FileSizeLow / 1024
				
				if (FoundNode->FileSizeLow % 1024) {
					BlockCount += 1
				}
				
				Print(" ^A0%i^F0 total blocks, ^A0%i^F0 total size\n", BlockCount, FoundNode->FileSizeLow)
				
				Print(" INode: ^A0%i^F0\n", FoundNode->INodeNumber - 1)
				
				i32 Offset := 0
				i32 Block := FS->FindINodeBlock(FoundNode->INodeNumber, &Offset)
				
				Print(" Location: sector ^A0%i^F0+^20%i^F0 (offset ^A0%x^F0)\n", Block * 2, Offset, (Block * 1024) + Offset)
				
				for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex += 1) {
					i32 Temp := FS->FindINodeDataBlock(FoundNode, BlockIndex, false)
					
					Print("  ^20%i^F0 = Blocks[^20%i^F0] (sector %i | offset %x)\n", BlockIndex, Temp, Temp * 2, Temp * 1024)
				}
				
				Free(FoundNode)
			}
		}
		else if (StringEquals(Command, "cat")) {
			DirectoryEntry* FoundFileEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
			
			if (FoundFileEntry = null || !FoundFileEntry->IsFile()) {
				Print(" Could not find file '^C0%s^F0'\n", Path)
			}
			else {
				INode* FoundFileNode := FS->CloneINode(FoundFileEntry->INode)
				
				i32 FileBlockCount := FoundFileNode->FileSizeLow / 1024
				
				if (FoundFileNode->FileSizeLow % 1024) {
					FileBlockCount += 1
				}
				
				for (i32 FileBlockIndex := 0, FileBlockIndex < FileBlockCount, FileBlockIndex += 1) {
					i32 FileDataBlock := FS->FindINodeDataBlock(FoundFileNode, FileBlockIndex, false)
					Print("%s", FS->ReadBlock(FileDataBlock))
				}
				
				Print("\n Done, ^A0%i^F0 blocks printed\n", FileBlockCount)
				
				Free(FoundFileNode)
			}
		}
		else if (StringEquals(Command, "touch")) {
			i32 CreatedFileNodeNumber := FS->MakeFile(RootINode, Path)
			
			if (CreatedFileNodeNumber = -1) {
				Print(" File '^C0%s^F0' already exists\n", Path)
			}
			else {
				Print(" Created new file at '^A0%s^F0', INode ^A0%i^F0\n", Path, CreatedFileNodeNumber)
			}
		}
		else if (StringEquals(Command, "mkdir")) {
			i32 CreatedDirectoryNodeNumber := FS->MakeDirectory(RootINode, Path)
			
			if (CreatedDirectoryNodeNumber = -1) {
				Print(" Directory '^C0%s^F0' already exists\n", Path)
			}
			else {
				Print(" Created new directory at '^A0%s^F0', INode ^A0%i^F0\n", Path, CreatedDirectoryNodeNumber)
			}
		}
		else if (StringEquals(Command, "bg")) {
			i32 Index := AToI(Path) As i16
			Print("%i = \n", Index)
			BlockGroupDescriptor* BGD := FS->GetBlockGroupDescriptor(Index)
			
			BGD->Print()
		}
		else if (StringEquals(Command, "tree")) {
			DirectoryTree(FS, RootINode, 0)
		}
		else if (StringEquals(Command, "format")) {
			i32 Size := AToI(Path) As i32
			
			Ext2CreationParameters* Parameters := Alloc(#Ext2CreationParameters)
			Parameters->SetDefaults()
			Parameters->AssumeFromStorageSize(Size)
			
			FS->Format(Parameters)
			
			RootINode := CloneMemory(FS->ReadINode(2), #INode)
		}
		else if (StringEquals(Command, "quit")) {
			Free(ArgV)
			break
		}
		
		Free(ArgV)
	}
}

#Require "./src/lib/Debug.rlx"

struct Ext2FileBackedDevice {
	i64 FD
	
	define void Read(i32 SectorNumber, void* Buffer) {
		if (SectorNumber < 0) {
			Throw(EXT2_EXCEPTION_DEVICE_READ_ERROR)
		}
		
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileRead(this->FD, Buffer, 512)
	}
	define void Write(i32 SectorNumber, void* Buffer) {
		if (SectorNumber < 0) {
			Throw(EXT2_EXCEPTION_DEVICE_WRITE_ERROR)
		}
		
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileWrite(this->FD, Buffer, 512)
	}
	
	static void Read(Ext2FileBackedDevice* this, i32 Sector, void* Buffer) {
		this->Read(Sector, Buffer)
	}
	static void Write(Ext2FileBackedDevice* this, i32 Sector, void* Buffer) {
		this->Write(Sector, Buffer)
	}
	
	static Ext2DeviceTraits* New(i64 FD) {
		Ext2FileBackedDevice* this := Alloc(#Ext2FileBackedDevice)
		
		this->FD := FD
		
		Ext2DeviceTraits* Traits := Alloc(#Ext2DeviceTraits)
		
		Traits->State := this
		Traits->ReadSector := &Ext2FileBackedDevice:Read
		Traits->WriteSector := &Ext2FileBackedDevice:Write
		
		return Traits
	}
}



define i32 Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	i64 F := FileOpen("new.bin", FILE_READ_WRITE | FILE_CREATE_NEW)
	
	Print("FD = %x\n", F)
	
	Ext2DeviceTraits* Traits := Ext2FileBackedDevice:New(F)
	
	Ext2* FS := Ext2:New(Traits)
	
	void* SB := Alloc(2048)
	void* TI := Alloc(1024)
	void* TB1 := Alloc(1024)
	void* TB2 := Alloc(1024)
	
	FS->Initialize(SB, TI, TB1, TB2)
	
	;Print("SB data\n Block size = %i\n Blocks per group = %i\n INodes per group = %i\n\n", 1024 << (FS->SuperBlock->BlockSize As i8), FS->SuperBlock->BlocksPerGroup, FS->SuperBlock->INodesPerGroup)
	
	FS->SuperBlock->Print()
	
	Prompt(FS)
	
	return 0
	
	;i32 NewNode := FS->AllocateINode()
	;
	;i8* Data := "Abc 123 hello asdiausd ipi"
	;FS->WriteINodeData(NewNode, Data, StringLength(Data))
	;
	;FS->DirectoryAppendEntry(2, "Testfile.txt", NewNode, 1)
	
	;INode* RootINode := CloneMemory(FS->ReadINode(2), #INode)
	;
	;DirectoryTree(FS, RootINode, 1)
	
	
	;i8** Path := Alloc(0x100)
	;
	;i32 Count := SplitPath(ArgV[1], Path, 5)
	;
	;DirectoryEntry* Result := FS->FindDirectoryEntryByPath(Path, Count, true)
	;
	;if (Result > 0x200) {
	;	Print("Found file '%s' at INode %i\n", Result~>Name, Result->INode)
	;	;i32 ResultNode := Result->INode
	;	;
	;	;/* INode* Found := Ext2ReadINode(FSP, Result->INode)
	;	;void* Data := Ext2ReadINodeData(FSP, Found, 0) */
	;	;
	;	;
	;	;i32 NewNode := Ext2AllocateINode(FSP)
	;	;
	;	;INode* NewNodeData := Alloc(#INode)
	;	;
	;	;
	;	;
	;	;Ext2WriteINode(FSP, NewNode, NewNodeData)
	;	;Ext2DirectoryAppendEntry(FSP, ResultNode, "dummyTest", NewNode, 1)
	;	;
	;	;i8* Data := "Abcd 123, dummy! aoi"
	;	;void* Temp := Alloc(0x1000)
	;	;MemoryCopy(Data, Temp, StringLength(Data))
	;	;
	;	;Ext2AllocateAndWriteBlocks(FSP, NewNode, 1, Temp)
	;}
	;else {
	;	Print("Couldn't find file, error %c (%i)\n", Result As i8, Result As i64)
	;}
}