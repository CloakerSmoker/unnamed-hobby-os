
#Require "$/Memory.rlx"
#Require "$/File.rlx"
#Require "$/Console.rlx"
#Require "$/Exception.rlx"
#Require "$/Debug.rlx"

declare void PrintTerm(AMLTerm*)

i8 AML_DUAL_NAME_PREFIX := 0x2E
i8 AML_MULTI_NAME_PREFIX := 0x2F

i8 AML_NAME_STRING_SINGLE := 0
i8 AML_NAME_STRING_DUAL := 1
i8 AML_NAME_STRING_MULTI := 2
i8 AML_NAME_STRING_NULL := 3

struct AMLNameString {
	i32 IndirectSegmentCount
	
	i8 RootCharacter
	i8 Kind
	
	i32[2] DirectNameSegments
	i32* IndirectNameSegments
	
	static AMLNameString* New(i8 RootCharacter) {
		AMLNameString* this := Alloc(#AMLNameString)
		
		this->RootCharacter := RootCharacter
		
		return this
	}
	
	define void Print() {
		Print("%c", this->RootCharacter)
		
		if (this->Kind = AML_NAME_STRING_SINGLE) {
			Print("%l", this->DirectNameSegments[0])
		}
		else if (this->Kind = AML_NAME_STRING_DUAL) {
			Print("%l", this->DirectNameSegments[0])
			Print("%l", this->DirectNameSegments[1])
		}
		else if (this->Kind = AML_NAME_STRING_MULTI) {
			for (i32 Index := 0, Index < this->IndirectSegmentCount, Index++) {
				Print("%l", this->IndirectNameSegments[Index])
			}
		}
	}
}

i8 AML_DATA_OBJECT_BYTE_PREFIX := 0xA
i8 AML_DATA_OBJECT_WORD_PREFIX := 0xB
i8 AML_DATA_OBJECT_DWORD_PREFIX := 0xC
i8 AML_DATA_OBJECT_STRING_PREFIX := 0xD
i8 AML_DATA_OBJECT_QWORD_PREFIX := 0xE
i8 AML_DATA_OBJECT_CONST_ZERO_OP := 0x0
i8 AML_DATA_OBJECT_CONST_ONE_OP := 0x1
i8 AML_DATA_OBJECT_CONST_ONES_OP := 0xFF As i8

struct AMLDataObject {
	i8 Kind
	
	union {
		i8* StringValue
		
		i8 ByteValue
		i16 WordValue
		i32 DoubleWordValue
		i64 QuadWordValue
	}
	
	define void Print() {
		if (this->Kind = AML_DATA_OBJECT_STRING_PREFIX) {
			Print("%s", this->StringValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_BYTE_PREFIX) {
			Print("%x", this->ByteValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_WORD_PREFIX) {
			Print("%x", this->WordValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_DWORD_PREFIX) {
			Print("%x", this->DoubleWordValue)
		}
		else {
			Print("%x", this->QuadWordValue)
		}
	}
}

i8 AML_SUPERNAME_LOCAL := 0
i8 AML_SUPERNAME_ARG := 1
i8 AML_SUPERNAME_NAME := 2

struct AMLSuperName {
	union {
		i32 LocalNumber
		i32 ArgNumber
		AMLNameString Name
	}
	
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_SUPERNAME_NAME) {
			this~>Name->Print()
		}
		else if (this->Kind = AML_SUPERNAME_LOCAL) {
			Print("Local%i", this->ArgNumber)
		}
		else if (this->Kind = AML_SUPERNAME_ARG) {
			Print("Arg%i", this->ArgNumber)
		}
	}
}

i8 AML_TARGET_SUPERNAME := 0
i8 AML_TARGET_DEBUG_OBJ := 1
i8 AML_TARGET_REFERENCE_TYPE := 2

struct AMLTarget {
	i8 Kind
	
	union {
		AMLSuperName SuperName
	}
	
	define void Print() {
		this~>SuperName->Print()
	}
}

declare void PrintTermArg(AMLTermArg*)

i8 AML_TO_BUFFER_OP := 0x96 As i8
i8 AML_TO_DECIMAL_STRING_OP := 0x97 As i8
i8 AML_TO_HEX_STRING_OP := 0x98 As i8
i8 AML_TO_INTEGER_OP := 0x99 As i8

struct AMLDataTargetOperation {
	AMLTermArg* Data
	AMLTarget Target
	i8 Operation
	
	define void Print() {
		i8*[4] Names {
			"ToBuffer", "ToDecimalString", "ToHexString", "ToInteger"
		}
		
		this~>Target->Print()
		Print(" := %s(", Names[((this->Operation As i32) & 0xFF) - 0x96])
		PrintTermArg(this->Data)
		Print(")")
	}
}

i8 AML_DDT_ADD         := 0  ; 0x72
i8 AML_DDT_CONCAT      := 1  ; 0x73
i8 AML_DDT_SUBTRACT    := 2  ; 0x74

i8 AML_DDT_MULTIPLY    := 3  ; 0x77
i8 AML_DDT_SHIFT_LEFT  := 4  ; 0x79
i8 AML_DDT_SHIFT_RIGHT := 5  ; 0x7A
i8 AML_DDT_AND         := 6  ; 0x7B
i8 AML_DDT_NAND        := 7  ; 0x7C
i8 AML_DDT_OR          := 8  ; 0x7D
i8 AML_DDT_NOR         := 9  ; 0x7E
i8 AML_DDT_XOR         := 10 ; 0x7F

struct AMLDataDataTargetOperation {
	AMLTermArg* Left
	AMLTermArg* Right
	AMLTarget Target
	i8 Operation
	
	define void Print() {
		i8*[11] Names {
			"+", ".", "-", "<<", ">>", "&", "NAND", "|", "NOR", "^"
		}
		
		this~>Target->Print()
		Print(" := ")
		PrintTermArg(this->Left)
		Print(" %s ", Names[this->Operation])
		PrintTermArg(this->Right)
	}
}

i8 AML_SUPERNAME_REF_OF := 0x71
i8 AML_SUPERNAME_INCREMENT := 0x75
i8 AML_SUPERNAME_DECREMENT := 0x76
i8 AML_SUPERNAME_SIZEOF := 0x87 As i8
i8 AML_SUPERNAME_TYPEOF := 0x8E As i8

struct AMLSuperNameOperation {
	AMLSuperName SuperName
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_SUPERNAME_REF_OF) {
			Print("&")
		}
		else if (this->Kind = AML_SUPERNAME_INCREMENT) {
			Print("++")
		}
		else if (this->Kind = AML_SUPERNAME_DECREMENT) {
			Print("--")
		}
		else if (this->Kind = AML_SUPERNAME_SIZEOF) {
			Print("sizeof ")
		}
		else if (this->Kind = AML_SUPERNAME_TYPEOF) {
			Print("typeof ")
		}
		
		this~>SuperName->Print()
	}
}

i8 AML_STORE_OPERATION := 0x70

struct AMLStoreOperation {
	AMLTermArg* Source
	AMLSuperName Destination
}

i8 AML_EXPRESSION_DATA_TARGET := 2
i8 AML_EXPRESSION_DATA_DATA_TARGET := 3
i8 AML_EXPRESSION_SUPER_NAME_OPERATION := 6
i8 AML_EXPRESSION_STORE_OPERATION := 7

struct AMLExpressionOpcode {
	union {
		AMLDataTargetOperation DataTarget
		AMLDataDataTargetOperation DataDataTarget
		AMLSuperNameOperation SuperNameOperation
		AMLStoreOperation StoreOperation
	}
	
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_EXPRESSION_DATA_TARGET) {
			this~>DataTarget->Print()
		}
		else if (this->Kind = AML_EXPRESSION_DATA_DATA_TARGET) {
			this~>DataDataTarget->Print()
		}
		else if (this->Kind = AML_EXPRESSION_SUPER_NAME_OPERATION) {
			this~>SuperNameOperation->Print()
		}
		else if (this->Kind = AML_EXPRESSION_STORE_OPERATION) {
			this~>StoreOperation~>Destination->Print()
			Print(" := ")
			PrintTermArg(this~>StoreOperation->Source)
		}
	}
}

i8 AML_TERM_ARG_EXPRESSION := 0
i8 AML_TERM_ARG_DATA_OBJECT := 1
i8 AML_TERM_ARG_LOCAL_OBJECT := 2
i8 AML_TERM_ARG_ARG_OBJECT := 4

struct AMLTermArg {
	i8 Kind
	
	union {
		AMLExpressionOpcode Expression
		AMLDataObject DataObject
		i32 LocalNumber
		i32 ArgNumber
	}
	
	define void Print() {
		if (this->Kind = AML_TERM_ARG_EXPRESSION) {
			this~>Expression->Print()
		}
		else if (this->Kind = AML_TERM_ARG_DATA_OBJECT) {
			this~>DataObject->Print()
		}
		else if (this->Kind = AML_TERM_ARG_LOCAL_OBJECT) {
			Print("Local%i", this->ArgNumber)
		}
		else if (this->Kind = AML_TERM_ARG_ARG_OBJECT) {
			Print("Arg%i", this->ArgNumber)
		}
	}
}

define void PrintTermArg(AMLTermArg* TermArg) {
	TermArg->Print()
}

struct AMLDefineRegion {
	AMLNameString Name
	i8 AddressSpace
	AMLTermArg Offset
	AMLTermArg Length
	
	define void Print() {
		Print("AMLDefineRegion ")
		this~>Name->Print()
		Print(" %x { ", this->AddressSpace)
		this~>Offset->Print()
		Print(", ")
		this~>Length->Print()
		Print(" }\n")
	}
}

i8 AML_FIELD_NAMED := 0
i8 AML_FIELD_RESERVED := 1
i8 AML_FIELD_ACCESS := 2
i8 AML_FIELD_EXT_ACCESS := 3
i8 AML_FIELD_CONNECT := 4

struct AMLNamedField {
	AMLNameString Name
	i32 Length
	
	define void Print() {
		this~>Name->Print()
		Print(": %x", this->Length)
	}
}

struct AMLField {
	i8 Kind
	
	union {
		AMLNamedField Named
	}
	
	define void Print() {
		this~>Named->Print()
	}
}

struct AMLDefineField {
	i32 Length
	AMLNameString Name
	i8 Flags
	i32 Count
	AMLField* Fields
	
	define void Print() {
		Print("AMLDefineField ")
		this~>Name->Print()
		Print(" %x {\n", this->Flags)
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			this->Fields[Index]->Print()
			Print("\n")
		}
		
		Print("}\n")
	}
}

struct AMLDefineScope {
	i32 Length
	AMLNameString Name
	i32 Count
	AMLTerm* Terms
	
	define void Print() {
		Print("AMLScope ")
		this~>Name->Print()
		Print(" {\n")
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			PrintTerm(this->Terms[Index])
			Print("\n")
		}
		
		Print("}\n")
	}
}

struct AMLDefineMethod {
	i32 Length
	AMLNameString Name
	i8 Flags
	i32 Count
	AMLTerm* Terms
	
	define void Print() {
		Print("AMLDefineMethod ")
		this~>Name->Print()
		Print(" %x {\n", this->Flags)
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			PrintTerm(this->Terms[Index])
			Print("\n")
		}
		
		Print("}\n")
	}
}

i8 AML_ALIAS_OP := 0x6
i8 AML_NAME_OP := 0x8
i8 AML_SCOPE_OP := 0x10
i8 AML_METHOD_OP := 0x14

i8 AML_EXT_REGION_OP := 0x80 As i8
i8 AML_EXT_FIELD_OP := 0x81 As i8

i8 AML_EXPRESSION_OP := 0x96 As i8

struct AMLTerm {
	i8 Kind
	
	union {
		AMLDefineRegion Region
		AMLDefineField Field
		AMLDefineScope Scope
		AMLDefineMethod Method
		AMLExpressionOpcode Expression
	}
	
	define void Print() {
		if (this->Kind = AML_SCOPE_OP) {
			this~>Scope->Print()
		}
		else if (this~>Kind = AML_METHOD_OP) {
			this~>Method->Print()
		}
		else if (this~>Kind = AML_EXPRESSION_OP) {
			this~>Expression->Print()
		}
		else if (this->Kind = AML_EXT_REGION_OP) {
			this~>Region->Print()
		}
		else if (this->Kind = AML_EXT_FIELD_OP) {
			this~>Field->Print()
		}
	}
}

define void PrintTerm(AMLTerm* Term) {
	Term->Print()
}

i64 AML_INVALID_SYNTAX := 'AML_USUK'

struct AMLParser {
	
	union {
		void* RawBuffer
		i8* Buffer
	}
	
	i32 Index
	i32 Length
	
	define i8 IsAtEnd() {
		return this->Index >= this->Length
	}
	
	define i8 Peek() {
		return this->Buffer[this->Index]
	}

	define i8 Next() {
		return this->Buffer[this->Index++]
	}
	
	define i8 NextMatches(i8 Value) {
		if (this->Peek() = Value) {
			this->Next()
			
			return true
		}
		
		return false
	}
	
	define void Fail() {
		Print("At byte %x\n", this->Index)
		
		for (i32 Index := this->Index - 10, Index < this->Index + 10, Index++) {
			Print("%c", this->Buffer[Index])
		}
		
		Throw(AML_INVALID_SYNTAX)
	}
	define void Fail(i8* Reason, i8 Unknown) {
		Print("%s\n", Reason)
		Print("%x '%c'\n", Unknown, Unknown)
		this->Fail()
	}
	
	define i32 ParsePackageLength() {
		i8 First := this->Next()
		i32 Length := (First & 0b11_00_0000) >> 6
		i32 Value := First & 0b00_00_1111
		
		if (Length = 0) {
			Value |= First & 0b00_11_0000
		}
		
		for (i32 Index := 0, Index < Length, Index++) {
			i8 Shift := ((Index * 8) + 4) As i8
			
			Value |= this->Next() << Shift
		}
		
		return Value
	}
	
	define i8 ParseLeadNameCharacter() {
		i8 Next := this->Next()
		
		if (('A' <= Next && Next <= 'Z') || Next = '_') {
			return Next
		}
		
		this->Fail("Expected [_A-Z] for lead name", Next)
		return 0
	}
	define i8 ParseNameCharacter() {
		i8 Next := this->Next()
		
		if (('A' <= Next && Next <= 'Z') || Next = '_') {
			return Next
		}
		else if ('0' <= Next && Next <= '9') {
			return Next
		}
		
		this->Fail()
		return 0
	}
	
	define i32 ParseNameSegment() {
		i32 Result := this->ParseLeadNameCharacter()
		
		Result |= this->ParseNameCharacter() << 8
		Result |= this->ParseNameCharacter() << 16
		Result |= this->ParseNameCharacter() << 24
		
		return Result
	}
	
	define void ParseNamePath(AMLNameString* Result) {
		if (this->NextMatches(AML_DUAL_NAME_PREFIX)) {
			Result->Kind := AML_NAME_STRING_DUAL
			Result->DirectNameSegments[0] := this->ParseNameSegment()
			Result->DirectNameSegments[1] := this->ParseNameSegment()
		}
		else if (this->NextMatches(AML_MULTI_NAME_PREFIX)) {
			Result->Kind := AML_NAME_STRING_MULTI
			
			i8 Count := this->Next()
			
			Result->IndirectSegmentCount := Count
			Result->IndirectNameSegments := Alloc(Count * #i32)
			
			for (i32 Index := 0, Index < Count, Index++) {
				Result->IndirectNameSegments[Index] := this->ParseNameSegment()
			}
		}
		else if (this->NextMatches(0)) {
			Result->Kind := AML_NAME_STRING_NULL
		}
		else {
			Result->Kind := AML_NAME_STRING_SINGLE
			Result->DirectNameSegments[0] := this->ParseNameSegment()
		}
	}
	
	define void ParseNameString(AMLNameString* Result) {
		i8 MaybeRootCharacter := this->Peek()
		
		if (this->NextMatches('\') || this->NextMatches('^')) {
			Result->RootCharacter := MaybeRootCharacter
		}
		
		this->ParseNamePath(Result)
	}
	
	define void ParseScope() {
		i32 Length := this->ParsePackageLength()
		
		
	}
	
	define void ParseObject() {
		if (this->NextMatches(AML_SCOPE_OP)) {
			
		}
		
		
	}
	
	define i64 ReadByte() {
		return this->Next()
	}
	define i64 ReadWord() {
		return this->ReadByte() | (this->ReadByte() << 8)
	}
	define i64 ReadDoubleWord() {
		return this->ReadWord() | (this->ReadWord() << 16)
	}
	define i64 ReadQuadWord() {
		return this->ReadDoubleWord() | (this->ReadDoubleWord() << 32)
	}
	
	define void ParseDataObject(AMLDataObject* Result) {
		i8 Next := this->Next()
		
		Result->Kind := Next
		
		if (Next = AML_DATA_OBJECT_BYTE_PREFIX) {
			Result->ByteValue := this->ReadByte() As i8
		}
		else if (Next = AML_DATA_OBJECT_WORD_PREFIX) {
			Result->WordValue := this->ReadWord() As i16
		}
		else if (Next = AML_DATA_OBJECT_DWORD_PREFIX) {
			Result->DoubleWordValue := this->ReadDoubleWord() As i32
		}
		else if (Next = AML_DATA_OBJECT_QWORD_PREFIX) {
			Result->QuadWordValue := this->ReadQuadWord()
		}
		else if (Next = AML_DATA_OBJECT_STRING_PREFIX) {
			Result->StringValue := &this->Buffer[this->Index]
			
			while (this->Next() != 0) {}
		}
		else if (Next = AML_DATA_OBJECT_CONST_ZERO_OP) {
			Result->QuadWordValue := 0
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONE_OP) {
			Result->QuadWordValue := 1
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONES_OP) {
			Result->QuadWordValue := -1
		}
	}
	
	define i8 NextIsDataObject() {
		i8 Next := this->Peek()
		
		if (AML_DATA_OBJECT_BYTE_PREFIX <= Next && Next <= AML_DATA_OBJECT_QWORD_PREFIX) {
			return true
		}
		else if (Next = AML_DATA_OBJECT_CONST_ZERO_OP || Next = AML_DATA_OBJECT_CONST_ONE_OP) {
			return true
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONES_OP) {
			return true
		}
		
		return false
	}
	define i8 NextIsLocalObject() {
		i8 Next := this->Peek()
		
		return 0x60 <= Next && Next <= 0x67
	}
	define i8 NextIsArgObject() {
		i8 Next := this->Peek()
		
		return 0x68 <= Next && Next <= 0x6E
	}
	define void ParseSuperName(AMLSuperName* Result) {
		if (this->NextIsLocalObject()) {
			Result->Kind := AML_SUPERNAME_LOCAL
			Result->LocalNumber := this->Next() - 0x60
		}
		else if (this->NextIsArgObject()) {
			Result->Kind := AML_SUPERNAME_ARG
			Result->ArgNumber := this->Next() - 0x68
		}
		else {
			Result->Kind := AML_SUPERNAME_NAME
			this->ParseNameString(Result~>Name)
		}
	}
	
	declare void ParseTermArg(AMLTermArg*)
	declare void ParseTarget(AMLTarget*)
	
	define i8 NextIsDataTarget() {
		i32 Next := (this->Peek() As i32) & 0xFF
		
		return 0x96 <= Next && Next <= 0x99
	}
	define void ParseDataTarget(AMLDataTargetOperation* Result) {
		Result->Operation := this->Next()
		
		Result->Data := Alloc(#AMLTermArg)
		
		this->ParseTermArg(Result->Data)
		this->ParseTarget(Result~>Target)
	}
	
	define i8 NextIsDataDataTarget() {
		i32 Next := (this->Peek() As i32) & 0xFF
		
		if (0x72 <= Next && Next <= 0x74) {
			return true
		}
		else if (0x77 <= Next && Next <= 0x7F && Next != 0x78) {
			return true
		}
		
		return false
	}
	define void ParseDataDataTarget(AMLDataDataTargetOperation* Result) {
		i32 Next := (this->Next() As i32) & 0xFF
		
		if (0x72 <= Next && Next <= 0x74) {
			Result->Operation := (Next - 0x72) As i8
		}
		else if (0x77 <= Next && Next <= 0x7F) {
			Result->Operation := (2 + (Next - 0x77)) As i8
		}
		
		Result->Left := Alloc(#AMLTermArg)
		Result->Right := Alloc(#AMLTermArg)
		
		this->ParseTermArg(Result->Left)
		this->ParseTermArg(Result->Right)
		this->ParseTarget(Result~>Target)
		
		Result->Print()
	}
	
	define i8 NextIsSuperNameOperation() {
		i32 Next := this->Peek()
		
		if      (Next = AML_SUPERNAME_REF_OF   ) { return true }
		else if (Next = AML_SUPERNAME_INCREMENT) { return true }
		else if (Next = AML_SUPERNAME_DECREMENT) { return true }
		else if (Next = AML_SUPERNAME_SIZEOF   ) { return true }
		else if (Next = AML_SUPERNAME_TYPEOF   ) { return true }
		
		return false
	}
	
	define void ParseSuperNameOperation(AMLSuperNameOperation* Result) {
		Result->Kind := this->Next()
		this->ParseSuperName(Result~>SuperName)
	}
	
	define i8 NextIsExpression() {
		i8 Next := this->Peek()
		
		if (Next = AML_STORE_OPERATION) {
			return true
		}
		
		return this->NextIsDataTarget() || this->NextIsDataDataTarget() || this->NextIsSuperNameOperation()
	}
	
	define void ParseExpression(AMLExpressionOpcode* Result) {
		if (this->NextIsDataTarget()) {
			Result->Kind := AML_EXPRESSION_DATA_TARGET
			this->ParseDataTarget(Result~>DataTarget)
		}
		else if (this->NextIsDataDataTarget()) {
			Result->Kind := AML_EXPRESSION_DATA_DATA_TARGET
			this->ParseDataDataTarget(Result~>DataDataTarget)
		}
		else if (this->NextIsSuperNameOperation()) {
			Result->Kind := AML_EXPRESSION_SUPER_NAME_OPERATION
			this->ParseSuperNameOperation(Result~>SuperNameOperation)
		}
		else if (this->NextMatches(AML_STORE_OPERATION)) {
			Result->Kind := AML_EXPRESSION_STORE_OPERATION
			
			Result~>StoreOperation->Source := Alloc(#AMLTermArg)
			this->ParseTermArg(Result~>StoreOperation->Source)
			this->ParseSuperName(Result~>StoreOperation~>Destination)
		}
	}
	
	define void ParseTermArg(AMLTermArg* Result) {
		if (this->NextIsDataObject()) {
			Result->Kind := AML_TERM_ARG_DATA_OBJECT
			this->ParseDataObject(Result~>DataObject)
		}
		else if (this->NextIsLocalObject()) {
			Result->Kind := AML_TERM_ARG_LOCAL_OBJECT
			Result->LocalNumber := this->Next() - 0x60
		}
		else if (this->NextIsArgObject()) {
			Result->Kind := AML_TERM_ARG_ARG_OBJECT
			Result->ArgNumber := this->Next() - 0x68
		}
		else if (this->NextIsExpression()) {
			Result->Kind := AML_TERM_ARG_EXPRESSION
			this->ParseExpression(Result~>Expression)
		}
		else {
			this->Fail("Unimplemented term-arg", this->Peek())
		}
	}
	
	define void ParseTarget(AMLTarget* Result) {
		Result->Kind := AML_TARGET_SUPERNAME
		this->ParseSuperName(Result~>SuperName)
	}
	
	define void ParseDefineRegion(AMLDefineRegion* Result) {
		this->ParseNameString(Result~>Name)
		Result->AddressSpace := this->Next()
		this->ParseTermArg(Result~>Offset)
		this->ParseTermArg(Result~>Length)
	}
	
	define void ParseNamedField(AMLNamedField* Result) {
		this->ParseNameString(Result~>Name)
		Result->Length := this->ParsePackageLength()
	}
	
	define void ParseField(AMLField* Result) {
		Result->Kind := AML_FIELD_NAMED
		this->ParseNamedField(Result~>Named)
	}
	
	define void ParseDefineField(AMLDefineField* Result) {
		i32 Start := this->Index
		
		Result->Length := this->ParsePackageLength()
		this->ParseNameString(Result~>Name)
		Result->Flags := this->Next()
		
		i32 FieldCountGuess := (Result->Length - 6) / 4
		
		Result->Fields := Alloc(FieldCountGuess * #AMLField)
		
		i32 End := Start + Result->Length
		i32 Index := 0
		
		while (this->Index < End) {
			this->ParseField(Result->Fields[Index++])
		}
		
		Result->Count := Index
	}
	
	declare void ParseTermList(i32, i32*, AMLTerm**)
	
	define void ParseDefineScope(AMLDefineScope* Result) {
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		this->ParseNameString(Result~>Name)
		
		i32 End := Start + Result->Length
		
		this->ParseTermList(End, Result~>Count, Result~>Terms)
	}
	
	define void ParseDefineMethod(AMLDefineMethod* Result) {
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		this->ParseNameString(Result~>Name)
		Result->Flags := this->Next()
		
		i32 End := Start + Result->Length
		
		this->ParseTermList(End, Result~>Count, Result~>Terms)
	}
	
	define void ParseTerm(AMLTerm* Result) {
		Result->Kind := 0
		
		if (this->NextMatches(AML_SCOPE_OP)) {
			Result->Kind := AML_SCOPE_OP
			this->ParseDefineScope(Result~>Scope)
		}
		else if (this->NextMatches(AML_METHOD_OP)) {
			Result->Kind := AML_METHOD_OP
			this->ParseDefineMethod(Result~>Method)
		}
		else if (this->NextIsExpression()) {
			Result->Kind := AML_EXPRESSION_OP
			this->ParseExpression(Result~>Expression)
		}
		else if (this->NextMatches('[')) {
			if (this->NextMatches(AML_EXT_REGION_OP)) {
				Result->Kind := AML_EXT_REGION_OP
				this->ParseDefineRegion(Result~>Region)
			}
			else if (this->NextMatches(AML_EXT_FIELD_OP)) {
				Result->Kind := AML_EXT_FIELD_OP
				this->ParseDefineField(Result~>Field)
			}
			
		}
		
		if (Result->Kind = 0) {
			this->Fail("Unimplemented term", this->Peek())
		}
		
	}
	
	define void ParseTermList(i32 End, i32* OutCount, AMLTerm** OutTerms) {
		i32 Length := End - this->Index
		i32 TermCountGuess := Length / 8
		AMLTerm* Terms := Alloc(TermCountGuess * #AMLTerm)
		
		i32 Index := 0
		
		while (this->Index < End) {
			this->ParseTerm(Terms[Index++])
		}
		
		*OutCount := Index
		*OutTerms := Terms
	}
	
}

define void Main() {
	i64 F := FileOpen("/home/connor/Desktop/nasm-2.14.02-win64/example.aml", FILE_READ)
	
	i32 Size := FileGetSize(F)
	void* AML := FileReadAll(F)
	
	FileClose(F)
	
	AMLParser* P := Alloc(#AMLParser)
	
	P->Buffer := AML
	P->Length := Size
	
	AMLTerm* Root := Alloc(#AMLTerm)
	
	P->ParseTerm(Root)
	
	Root->Print()
}