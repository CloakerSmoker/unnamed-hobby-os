
#Require "$/Memory.rlx"
#Require "$/File.rlx"
#Require "$/Console.rlx"
#Require "$/Exception.rlx"
#Require "$/Debug.rlx"

declare void PrintTerm(AMLTerm*)

i8 AML_DUAL_NAME_PREFIX := 0x2E
i8 AML_MULTI_NAME_PREFIX := 0x2F

i8 AML_NAME_STRING_SINGLE := 0
i8 AML_NAME_STRING_DUAL := 1
i8 AML_NAME_STRING_MULTI := 2
i8 AML_NAME_STRING_NULL := 3

struct AMLNameString {
	i32 IndirectSegmentCount
	
	i8 RootCharacter
	i8 Kind
	
	i32[2] DirectNameSegments
	i32* IndirectNameSegments
	
	static AMLNameString* New(i8 RootCharacter) {
		AMLNameString* this := Alloc(#AMLNameString)
		
		this->RootCharacter := RootCharacter
		
		return this
	}
	
	define void Print() {
		Print("%c", this->RootCharacter)
		
		if (this->Kind = AML_NAME_STRING_SINGLE) {
			Print("%l", this->DirectNameSegments[0])
		}
		else if (this->Kind = AML_NAME_STRING_DUAL) {
			Print("%l", this->DirectNameSegments[0])
			Print("%l", this->DirectNameSegments[1])
		}
		else if (this->Kind = AML_NAME_STRING_MULTI) {
			for (i32 Index := 0, Index < this->IndirectSegmentCount, Index++) {
				Print("%l", this->IndirectNameSegments[Index])
			}
		}
	}
}

i8 AML_DATA_OBJECT_BYTE_PREFIX := 0xA
i8 AML_DATA_OBJECT_WORD_PREFIX := 0xB
i8 AML_DATA_OBJECT_DWORD_PREFIX := 0xC
i8 AML_DATA_OBJECT_STRING_PREFIX := 0xD
i8 AML_DATA_OBJECT_QWORD_PREFIX := 0xE
i8 AML_DATA_OBJECT_CONST_ZERO_OP := 0x0
i8 AML_DATA_OBJECT_CONST_ONE_OP := 0x1
i8 AML_DATA_OBJECT_CONST_ONES_OP := 0xFF As i8

struct AMLDataObject {
	i8 Kind
	
	union {
		i8* StringValue
		
		i8 ByteValue
		i16 WordValue
		i32 DoubleWordValue
		i64 QuadWordValue
	}
	
	define void Print() {
		if (this->Kind = AML_DATA_OBJECT_STRING_PREFIX) {
			Print("%s", this->StringValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_BYTE_PREFIX) {
			Print("%x", this->ByteValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_WORD_PREFIX) {
			Print("%x", this->WordValue)
		}
		else if (this->Kind = AML_DATA_OBJECT_DWORD_PREFIX) {
			Print("%x", this->DoubleWordValue)
		}
		else {
			Print("%x", this->QuadWordValue)
		}
	}
}

i8 AML_SUPERNAME_LOCAL := 0
i8 AML_SUPERNAME_ARG := 1
i8 AML_SUPERNAME_NAME := 2

struct AMLSuperName {
	union {
		i32 LocalNumber
		i32 ArgNumber
		AMLNameString* Name
	}
	
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_SUPERNAME_NAME) {
			this->Name->Print()
		}
		else if (this->Kind = AML_SUPERNAME_LOCAL) {
			Print("Local%i", this->ArgNumber)
		}
		else if (this->Kind = AML_SUPERNAME_ARG) {
			Print("Arg%i", this->ArgNumber)
		}
	}
}

i8 AML_TARGET_SUPERNAME := 0
i8 AML_TARGET_DEBUG_OBJ := 1
i8 AML_TARGET_REFERENCE_TYPE := 2
i8 AML_TARGET_NULL := 3

struct AMLTarget {
	i8 Kind
	
	union {
		AMLSuperName* SuperName
	}
	
	define void Print() {
		if (this->Kind = AML_TARGET_SUPERNAME) {
			this->SuperName->Print()
			Print(" := ")
		}
	}
}

declare void PrintTermArg(AMLTermArg*)

i8 AML_TO_BUFFER_OP := 0x96 As i8
i8 AML_TO_DECIMAL_STRING_OP := 0x97 As i8
i8 AML_TO_HEX_STRING_OP := 0x98 As i8
i8 AML_TO_INTEGER_OP := 0x99 As i8

struct AMLDataTargetOperation {
	AMLTermArg* Data
	AMLTarget* Target
	i8 Operation
	
	define void Print() {
		i8*[4] Names {
			"ToBuffer", "ToDecimalString", "ToHexString", "ToInteger"
		}
		
		this->Target->Print()
		Print("%s(", Names[((this->Operation As i32) & 0xFF) - 0x96])
		PrintTermArg(this->Data)
		Print(")")
	}
}

i8 AML_DDT_ADD         := 0  ; 0x72
i8 AML_DDT_CONCAT      := 1  ; 0x73
i8 AML_DDT_SUBTRACT    := 2  ; 0x74

i8 AML_DDT_MULTIPLY    := 3  ; 0x77
i8 AML_DDT_SHIFT_LEFT  := 4  ; 0x79
i8 AML_DDT_SHIFT_RIGHT := 5  ; 0x7A
i8 AML_DDT_AND         := 6  ; 0x7B
i8 AML_DDT_NAND        := 7  ; 0x7C
i8 AML_DDT_OR          := 8  ; 0x7D
i8 AML_DDT_NOR         := 9  ; 0x7E
i8 AML_DDT_XOR         := 10 ; 0x7F

i8 AML_DDT_CONCAT_RES  := 11
i8 AML_DDT_MOD         := 12

i8 AML_DDT_INDEX       := 13

struct AMLDataDataTargetOperation {
	AMLTermArg* Left
	AMLTermArg* Right
	AMLTarget* Target
	i8 Operation
	
	define void Print() {
		i8*[14] Names {
			"+", ".", "-", "<<", ">>", "&", "NAND", "|", "NOR", "^", "..", "%", "["
		}
		
		this->Target->Print()
		PrintTermArg(this->Left)
		
		if (this->Operation = AML_DDT_INDEX) {
			Print("[")
		}
		else {
			Print(" %s ", Names[this->Operation])
		}
		
		PrintTermArg(this->Right)
		
		if (this->Operation = AML_DDT_INDEX) {
			Print("]")
		}
	}
}

i8 AML_SUPERNAME_REF_OF := 0x71
i8 AML_SUPERNAME_INCREMENT := 0x75
i8 AML_SUPERNAME_DECREMENT := 0x76
i8 AML_SUPERNAME_SIZEOF := 0x87 As i8
i8 AML_SUPERNAME_TYPEOF := 0x8E As i8

struct AMLSuperNameOperation {
	AMLSuperName* SuperName
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_SUPERNAME_REF_OF) {
			Print("&")
		}
		else if (this->Kind = AML_SUPERNAME_INCREMENT) {
			Print("++")
		}
		else if (this->Kind = AML_SUPERNAME_DECREMENT) {
			Print("--")
		}
		else if (this->Kind = AML_SUPERNAME_SIZEOF) {
			Print("sizeof ")
		}
		else if (this->Kind = AML_SUPERNAME_TYPEOF) {
			Print("typeof ")
		}
		
		this->SuperName->Print()
	}
}

i8 AML_STORE_OPERATION := 0x70

struct AMLStoreOperation {
	AMLTermArg* Source
	AMLSuperName* Destination
}

i8 AML_DD_AND := 0 ; 0x90
i8 AML_DD_OR  := 1 ; 0x91
i8 AML_DD_NE  := 2 ; 0x92 0x93
i8 AML_DD_LE  := 3 ; 0x92 0x94
i8 AML_DD_GE  := 4 ; 0x92 0x95
i8 AML_DD_E   := 5 ; 0x93
i8 AML_DD_L   := 6 ; 0x95
i8 AML_DD_G   := 7 ; 0x94

struct AMLDataDataOperation {
	AMLTermArg* Left
	AMLTermArg* Right
	i8 Operation
	
	define void Print() {
		i8*[8] Operators {
			"&&", "||", "!=", "<=", ">=", "==", ">", "<"
		}
		
		PrintTermArg(this->Left)
		Print(" %s ", Operators[this->Operation])
		PrintTermArg(this->Right)
	}
}

i8 AML_DATA_OP_DEREF := 0x83 As i8
i8 AML_DATA_OP_LNOT  := 0x92 As i8

struct AMLDataOperation {
	AMLTermArg* Operand
	i8 Operation
	
	define void Print() {
		if (this->Operation = AML_DATA_OP_DEREF) {
			Print("*")
		}
		else if (this->Operation = AML_DATA_OP_LNOT) {
			Print("!")
		}
		
		PrintTermArg(this->Operand)
	}
}

i8 AML_EXPRESSION_DATA_TARGET := 2
i8 AML_EXPRESSION_DATA_DATA_TARGET := 3
i8 AML_EXPRESSION_SUPER_NAME_OPERATION := 6
i8 AML_EXPRESSION_STORE_OPERATION := 7
i8 AML_EXPRESSION_DATA_DATA := 8
i8 AML_EXPRESSION_DATA := 9

struct AMLExpressionOpcode {
	union {
		AMLDataTargetOperation* DataTarget
		AMLDataDataTargetOperation* DataDataTarget
		AMLSuperNameOperation* SuperNameOperation
		AMLStoreOperation* StoreOperation
		AMLDataDataOperation* DataData
		AMLDataOperation* DataOperation
	}
	
	i8 Kind
	
	define void Print() {
		i8 dummy := this->Kind
		
		if (this->Kind = AML_EXPRESSION_DATA_TARGET) {
			this->DataTarget->Print()
		}
		else if (this->Kind = AML_EXPRESSION_DATA_DATA_TARGET) {
			this->DataDataTarget->Print()
		}
		else if (this->Kind = AML_EXPRESSION_SUPER_NAME_OPERATION) {
			this->SuperNameOperation->Print()
		}
		else if (this->Kind = AML_EXPRESSION_DATA_DATA) {
			this->DataData->Print()
		}
		else if (this->Kind = AML_EXPRESSION_DATA) {
			this->DataOperation->Print()
		}
		else if (this->Kind = AML_EXPRESSION_STORE_OPERATION) {
			this->StoreOperation->Destination->Print()
			Print(" := ")
			PrintTermArg(this->StoreOperation->Source)
		}
	}
}

i8 AML_TERM_ARG_EXPRESSION := 0
i8 AML_TERM_ARG_DATA_OBJECT := 1
i8 AML_TERM_ARG_LOCAL_OBJECT := 2
i8 AML_TERM_ARG_ARG_OBJECT := 4

struct AMLTermArg {
	i8 Kind
	
	union {
		AMLExpressionOpcode* Expression
		AMLDataObject* DataObject
		i32 LocalNumber
		i32 ArgNumber
	}
	
	define void Print() {
		if (this->Kind = AML_TERM_ARG_EXPRESSION) {
			this->Expression->Print()
		}
		else if (this->Kind = AML_TERM_ARG_DATA_OBJECT) {
			this->DataObject->Print()
		}
		else if (this->Kind = AML_TERM_ARG_LOCAL_OBJECT) {
			Print("Local%i", this->ArgNumber)
		}
		else if (this->Kind = AML_TERM_ARG_ARG_OBJECT) {
			Print("Arg%i", this->ArgNumber)
		}
	}
}

define void PrintTermArg(AMLTermArg* TermArg) {
	TermArg->Print()
}

i8 AML_WHILE_OP := 0xA2 As i8

struct AMLWhileLoop {
	i32 Length
	AMLTermArg* Condition
	i32 Count
	AMLTerm** Body
	
	define void Print() {
		Print("While (")
		this->Condition->Print()
		Print(") {\n")
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			PrintTerm(this->Body[Index])
			Print("\n")
		}
		
		Print("}\n")
	}
}

struct AMLStatementOpcode {
	union {
		AMLWhileLoop* WhileLoop
	}
	
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_WHILE_OP) {
			this->WhileLoop->Print()
		}
	}
}


struct AMLDefineRegion {
	AMLNameString* Name
	i8 AddressSpace
	AMLTermArg* Offset
	AMLTermArg* Length
	
	define void Print() {
		Print("AMLDefineRegion ")
		this->Name->Print()
		Print(" %x { ", this->AddressSpace)
		this->Offset->Print()
		Print(", ")
		this->Length->Print()
		Print(" }\n")
	}
}

i8 AML_FIELD_NAMED := 0
i8 AML_FIELD_RESERVED := 1
i8 AML_FIELD_ACCESS := 2
i8 AML_FIELD_EXT_ACCESS := 3
i8 AML_FIELD_CONNECT := 4

struct AMLNamedField {
	AMLNameString* Name
	i32 Length
	
	define void Print() {
		this->Name->Print()
		Print(": %x", this->Length)
	}
}

struct AMLField {
	i8 Kind
	
	union {
		AMLNamedField* Named
	}
	
	define void Print() {
		this->Named->Print()
	}
}

struct AMLDefineField {
	i32 Length
	AMLNameString* Name
	i8 Flags
	i32 Count
	AMLField** Fields
	
	define void Print() {
		Print("AMLDefineField ")
		this->Name->Print()
		Print(" %x {\n", this->Flags)
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			this->Fields[Index]->Print()
			Print("\n")
		}
		
		Print("}\n")
	}
}

struct AMLDefineScope {
	i32 Length
	AMLNameString* Name
	i32 Count
	AMLTerm** Terms
	
	define void Print() {
		Print("AMLScope ")
		this->Name->Print()
		Print(" {\n")
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			PrintTerm(this->Terms[Index])
			Print("\n")
		}
		
		Print("}\n")
	}
}

struct AMLDefineMethod {
	i32 Length
	AMLNameString* Name
	i8 Flags
	i32 Count
	AMLTerm** Terms
	
	define void Print() {
		Print("AMLDefineMethod ")
		this->Name->Print()
		Print(" %x {\n", this->Flags)
		
		for (i32 Index := 0, Index < this->Count, Index++) {
			Print("\t")
			PrintTerm(this->Terms[Index])
			Print("\n")
		}
		
		Print("}\n")
	}
}

i8 AML_ALIAS_OP := 0x6
i8 AML_NAME_OP := 0x8
i8 AML_SCOPE_OP := 0x10
i8 AML_METHOD_OP := 0x14

i8 AML_EXT_REGION_OP := 0x80 As i8
i8 AML_EXT_FIELD_OP := 0x81 As i8

i8 AML_EXPRESSION_OP := 0x96 As i8
i8 AML_STATEMENT_OP := 0x97 As i8

struct AMLTerm {
	union {
		AMLDefineRegion* Region
		AMLDefineField* Field
		AMLDefineScope* Scope
		AMLDefineMethod* Method
		AMLExpressionOpcode* Expression
		AMLStatementOpcode* Statement
	}
	
	i8 Kind
	
	define void Print() {
		if (this->Kind = AML_SCOPE_OP) {
			this->Scope->Print()
		}
		else if (this->Kind = AML_METHOD_OP) {
			this->Method->Print()
		}
		else if (this->Kind = AML_EXPRESSION_OP) {
			this->Expression->Print()
		}
		else if (this->Kind = AML_STATEMENT_OP) {
			this->Statement->Print()
		}
		else if (this->Kind = AML_EXT_REGION_OP) {
			this->Region->Print()
		}
		else if (this->Kind = AML_EXT_FIELD_OP) {
			this->Field->Print()
		}
	}
}

define void PrintTerm(AMLTerm* Term) {
	Term->Print()
}

i64 AML_INVALID_SYNTAX := 'AML_USUK'

struct AMLParser {
	
	union {
		void* RawBuffer
		i8* Buffer
	}
	
	i32 Index
	i32 Length
	
	define i8 IsAtEnd() {
		return this->Index >= this->Length
	}
	
	define i8 Peek() {
		return this->Buffer[this->Index]
	}

	define i8 Next() {
		return this->Buffer[this->Index++]
	}
	
	define i8 NextMatches(i8 Value) {
		if (this->Peek() = Value) {
			this->Next()
			
			return true
		}
		
		return false
	}
	
	define void Fail() {
		Print("At byte %x\n", this->Index)
		
		for (i32 Index := this->Index - 10, Index < this->Index + 10, Index++) {
			Print("%c", this->Buffer[Index])
		}
		
		Throw(AML_INVALID_SYNTAX)
	}
	define void Fail(i8* Reason, i8 Unknown) {
		Print("%s\n", Reason)
		Print("%x '%c'\n", Unknown, Unknown)
		this->Fail()
	}
	
	define i32 ParsePackageLength() {
		i8 First := this->Next()
		i32 Length := (First & 0b11_00_0000) >> 6
		i32 Value := First & 0b00_00_1111
		
		if (Length = 0) {
			Value |= First & 0b00_11_0000
		}
		
		for (i32 Index := 0, Index < Length, Index++) {
			i8 Shift := ((Index * 8) + 4) As i8
			
			Value |= this->Next() << Shift
		}
		
		return Value
	}
	
	define i8 ParseLeadNameCharacter() {
		i8 Next := this->Next()
		
		if (('A' <= Next && Next <= 'Z') || Next = '_') {
			return Next
		}
		
		this->Fail("Expected [_A-Z] for lead name", Next)
		return 0
	}
	define i8 ParseNameCharacter() {
		i8 Next := this->Next()
		
		if (('A' <= Next && Next <= 'Z') || Next = '_') {
			return Next
		}
		else if ('0' <= Next && Next <= '9') {
			return Next
		}
		
		this->Fail()
		return 0
	}
	
	define i32 ParseNameSegment() {
		i32 Result := this->ParseLeadNameCharacter()
		
		Result |= this->ParseNameCharacter() << 8
		Result |= this->ParseNameCharacter() << 16
		Result |= this->ParseNameCharacter() << 24
		
		return Result
	}
	
	define void ParseNamePath(AMLNameString* Result) {
		if (this->NextMatches(AML_DUAL_NAME_PREFIX)) {
			Result->Kind := AML_NAME_STRING_DUAL
			Result->DirectNameSegments[0] := this->ParseNameSegment()
			Result->DirectNameSegments[1] := this->ParseNameSegment()
		}
		else if (this->NextMatches(AML_MULTI_NAME_PREFIX)) {
			Result->Kind := AML_NAME_STRING_MULTI
			
			i8 Count := this->Next()
			
			Result->IndirectSegmentCount := Count
			Result->IndirectNameSegments := Alloc(Count * #i32)
			
			for (i32 Index := 0, Index < Count, Index++) {
				Result->IndirectNameSegments[Index] := this->ParseNameSegment()
			}
		}
		else if (this->NextMatches(0)) {
			Result->Kind := AML_NAME_STRING_NULL
		}
		else {
			Result->Kind := AML_NAME_STRING_SINGLE
			Result->DirectNameSegments[0] := this->ParseNameSegment()
		}
	}
	
	define AMLNameString* ParseNameString() {
		AMLNameString* Result := Alloc(#AMLNameString)
		
		i8 MaybeRootCharacter := this->Peek()
		
		if (this->NextMatches('\') || this->NextMatches('^')) {
			Result->RootCharacter := MaybeRootCharacter
		}
		
		this->ParseNamePath(Result)
		
		return Result
	}
	
	define i64 ReadByte() {
		return this->Next()
	}
	define i64 ReadWord() {
		return this->ReadByte() | (this->ReadByte() << 8)
	}
	define i64 ReadDoubleWord() {
		return this->ReadWord() | (this->ReadWord() << 16)
	}
	define i64 ReadQuadWord() {
		return this->ReadDoubleWord() | (this->ReadDoubleWord() << 32)
	}
	
	define AMLDataObject* ParseDataObject() {
		AMLDataObject* Result := Alloc(#AMLDataObject)
		
		i8 Next := this->Next()
		
		Result->Kind := Next
		
		if (Next = AML_DATA_OBJECT_BYTE_PREFIX) {
			Result->ByteValue := this->ReadByte() As i8
		}
		else if (Next = AML_DATA_OBJECT_WORD_PREFIX) {
			Result->WordValue := this->ReadWord() As i16
		}
		else if (Next = AML_DATA_OBJECT_DWORD_PREFIX) {
			Result->DoubleWordValue := this->ReadDoubleWord() As i32
		}
		else if (Next = AML_DATA_OBJECT_QWORD_PREFIX) {
			Result->QuadWordValue := this->ReadQuadWord()
		}
		else if (Next = AML_DATA_OBJECT_STRING_PREFIX) {
			Result->StringValue := &this->Buffer[this->Index]
			
			while (this->Next() != 0) {}
		}
		else if (Next = AML_DATA_OBJECT_CONST_ZERO_OP) {
			Result->QuadWordValue := 0
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONE_OP) {
			Result->QuadWordValue := 1
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONES_OP) {
			Result->QuadWordValue := -1
		}
		
		return Result
	}
	
	define i8 NextIsDataObject() {
		i8 Next := this->Peek()
		
		if (AML_DATA_OBJECT_BYTE_PREFIX <= Next && Next <= AML_DATA_OBJECT_QWORD_PREFIX) {
			return true
		}
		else if (Next = AML_DATA_OBJECT_CONST_ZERO_OP || Next = AML_DATA_OBJECT_CONST_ONE_OP) {
			return true
		}
		else if (Next = AML_DATA_OBJECT_CONST_ONES_OP) {
			return true
		}
		
		return false
	}
	define i8 NextIsLocalObject() {
		i8 Next := this->Peek()
		
		return 0x60 <= Next && Next <= 0x67
	}
	define i8 NextIsArgObject() {
		i8 Next := this->Peek()
		
		return 0x68 <= Next && Next <= 0x6E
	}
	define AMLSuperName* ParseSuperName() {
		AMLSuperName* Result := Alloc(#AMLSuperName)
		
		if (this->NextIsLocalObject()) {
			Result->Kind := AML_SUPERNAME_LOCAL
			Result->LocalNumber := this->Next() - 0x60
		}
		else if (this->NextIsArgObject()) {
			Result->Kind := AML_SUPERNAME_ARG
			Result->ArgNumber := this->Next() - 0x68
		}
		else {
			Result->Kind := AML_SUPERNAME_NAME
			Result->Name := this->ParseNameString()
		}
		
		return Result
	}
	define AMLTarget* ParseTarget() {
		AMLTarget* Result := Alloc(#AMLTarget)
		
		if (this->NextMatches(0)) {
			Result->Kind := AML_TARGET_NULL
		}
		else {
			Result->Kind := AML_TARGET_SUPERNAME
			Result->SuperName := this->ParseSuperName()
		}
		
		return Result
	}
	
	declare AMLTermArg* ParseTermArg()
	
	define i8 NextIsDataTarget() {
		i32 Next := (this->Peek() As i32) & 0xFF
		
		return 0x96 <= Next && Next <= 0x99
	}
	define AMLDataTargetOperation* ParseDataTarget() {
		AMLDataTargetOperation* Result := Alloc(#AMLDataTargetOperation)
		
		Result->Operation := this->Next()
		
		Result->Data := this->ParseTermArg()
		Result->Target := this->ParseTarget()
		
		return Result
	}
	
	define i8 NextIsDataDataTarget() {
		i32 Next := (this->Peek() As i32) & 0xFF
		
		if (0x72 <= Next && Next <= 0x74) {
			return true
		}
		else if (0x77 <= Next && Next <= 0x7F && Next != 0x78) {
			return true
		}
		else if (Next = 0x84 || Next = 0x85 || Next = 0x88) {
			return true
		}
		
		return false
	}
	define AMLDataDataTargetOperation* ParseDataDataTarget() {
		AMLDataDataTargetOperation* Result := Alloc(#AMLDataDataTargetOperation)
		
		i32 Next := (this->Next() As i32) & 0xFF
		
		if (0x72 <= Next && Next <= 0x74) {
			Result->Operation := (Next - 0x72) As i8
		}
		else if (0x77 <= Next && Next <= 0x7F) {
			Result->Operation := (2 + (Next - 0x77)) As i8
		}
		else if (Next = 0x84 || Next = 0x85) {
			Result->Operation := (11 + (Next = 0x85)) As i8
		}
		else if (Next = 0x88) {
			Result->Operation := 13
		}
		
		Result->Left := this->ParseTermArg()
		Result->Right := this->ParseTermArg()
		Result->Target := this->ParseTarget()
		
		return Result
	}
	
	define i8 NextIsSuperNameOperation() {
		i32 Next := this->Peek()
		
		if      (Next = AML_SUPERNAME_REF_OF   ) { return true }
		else if (Next = AML_SUPERNAME_INCREMENT) { return true }
		else if (Next = AML_SUPERNAME_DECREMENT) { return true }
		else if (Next = AML_SUPERNAME_SIZEOF   ) { return true }
		else if (Next = AML_SUPERNAME_TYPEOF   ) { return true }
		
		return false
	}
	define AMLSuperNameOperation* ParseSuperNameOperation() {
		AMLSuperNameOperation* Result := Alloc(#AMLSuperNameOperation)
		
		Result->Kind := this->Next()
		Result->SuperName := this->ParseSuperName()
		
		return Result
	}
	
	define i8 NextIsDataData() {
		i32 Next := (this->Peek() As i32) & 0xFF
		
		if (0x90 <= Next && Next <= 0x95) {
			if (Next = 0x92) {
				i8 Peek := this->Buffer[this->Index + 2]
				
				return 0x93 <= Peek && Peek <= 0x95
			}
			
			return true
		}
		
		return false
	}
	define AMLDataDataOperation* ParseDataData() {
		AMLDataDataOperation* Result := Alloc(#AMLDataDataOperation)
		
		i8 Operation := this->Next()
		
		if (Operation = 0x92) {
			Result->Operation := (this->Next() - 0x91) As i8
		}
		else if (Operation >= 0x93) {
			Result->Operation := ((Operation - 0x90) + 2) As i8
		}
		else {
			Result->Operation := (Operation - 0x90) As i8
		}
		
		Result->Left := this->ParseTermArg()
		Result->Right := this->ParseTermArg()
		
		return Result
	}
	
	define i8 NextIsDataOperation() {
		i8 Next := this->Peek()
		
		return Next = AML_DATA_OP_DEREF || Next = AML_DATA_OP_LNOT
	}
	define AMLDataOperation* ParseDataOperation() {
		AMLDataOperation* Result := Alloc(#AMLDataOperation)
		
		Result->Operation := this->Next()
		Result->Operand := this->ParseTermArg()
		
		return Result
	}
	
	define i8 NextIsExpression() {
		i8 Next := this->Peek()
		
		if (Next = AML_STORE_OPERATION) {
			return true
		}
		
		return this->NextIsDataTarget() || this->NextIsDataDataTarget()
		|| this->NextIsSuperNameOperation() || this->NextIsDataData()
		|| this->NextIsDataOperation()
	}
	
	define AMLExpressionOpcode* ParseExpression() {
		AMLExpressionOpcode* Result := Alloc(#AMLExpressionOpcode)
		
		if (this->NextIsDataTarget()) {
			Result->Kind := AML_EXPRESSION_DATA_TARGET
			Result->DataTarget := this->ParseDataTarget()
		}
		else if (this->NextIsDataDataTarget()) {
			Result->Kind := AML_EXPRESSION_DATA_DATA_TARGET
			Result->DataDataTarget := this->ParseDataDataTarget()
		}
		else if (this->NextIsDataData()) {
			Result->Kind := AML_EXPRESSION_DATA_DATA
			Result->DataData := this->ParseDataData()
		}
		else if (this->NextIsDataOperation()) {
			Result->Kind := AML_EXPRESSION_DATA
			Result->DataOperation := this->ParseDataOperation()
		}
		else if (this->NextIsSuperNameOperation()) {
			Result->Kind := AML_EXPRESSION_SUPER_NAME_OPERATION
			Result->SuperNameOperation := this->ParseSuperNameOperation()
		}
		else if (this->NextMatches(AML_STORE_OPERATION)) {
			Result->Kind := AML_EXPRESSION_STORE_OPERATION
			
			Result->StoreOperation := Alloc(#AMLStoreOperation)
			Result->StoreOperation->Source := this->ParseTermArg()
			Result->StoreOperation->Destination := this->ParseSuperName()
		}
		
		return Result
	}
	
	define AMLTermArg* ParseTermArg() {
		AMLTermArg* Result := Alloc(#AMLTermArg)
		
		if (this->NextIsDataObject()) {
			Result->Kind := AML_TERM_ARG_DATA_OBJECT
			Result->DataObject := this->ParseDataObject()
		}
		else if (this->NextIsLocalObject()) {
			Result->Kind := AML_TERM_ARG_LOCAL_OBJECT
			Result->LocalNumber := this->Next() - 0x60
		}
		else if (this->NextIsArgObject()) {
			Result->Kind := AML_TERM_ARG_ARG_OBJECT
			Result->ArgNumber := this->Next() - 0x68
		}
		else if (this->NextIsExpression()) {
			Result->Kind := AML_TERM_ARG_EXPRESSION
			Result->Expression := this->ParseExpression()
		}
		else {
			this->Fail("Unimplemented term-arg", this->Peek())
		}
		
		return Result
	}
	
	declare AMLTerm** ParseTermList(i32, i32*)
	
	define AMLWhileLoop* ParseWhile() {
		AMLWhileLoop* Result := Alloc(#AMLWhileLoop)
		
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		Result->Condition := this->ParseTermArg()
		i32 End := Start + Result->Length
		
		Result->Body := this->ParseTermList(End, Result~>Count)
		
		return Result
	}
	
	define i8 NextIsStatement() {
		i8 Next := this->Peek()
		
		if (Next = AML_WHILE_OP) {
			return true
		}
		
		return false
	}
	define AMLStatementOpcode* ParseStatement() {
		AMLStatementOpcode* Result := Alloc(#AMLStatementOpcode)
		
		Result->Kind := this->Peek()
		
		if (this->NextMatches(AML_WHILE_OP)) {
			Result->WhileLoop := this->ParseWhile()
		}
		
		return Result
	}
	
	define AMLDefineRegion* ParseDefineRegion() {
		AMLDefineRegion* Result := Alloc(#AMLDefineRegion)
		
		Result->Name := this->ParseNameString()
		Result->AddressSpace := this->Next()
		Result->Offset := this->ParseTermArg()
		Result->Length := this->ParseTermArg()
		
		return Result
	}
	
	define AMLNamedField* ParseNamedField() {
		AMLNamedField* Result := Alloc(#AMLNamedField)
		
		Result->Name := this->ParseNameString()
		Result->Length := this->ParsePackageLength()
		
		return Result
	}
	
	define AMLField* ParseField() {
		AMLField* Result := Alloc(#AMLField)
		
		Result->Kind := AML_FIELD_NAMED
		Result->Named := this->ParseNamedField()
		
		return Result
	}
	
	define AMLDefineField* ParseDefineField() {
		AMLDefineField* Result := Alloc(#AMLDefineField)
		
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		Result->Name := this->ParseNameString()
		Result->Flags := this->Next()
		i32 End := Start + Result->Length
		
		i32 FieldCountGuess := (Result->Length - 6) / 4
		Result->Fields := Alloc(FieldCountGuess * #AMLField*)
		
		i32 Index := 0
		
		while (this->Index < End) {
			Result->Fields[Index++] := this->ParseField()
		}
		
		Result->Count := Index
		
		return Result
	}
	
	define AMLDefineScope* ParseDefineScope() {
		AMLDefineScope* Result := Alloc(#AMLDefineScope)
		
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		Result->Name := this->ParseNameString()
		i32 End := Start + Result->Length
		
		Result->Terms := this->ParseTermList(End, Result~>Count)
		
		return Result
	}
	
	define AMLDefineMethod* ParseDefineMethod() {
		AMLDefineMethod* Result := Alloc(#AMLDefineMethod)
		
		i32 Start := this->Index
		Result->Length := this->ParsePackageLength()
		Result->Name := this->ParseNameString()
		Result->Flags := this->Next()
		i32 End := Start + Result->Length
		
		Result->Terms := this->ParseTermList(End, Result~>Count)
		
		return Result
	}
	
	define AMLTerm* ParseTerm() {
		AMLTerm* Result := Alloc(#AMLTerm)
		
		Result->Kind := 0
		
		if (this->NextMatches(AML_SCOPE_OP)) {
			Result->Kind := AML_SCOPE_OP
			Result->Scope := this->ParseDefineScope()
		}
		else if (this->NextMatches(AML_METHOD_OP)) {
			Result->Kind := AML_METHOD_OP
			Result->Method := this->ParseDefineMethod()
		}
		else if (this->NextIsExpression()) {
			Result->Kind := AML_EXPRESSION_OP
			Result->Expression := this->ParseExpression()
		}
		else if (this->NextIsStatement()) {
			Result->Kind := AML_STATEMENT_OP
			Result->Statement := this->ParseStatement()
		}
		else if (this->NextMatches('[')) {
			if (this->NextMatches(AML_EXT_REGION_OP)) {
				Result->Kind := AML_EXT_REGION_OP
				Result->Region := this->ParseDefineRegion()
			}
			else if (this->NextMatches(AML_EXT_FIELD_OP)) {
				Result->Kind := AML_EXT_FIELD_OP
				Result->Field := this->ParseDefineField()
			}
			
		}
		
		if (Result->Kind = 0) {
			this->Fail("Unimplemented term", this->Peek())
		}
		
		return Result
	}
	
	define AMLTerm** ParseTermList(i32 End, i32* OutCount) {
		i32 Length := End - this->Index
		i32 TermCountGuess := Length / 4
		AMLTerm** Terms := Alloc(TermCountGuess * #AMLTerm*)
		
		i32 Index := 0
		
		while (this->Index < End) {
			Terms[Index++] := this->ParseTerm()
			
			if (Index >= TermCountGuess) {
				this->Fail("Bad term count guess", 0)
			}
		}
		
		*OutCount := Index
		
		return Terms
	}
	
}

define void Main() {
	Print("%x %x\n", #AMLTerm, #AMLTermArg)
	Print("%x\n", (null As AMLTerm*)~>Statement~>WhileLoop~>Body)

	i64 F := FileOpen("example.aml", FILE_READ)
	
	i32 Size := FileGetSize(F)
	void* AML := FileReadAll(F)
	
	FileClose(F)
	
	AMLParser* P := Alloc(#AMLParser)
	
	P->Buffer := AML
	P->Length := Size
	
	AMLTerm* Root := P->ParseTerm()
	
	Root->Print()
}

; https://uefi.org/sites/default/files/resources/ACPI_6_2.pdf