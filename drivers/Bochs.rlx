#Require "./src/utility/String.rlx"

define void BochsPrintCharacter(i8 Character) {
	asm (rdx := 0xE9, rax := Character) {
		outb
	}
}
define void BochsPrintCharacters(i8* Characters, i32 Count) {
	for (i32 Index := 0, Index < Count, Index++) {
		BochsPrintCharacter(Characters[Index])
	}
}
define void BochsPrintString(i8* String) {
	BochsPrintCharacters(String, StringLength(String))
}
define void BochsPrintNewLine() {
	BochsPrintCharacter(13)
	BochsPrintCharacter(10)
}

i8[96] BochsPrintBuffer

define void ClearBochsPrintBuffer() {
	for (i32 Index := 0, Index < 12, Index += 1) {
		(BochsPrintBuffer As i64*)[Index] := 0
	}
}

define void BochsPrint(i64 Number) {
	ClearBochsPrintBuffer()
	IToA(Number, 10, BochsPrintBuffer)
	BochsPrintString(BochsPrintBuffer)
}
define void BochsPrintHex(i64 Number, i8 WithZeroX) {
	ClearBochsPrintBuffer()
	IToA(Number, 16, BochsPrintBuffer, WithZeroX)
	BochsPrintString(BochsPrintBuffer)
}
define void BochsPrintBinary(i64 Number) {
	ClearBochsPrintBuffer()
	IToA(Number, 2, BochsPrintBuffer)
	BochsPrintString(BochsPrintBuffer)
}
define void BochsPrintHex(i64 Number) {
	BochsPrintHex(Number, true)
}
define void BochsPrintLiteral(i64 PackedCharacters) {
	i8* Characters := (&PackedCharacters) As i8*
	
	for (i32 Length := 0, (Length < 8) && (Characters[Length] != 0), Length += 1) {}
	
	BochsPrintCharacters(Characters, Length)
}

define void BochsPrint(i8* Format, ... Args) {
	if (USE_BOCHS_PORT_HACK) {
		i32 Length := StringLength(Format)
		i32 ArgIndex := 1
		
		for (i32 Index := 0, Index < Length, Index += 1) {
			i8 Next := Format[Index]
			
			if (Next = '%') {
				Index += 1
				Next := Format[Index]
				void NextArg := Args[ArgIndex]
				
				if (Next = 'i') {
					BochsPrint(NextArg As i64)
				}
				else if (Next = 'x') {
					BochsPrintHex(NextArg As i64)
				}
				else if (Next = 'c') {
					BochsPrintCharacter(NextArg As i8)
				}
				else if (Next = 's') {
					BochsPrintString(NextArg As i8*)
				}
				else if (Next = 'l') {
					BochsPrintLiteral(NextArg As i64)
				}
				else if (Next = 'b') {
					BochsPrintBinary(NextArg As i64)
				}
				
				ArgIndex += 1
			}
			else {
				BochsPrintCharacter(Next)
			}
		}
	}
}

#Require "./src/utility/Exception.rlx"

define void BochsPrintStackDump(i64 RBP) {
	BochsPrint("\nStack dump:\n")
	
	StackFrame* Last := RBP As StackFrame*
	i32 Index := 1
	
	while (Last) {
		if (Last->LastFrame & 1) {
			StackFrame* Temp := Last->LastFrame - 1
			
			BochsPrint("\tStack[%i] Try catch address = %x\n", Index, Last->ReturnAddress, Temp)
			Index += 1
			
			Last := Temp
		}
		else {
			i64* MaybeMagic := (Last - 0x8) As i64*
			i8** MaybeName := (Last - 0x10) As i8**
			
			if (Debug && *MaybeMagic = 0x12345678) {
				BochsPrint("\tStack[%i] Fn = (%x) %s\n", Index, Last->ReturnAddress, *MaybeName)
			}
			else {
				BochsPrint("\tStack[%i] Fn callsite = %x\n", Index, Last->ReturnAddress, Last->LastFrame)
			}
			
			Index += 1
			
			Last := Last->LastFrame
		}
	}
}