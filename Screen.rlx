

i32 SCREEN_WIDTH := 1024
i32 SCREEN_HEIGHT := 768
i32 COLOR_DEPTH := 24
i32 BYTES_PER_PIXEL := 3

i32 PIXEL_COUNT := SCREEN_WIDTH * SCREEN_HEIGHT
i32 FRAMEBUFFER_SIZE := PIXEL_COUNT * COLOR_DEPTH
i32 ROW_SIZE := SCREEN_WIDTH * BYTES_PER_PIXEL

struct Pixel {
	i8 Red
	i8 Green
	i8 Blue
	
	define void SetColor(i32 Color) asm {
		mov, r8b, {rdi + 3} As i8*
		mov, {rdi} As i32*, esi
		mov, {rdi + 3} As i8*, r8b
		ret
	}
}

define Pixel* FastGetPixelAddress(i32 X, i32 Y, i32 Width, i32 BytesPerPixel, Pixel* PixelBuffer) asm {
	imul, rsi, rdx
	add, rsi, rdi
	
	imul, rsi, rcx
	
	mov, rax, r8
	add, rax, rsi
	
	ret
}

; WARNING: This function assumes a 1024 width screen, with 24 bpp
define void FastSetPixel(void* Dummy, i32 X, i32 Y, i32 Color) asm {
	mov, rax, 0xE000_0000
	mov, ebx, 1024
	
	imul, edx, ebx
	add, edx, esi
	
	mov, ebx, 3
	imul, edx, ebx
	
	add, rax, rdx
	
	mov, b, {rax + 3} As i8*
	mov, {rax} As i32*, ecx
	mov, {rax + 3} As i8*, b
	ret
}

struct Screen {
	union {
		void* RawFrameBuffer
		i8* FrameBuffer
		Pixel* PixelBuffer
	}
	
	i32 FillColor
	
	define void Adopt(void* RawFrameBuffer, i32 FillColor) {
		this->RawFrameBuffer := RawFrameBuffer
		this->FillColor := FillColor
		
		i64* FastSetPixelTarget := &FastSetPixel + 2
		*FastSetPixelTarget := RawFrameBuffer As i64
	}
	
	define Pixel* GetPixelAddress(i32 X, i32 Y) {
		i32 Index := (Y * SCREEN_WIDTH) + X
		i32 Offset := Index * BYTES_PER_PIXEL
		
		return this->PixelBuffer + Offset
	}
	;define void SetPixel(i32 X, i32 Y, i32 Color) {
	;	FastGetPixelAddress(X, Y, SCREEN_WIDTH, BYTES_PER_PIXEL, this->PixelBuffer)->SetColor(Color)
	;}
	define void SetPixel(i32 X, i32 Y, i32 Color) asm {
		jmp, @FastSetPixel
	}
	define void DrawRectangle(i32 X, i32 Y, i32 Width, i32 Height, i32 Color) {
		for (i32 RowIndex := 0, RowIndex < Height, RowIndex += 1) {
			for (i32 ColumnIndex := 0, ColumnIndex <= Width, ColumnIndex += 1) {
				this->SetPixel(X + ColumnIndex, Y + RowIndex, Color)
			}
		}
	}
	define void DrawCharacter(i32 X, i32 Y, i8 Character, i32 ForegroundColor, i32 BackgroundColor) {
		if (Character = ' ') {
			this->DrawRectangle(X, Y, 8, 12, BackgroundColor)
			return
		}
		
		Glyph* CharacterGlyph := Font + (Character - FIRST_CHARACTER) * #Glyph
		
		for (i32 RowIndex := 0, RowIndex < 12, RowIndex += 1) {
			i8 RowData := CharacterGlyph~>Rows[RowIndex]
			
			for (i8 ColumnIndex := 0, ColumnIndex < 8, ColumnIndex += 1) {
				i8 Mask := (1 << ColumnIndex) As i8
				
				if (RowData & Mask) {
					this->SetPixel(X - ColumnIndex + 8, Y + RowIndex, ForegroundColor)
				}
				else {
					this->SetPixel(X - ColumnIndex + 8, Y + RowIndex, BackgroundColor)
				}
			}
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 TextLength, i32 ForegroundColor, i32 BackgroundColor) {
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			this->DrawCharacter(X, Y, Text[Index], ForegroundColor, BackgroundColor)
			
			X += 8
			
			if (X >= SCREEN_WIDTH) {
				X := 0
				Y -= 12
			}
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 ForegroundColor, i32 BackgroundColor) {
		this->DrawText(X, Y, Text, StringLength(Text), ForegroundColor, BackgroundColor)
	}
	
	define void VerticalScroll(i32 Offset) {
		i32 GAP_SIZE := Offset * ROW_SIZE
		
		void* TopRow := this->RawFrameBuffer
		void* NewTopRow := TopRow + GAP_SIZE
		
		i32 Y := 0
		
		if (Offset < 0) {
			Offset := -Offset
			
			GAP_SIZE := Offset * ROW_SIZE
			
			NewTopRow := this->RawFrameBuffer
			TopRow := NewTopRow + GAP_SIZE
			
			Y := SCREEN_HEIGHT - Offset
		}
		
		FastMoveMemory(NewTopRow, TopRow, FRAMEBUFFER_SIZE - GAP_SIZE)
		this->DrawRectangle(0, Y, SCREEN_WIDTH, Offset, this->FillColor)
	}
}

Screen RawScreen
Screen* Screen := &RawScreen