

i32 SCREEN_WIDTH := 1024
i32 SCREEN_HEIGHT := 768
i32 COLOR_DEPTH := 24
i32 BYTES_PER_PIXEL := 3

i32 PIXEL_COUNT := SCREEN_WIDTH * SCREEN_HEIGHT
i32 FRAMEBUFFER_SIZE := (PIXEL_COUNT + 1) * BYTES_PER_PIXEL
i32 ROW_SIZE := SCREEN_WIDTH * BYTES_PER_PIXEL

struct Pixel {
	i8 Red
	i8 Green
	i8 Blue
	
	define void SetColor(i32 Color) asm {
		mov, r8b, {rdi + 3} As i8*
		mov, {rdi} As i32*, esi
		mov, {rdi + 3} As i8*, r8b
		ret
	}
}

define Pixel* FastGetPixelAddress(i32 X, i32 Y, i32 Width, i32 BytesPerPixel, Pixel* PixelBuffer) asm {
	imul, rsi, rdx
	add, rsi, rdi
	
	imul, rsi, rcx
	
	mov, rax, r8
	add, rax, rsi
	
	ret
}

; WARNING: This function assumes a 1024 width screen, with 24 bpp
define void FastSetPixel(void* Dummy, i32 X, i32 Y, i32 Color) asm {
	mov, rax, 0xE000_0000
	mov, ebx, 1024
	
	imul, edx, ebx
	add, edx, esi
	
	mov, ebx, 3
	imul, edx, ebx
	
	add, rax, rdx
	
	mov, b, {rax + 3} As i8*
	mov, {rax} As i32*, ecx
	mov, {rax + 3} As i8*, b
	ret
}

declare void Print(i8*, ...)

struct Screen {
	union {
		void* RawFrameBuffer
		i8* FrameBuffer
		Pixel* PixelBuffer
	}
	
	i32 Width
	i32 Height
	i32 Depth
	i32 RawStride
	i32 FillColor
	
	i32 Stride
	i32 PixelCount
	i32 FrameBufferSize
	i32 RowSize
	
	Screen* Next
	Screen* FirstChild
	
	void* OnClearData
	void* OnClear
	
	define void Adopt(void* RawFrameBuffer, i32 Width, i32 Height, i32 Depth, i32 StrideOffset, i32 FillColor) {
		this->RawFrameBuffer := RawFrameBuffer
		this->Width := Width
		this->Height := Height
		this->Depth := Depth
		this->RawStride := StrideOffset
		this->FillColor := FillColor
		
		this->Stride := Width + StrideOffset
		this->RowSize := (Width * Depth) + StrideOffset
		this->PixelCount := Width * Height
		this->FrameBufferSize := (this->PixelCount * Depth) + (StrideOffset * Height)
	}
	define void SetClearListener(void* Function, void* Data) {
		this->OnClearData := Data
		this->OnClear := Function
	}
	
	define Pixel* GetPixelAddress(i32 X, i32 Y) {
		i32 Index := (Y * this->Stride) + X
		i32 Offset := Index * this->Depth
		
		return this->PixelBuffer + Offset
	}
	define void SetPixel(i32 X, i32 Y, i32 Color) {
		FastGetPixelAddress(X, Y, this->Stride, this->Depth, this->PixelBuffer)->SetColor(Color)
	}
	define void DrawRectangle(i32 X, i32 Y, i32 Width, i32 Height, i32 Color) {
		i32 Red := Color >> 16 & 0xFF
		i32 Green := Color >> 8 & 0xFF
		i32 Blue := Color & 0xFF
		
		if (Red = Green && Green = Blue) {
			; If we're drawing a rectangle which is monochrome, we can just set entire rows to be the exact same
			;  byte with `rep stosb`
			
			i32 RectangleRowSize := Width * this->Depth
			
			for (i32 FastRowIndex := 0, FastRowIndex < Height, FastRowIndex += 1) {
				FastSetMemory8(this->GetPixelAddress(X, Y + FastRowIndex), Blue, RectangleRowSize)
			}
			
			return
		}
		
		for (i32 RowIndex := 0, RowIndex < Height, RowIndex += 1) {
			for (i32 ColumnIndex := 0, ColumnIndex <= Width, ColumnIndex += 1) {
				this->SetPixel(X + ColumnIndex, Y + RowIndex, Color)
			}
		}
	}
	define void DrawCharacter(i32 X, i32 Y, i8 Character, i32 ForegroundColor, i32 BackgroundColor) {
		if (Character = ' ') {
			this->DrawRectangle(X, Y, 8, 12, BackgroundColor)
			return
		}
		
		Glyph* CharacterGlyph := Font + (Character - FIRST_CHARACTER) * #Glyph
		
		for (i32 RowIndex := 0, RowIndex < 12, RowIndex += 1) {
			i8 RowData := CharacterGlyph~>Rows[RowIndex]
			
			for (i8 ColumnIndex := 0, ColumnIndex < 8, ColumnIndex += 1) {
				i8 Mask := (1 << ColumnIndex) As i8
				
				if (RowData & Mask) {
					this->SetPixel(X - ColumnIndex + 7, Y + RowIndex, ForegroundColor)
				}
				else {
					this->SetPixel(X - ColumnIndex + 7, Y + RowIndex, BackgroundColor)
				}
			}
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 TextLength, i32 ForegroundColor, i32 BackgroundColor) {
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			if (X + 8 >= this->Width) {
				X := 0
				Y += 12
			}
			
			this->DrawCharacter(X, Y, Text[Index], ForegroundColor, BackgroundColor)
			
			X += 8
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 ForegroundColor, i32 BackgroundColor) {
		this->DrawText(X, Y, Text, StringLength(Text), ForegroundColor, BackgroundColor)
	}
	
	define void Clear() {
		this->DrawRectangle(0, 0, this->Width, this->Height, this->FillColor)
		
		if (this->OnClear != null) {
			asm (rax := this->OnClear, rdi := this->OnClearData, rsi := this) {
				call, rax
			}
		}
		
		if (this->FirstChild != null) {
			this->FirstChild->Clear()
		}
		
		if (this->Next != null) {
			this->Next->Clear()
		}
	}
	
	define void PrintHierarchy(i32 Depth) {
		for (i32 Index := 0, Index < Depth, Index += 1) { Print("    ") }
		
		Print("|-> %ix%i\n", this->Width, this->Height)
		
		if (this->FirstChild != null) {
			this->FirstChild->PrintHierarchy(Depth + 1)
		}
		
		if (this->Next != null) {
			this->Next->PrintHierarchy(Depth)
		}
	}
	
	define void VerticalScroll(i32 Offset) {
		;i32 GapSize := Offset * this->RowSize
		;
		;void* TopRow := this->RawFrameBuffer
		;void* NewTopRow := TopRow + GapSize
		;
		;i32 Y := 0
		;
		;if (Offset < 0) {
		;	Offset := -Offset
		;	
		;	GapSize := Offset * this->RowSize
		;	
		;	NewTopRow := this->RawFrameBuffer
		;	TopRow := NewTopRow + GapSize
		;	
		;	Y := this->Height - Offset
		;}
		;
		;FastMoveMemory(NewTopRow, TopRow, this->FrameBufferSize - GapSize)
		;this->DrawRectangle(0, Y, this->Width, Offset, this->FillColor)
	}
	
	define Screen* CreateWindow(Screen* Window, i32 X, i32 Y, i32 Width, i32 Height, i32 FillColor) {
		i32 Stride := (this->Width - Width) + this->RawStride
		void* FrameBuffer := this->GetPixelAddress(X, Y)
		
		Window->Adopt(FrameBuffer, Width, Height, this->Depth, Stride, FillColor)
		Window->Clear()
		
		Window->Next := this->FirstChild
		this->FirstChild := Window
		
		return Window
	}
	define Screen* CreateWindow(i32 X, i32 Y, i32 Width, i32 Height, i32 FillColor) {
		return this->CreateWindow(KernelHeapAllocate('Window', #Screen), X, Y, Width, Height, FillColor)
	}
}

Screen RawScreen
Screen* NativeScreen := &RawScreen

Screen* UptimeDisplay := null