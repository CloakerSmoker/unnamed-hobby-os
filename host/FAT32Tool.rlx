#Require "$/Console.rlx"
#Require "$/Exception.rlx"
#Require "$/String.rlx"
#Require "$/File.rlx"
#Require "$/Debug.rlx"

define i64 AToI(i8* String, i32 Length, i64 Base) {
	i64 Result := 0
	i64 Negative := 0
	
	i8 FirstCharacter := String[0] As i8
	
	if !(IsNumeric(FirstCharacter, Base)) {
		return 0
	}
		
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 NextCharacter := String[Index] As i8
		
		if !(IsNumeric(NextCharacter, Base)) {
			Break
		}
		
		Result *= Base
		Result += GetCharacterValue(NextCharacter)
	}
	
	return Result
}
define i64 AToI(i8* String, i64 Base) {
	return AToI(String, StringLength(String), Base)
}

define i64 ParseInteger(i8* ValueString) {
	i64 Value := AToI(ValueString)
	
	if (ValueString[0] = '0' && ValueString[1] = 'x') {
		Value := AToI(&ValueString[2], 16)
	}
	
	return Value
}

define i64 ParseSectorCount(i8* ValueString, i8* Scale) {
	i64 Value := ParseInteger(ValueString)
	
	if (Scale != null) {
		if (Scale[0] = 'm') {
			Value *= 0x800	
		}
		else {
			Print("Unknown scale '%s', defaulting to 1\n", Scale)
		}
	}
	
	return Value
}

#Require "./src/drivers/FAT32.rlx"

struct FAT32FileBackedDevice {
	i64 FD
	
	define void Read(i32 SectorNumber, void* Buffer) {
		;Print("Read %x\n", SectorNumber)
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileRead(this->FD, Buffer, 512)
	}
	define void Write(i32 SectorNumber, void* Buffer) {
		;Print("Write %x\n", SectorNumber)
		FileSeek(this->FD, SectorNumber * 512, SEEK_SET)
		FileWrite(this->FD, Buffer, 512)
	}
	
	static void Read(FAT32FileBackedDevice* this, i32 Sector, void* Buffer) {
		this->Read(Sector, Buffer)
	}
	static void Write(FAT32FileBackedDevice* this, i32 Sector, void* Buffer) {
		this->Write(Sector, Buffer)
	}
	
	static FAT32DeviceTraits* New(i64 FD) {
		FAT32FileBackedDevice* this := Alloc(#FAT32FileBackedDevice)
		
		this->FD := FD
		
		FAT32DeviceTraits* Traits := Alloc(#FAT32DeviceTraits)
		
		Traits->State := this
		Traits->ReadSector := &FAT32FileBackedDevice:Read
		Traits->WriteSector := &FAT32FileBackedDevice:Write
		
		return Traits
	}
}

define void PrintFAT32DirectoryEntry(FAT32DirectoryEntry* this) {
	if (this->Name[0]) {
		if (this->IsLongNameEntry()) {
			FAT32LongDirectoryEntry* Long := this As FAT32LongDirectoryEntry*
			
			Print("FAT32LongDirectoryEntry {\n")
			Print("\tOrder: %x\n", Long->Order)
			Print("\tFirstFive: %s\n", WToA(Long->FirstFive, 5))
			Print("\tAttributes: %x\n", Long->Attributes)
			Print("\tLongEntryType: %x\n", Long->LongEntryType)
			Print("\tNextSix: %s\n", WToA(Long->NextSix, 6))
			Print("\tLastTwo: %s\n", WToA(Long->LastTwo, 2))
			Print("}\n")
			
		}
		else {
			Print("FAT32DirectoryEntry {\n")
			Print("\tName: %s\n", this->Name)
			Print("\tAttributes: %x\n", this->Attributes)
			Print("\tFirstClusterHigh: %x\n", this->FirstClusterHigh)
			Print("\tFirstClusterLow: %x\n", this->FirstClusterLow)
			Print("\tFirstCluster: %x\n", this->GetFirstCluster())
			Print("\tFileSize: %x\n", this->FileSize)
			Print("}\n")
		}
	}
}

define void PrintFAT32DirectoryEntryCluster(FAT32DirectoryCluster* this) {
	for (i32 Index := 0, Index < 16, Index++) {
		FAT32DirectoryEntry* Next := this->Entries[Index]
		
		PrintFAT32DirectoryEntry(Next)
	}
}

define void PrintFAT32Header(FAT32BootSector* this) {
	Print("FAT32BootSector {\n")
	
	Print("\tOEMIdentitier       : %s\n", this->OEMIdentitier)
	Print("\tBytesPerSector      : %x\n", this->BytesPerSector)
	Print("\tSectorsPerCluster   : %x\n", this->SectorsPerCluster)
	Print("\tReservedSectorCount : %x\n", this->ReservedSectorCount)
	Print("\tFATCount            : %x\n", this->FATCount)
	Print("\tDirectoryEntryCount : %x\n", this->DirectoryEntryCount)
	Print("\tVolumeSectorCount   : %x\n", this->VolumeSectorCount)
	Print("\tMediaDescriptorType : %x\n", this->MediaDescriptorType)
	Print("\tOldSectorsPerFAT    : %x\n", this->OldSectorsPerFAT)
	Print("\tSectorsPerTrack     : %x\n", this->MediaDescriptorType)
	Print("\tHeadCount           : %x\n", this->HeadCount)
	Print("\tHiddenSectorCount   : %x\n", this->HiddenSectorCount)
	Print("\tLargeSectorCount    : %x\n", this->LargeSectorCount)
	Print("\tSectorsPerFAT       : %x\n", this->SectorsPerFAT)
	Print("\tVersion             : %x\n", this->Version)
	Print("\tRootDirectoryCluster: %x\n", this->RootDirectoryCluster)
	Print("\tFSInfoSector        : %x\n", this->FSInfoSector)
	Print("\tBackupBootSector    : %x\n", this->BackupBootSector)
	Print("\tDriveNumber         : %x\n", this->DriveNumber)
	Print("\tSignature           : %x\n", this->Signature)
	Print("\tVolumeID            : %x\n", this->VolumeID)
	Print("\tVolumeLabel         : %s\n", this->VolumeLabel)
	
	Print("}\n")
}

define void PrintFAT32Info(FAT32Info* this) {
	Print("FAT32Info {\n")
	
	Print("\tFirstSignature          : %x\n", this->FirstSignature)
	Print("\tSecondSignature         : %x\n", this->SecondSignature)
	Print("\tLastKnownFreeSectorCount: %x\n", this->LastKnownFreeSectorCount)
	Print("\tFirstAvailableCluster   : %x\n", this->FirstAvailableCluster)
	
	Print("}\n")
}

define i32 PathToCluster(FAT32Device* Device, i32 CurrentDirectoryCluster, i8* Path) {
	if (StringEquals(Path, "~")) {
		return Device->Header->RootDirectoryCluster
	}
	else {
		FAT32DirectoryEntry* Directory := Device->FindDirectoryEntryByPath(CurrentDirectoryCluster, Path)
		
		if !(Directory) {
			if (StringEquals(Path, ".")) {
				return CurrentDirectoryCluster
			}
			
			Print("Could not find directory '%s'\n", Path)
			return -1
		}
		
		i32 Cluster := Directory->GetFirstCluster()
		
		if (Cluster = 0 && StringEquals(Path, "..")) {
			Cluster := Device->Header->RootDirectoryCluster
		}
		
		return Cluster
	}
}

define void Prompt(FAT32Device* Device) {
	PrintFAT32Header(Device->ReadHeader())
	PrintFAT32Info(Device->ReadInfo())
	
	i32 CurrentDirectoryCluster := Device->Header->RootDirectoryCluster
	
	loop {
		Print("^90->^F0")
		i8* NextLine := ReadLine()
		
		i64 ArgC := 0
		i8** ArgV := null
		
		ParseCommandLine(NextLine, &ArgC, &ArgV)
		i8* Command := ArgV[0]
		i8* Path := ArgV[1]
		
		if (StringEquals(Command, "format") && ArgC >= 2) {
			Device->Format(ParseSectorCount(ArgV[1], ArgV[2]) As i32)
			
			CurrentDirectoryCluster := Device->Header->RootDirectoryCluster
		}
		else if !(CurrentDirectoryCluster) {
			Print("Device is not formatted, run 'format {size} {scale}' first\n")
		}
		else if (StringEquals(Command, "header")  && ArgC = 1) {
			Device->Sync()
			PrintFAT32Header(Device->ReadHeader())
		}
		else if (StringEquals(Command, "info") && ArgC = 1) {
			Device->Sync()
			PrintFAT32Info(Device->ReadInfo())
		}
		else if (StringEquals(Command, "ls")) {
			if (ArgC = 1) {
				Path := "."
			}
			
			i32 DirectoryCluster := PathToCluster(Device, CurrentDirectoryCluster, Path)
			
			if (DirectoryCluster = -1) {
				continue
			}
			
			i32 WalkData := Device->StartWalkDirectory(DirectoryCluster)
	
			loop {
				FAT32DirectoryEntry* Next := Device->WalkDirectoryNext(DirectoryCluster, &WalkData)
				
				if !(Next) {
					break
				}
				
				if !(Next->IsLongNameEntry()) {
					i8[16] LongName
					
					Next->GetName(LongName)
					
					if (Next->IsFile()) {
						Print("%s\n", LongName)
					}
					else {
						Print("%s/\n", LongName)
					}
				}
			}
		}
		else if (StringEquals(Command, "cd") && ArgC = 2) {
			i32 DirectoryCluster := PathToCluster(Device, CurrentDirectoryCluster, Path)
			
			if (DirectoryCluster = -1) {
				continue
			}
			
			CurrentDirectoryCluster := DirectoryCluster
		}
		else if (StringEquals(Command, "deinfo_s") && ArgC = 2) {
			FAT32DirectoryEntry* Directory := Device->FindDirectoryEntryByPath(CurrentDirectoryCluster, Path)
		
			if !(Directory) {
				Print("Could not find entry '%s'\n", Path)
				continue
			}
			
			PrintFAT32DirectoryEntry(Directory)
		}
		else if (StringEquals(Command, "deinfo_i") && ArgC = 2) {
			i32 EntryIndex := ParseInteger(ArgV[1]) As i32
			FAT32DirectoryEntry* Directory := Device->GetDirectoryEntry(CurrentDirectoryCluster, EntryIndex)
		
			if !(Directory) {
				Print("Could not find entry [%x]\n", EntryIndex)
				continue
			}
			
			PrintFAT32DirectoryEntry(Directory)
		}
		else if (StringEquals(Command, "ctos") && ArgC = 2) {
			i32 ClusterNumber := ParseInteger(ArgV[1]) As i32
			
			Print("Cluster %x is sector %x\n", ClusterNumber, Device->ClusterToSector(ClusterNumber))
		}
		else if (StringEquals(Command, "stoo") && ArgC = 2) {
			i32 SectorNumber := ParseInteger(ArgV[1]) As i32
			
			Print("Sector %x is offset %x\n", SectorNumber, SectorNumber * 0x200)
		}
		else if (StringEquals(Command, "rename") && ArgC = 3) {
			FAT32DirectoryEntry* Entry := Device->FindDirectoryEntryByPath(CurrentDirectoryCluster, Path)
			
			i8[16] Name
			Entry->GetName(Name)
			
			FAT32DirectoryEntry* EntryClone := CloneMemory(Entry, #FAT32DirectoryEntry)
			
			EntryClone->SetName(ArgV[2])
			
			Device->UpdateDirectoryEntry(CurrentDirectoryCluster, Path, EntryClone)
		}
		else if (StringEquals(Command, "cat") && ArgC = 2) {
			FAT32DirectoryEntry* FileEntry := Device->FindDirectoryEntryByPath(CurrentDirectoryCluster, Path)
			
			if !(FileEntry) {
				Print("Could not find file '%s'\n", Path)
			}
			
			i32 CurrentCluster := FileEntry->GetFirstCluster()
			
			i8[0x200] TempSector
			
			loop {
				Device->ReadClusterData(CurrentCluster, 0, TempSector)
				
				Print("%s", TempSector)
				
				CurrentCluster := Device->LookupClusterChain(CurrentCluster, 1)
				
				if (CurrentCluster = -1) {
					break
				}
			}
		}
		else if (StringEquals(Command, "mkdir") && ArgC = 2) {
			Device->MakeDirectory(CurrentDirectoryCluster, ArgV[1])
		}
		else if (StringEquals(Command, "touch") && ArgC = 2) {
			Device->MakeFile(CurrentDirectoryCluster, ArgV[1])
		}
		else if (StringEquals(Command, "pwd")) {
			Print("%x\n", CurrentDirectoryCluster)
		}
		else if (StringEquals(Command, "fat") && ArgC = 3) {
			i32 Start := ParseInteger(ArgV[1]) As i32
			i32 End := ParseInteger(ArgV[2]) As i32
			
			for (i32 Index := Start, Index < End, Index++) {
				Print("FAT[%x] = %x\n", Index, Device->ReadFAT(Index))
			}
		}
		else if (StringEquals(Command, "info_calc")) {
			Print(" FirstFATSector      : %x\n", Device->FirstFATSector)
			Print(" FirstClusterSector  : %x\n", Device->FirstClusterSector)
			Print(" SectorsPerCluster   : %x\n", Device->SectorsPerCluster)
			Print(" RootDirectoryCluster: %x\n", Device->RootDirectoryCluster)
			Print(" ClusterCount        : %x\n", Device->ClusterCount)
		}
		else if (StringEquals(Command, "import") && ArgC = 3) {
			i8* Source := ArgV[1]
			i8* Destination := ArgV[2]
			
			i64 File := FileOpen(Source, FILE_READ)
			
			if (File < 0) {
				Print("Could not open real file '%s', error %i\n", Source, File)
				continue
			}
			
			i32 ImportSize := FileGetSize(File)
			void* ImportData := FileReadAll(File)
			
			i32 FirstCluster := Device->AllocateCluster()
			Device->MakeDirectoryEntry(CurrentDirectoryCluster, Destination, 0, ImportSize, FirstCluster)
			Device->WriteClusterData(FirstCluster, ImportData, ImportSize)
		}
		else {
			return
		}
	}
}

define i32 Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	i8* ProgramDirectory := GetAbsolutePath(Concatenate(ArgV[0], "/../"))
	SetWorkingDirectory(ProgramDirectory)
	
	i64 F := FileOpen(ArgV[1], FILE_READ_WRITE | FILE_CREATE_NEW)
	
	Print("FD = %x\n", F)
	
	FAT32Device* Device := Alloc(#FAT32Device)
	
	Device->Initialize(FAT32FileBackedDevice:New(F))
	
	Prompt(Device)
	
	return 0
}