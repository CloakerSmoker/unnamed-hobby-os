
i16 PS2_DATA := 0x60

i8 SHIFT_STATE := false

define i8 GetMapIndex(i8* Map, i32 Max, i16 Code) {
	if (Code >= Max) {
		return ' '
	}
	
	return Map[Code]
}

define i8 ScanCodeToASCII(i16 ScanCode) {
	/* Note: This doesn't need to work for all characters, since it is only used for displaying, not for logic. */
	
	i8* LowerMap := "  1234567890-=  qwertyuiop[]  asdfghjkl;'` \\zxcvbnm,./    "
	i8* UpperMap := "  !@#$%^&*()_+  QWERTYUIOP{}  ASDFGHJKL:\"~ |ZXCVBNM<>?"
	
	i32 LowerMapMax := 58
	i32 UpperMapMax := 54
	
	if (SHIFT_STATE) {
		return GetMapIndex(UpperMap, UpperMapMax, ScanCode)
	}
	else {
		return GetMapIndex(LowerMap, LowerMapMax, ScanCode)
	}
}

declare void KeyboardWait(i8, i8)

i8{0x200} InputBuffer
i32 InputIndex := 0

i32 SCANCODE_MASK_DOWN := 0x80
i32 SCANCODE_SHIFT_UP := 0xAA
i32 SCANCODE_SHIFT_DOWN := 0x2A
i32 SCANCODE_BACKSPACE_DOWN := 0x0E
i32 SCANCODE_ENTER_DOWN := 0x1C

i32 SCANCODE_UP_ARROW := 0x48
i32 SCANCODE_LEFT_ARROW := 0x4B
i32 SCANCODE_RIGHT_ARROW := 0x4D
i32 SCANCODE_DOWN_ARROW := 0x50

define void KeyboardEvent() {
	/* IRQ1 handler */
	
	KeyboardWait(0, 1)
	i16 ScanCode := InB(PS2_DATA) As i16
	i8 ASCIICode := ScanCodeToASCII(ScanCode)
	
	if (ScanCode & SCANCODE_MASK_DOWN) {
		if (ScanCode = SCANCODE_SHIFT_UP) {
			SHIFT_STATE := false
		}
	}
	else if (ScanCode = SCANCODE_SHIFT_DOWN) {
		SHIFT_STATE := true
	}
	else if (ScanCode = SCANCODE_BACKSPACE_DOWN) {
		if (Terminal->X > 0) {
			Terminal->X -= 1
		}
		
		Terminal->Print(" ")
		Terminal->X -= 1
		
		if (InputIndex > 0) {
			InputIndex -= 1
		}
	}
	else if (ScanCode = SCANCODE_ENTER_DOWN) {
		Terminal->NewLine()
		
		InputBuffer[InputIndex] := 0
		
		;Shell->OnCommand(InputBuffer)
	}
	else if (ScanCode = SCANCODE_UP_ARROW) {
		Screen->VerticalScroll(12)
		Terminal->OnScroll(1)
	}
	else if (ScanCode = SCANCODE_DOWN_ARROW) {
		Screen->VerticalScroll(-12)
		Terminal->OnScroll(-1)
	}
	else {
		Print("%c", ASCIICode)
		
		InputBuffer[InputIndex] := ASCIICode
		InputIndex += 1
	}
	
	SendEOI(1)
}

define void _KeyboardEvent() asm {
	call, @InterruptSetup	/* Saves all GPRs */
	call, @KeyboardEvent	/* Call the actual handler */
	jmp, @InterruptReturn	/* Pop all GPRs, iretq */
}

i8 KEYBOARD_DATA := 0x60
i8 KEYBOARD_COMMAND := 0x64
i8 KEYBOARD_STATUS := 0x64

i8 CONTROLLER_READ_COMMAND := 0x20
i8 CONTROLLER_WRITE_COMMAND := 0x60
i8 CONTROLLER_DISABLE_AUX := 0xA7 As i8
i8 CONTROLLER_ENABLE_AUX := 0xA8 As i8
i8 CONTROLLER_DISABLE := 0xAD As i8
i8 CONTROLLER_ENABLE := 0xAE As i8

define void KeyboardWait(i8 ForWrite, i8 TargetStatus) {
	/* Bit 0 = read status, bit 1 = write status */
	
	i8 Mask := (1 << ForWrite) As i8
	TargetStatus := (TargetStatus << ForWrite) As i8
	
	loop {
		i8 Status := InB(KEYBOARD_STATUS)
		
		if ((Status & Mask) = TargetStatus) {
			return
		}
	}
}

i16 KEYBOARD_WAIT_INPUT := 0x100

define i8 KeyboardSendCommand(i16 Command, ... Bytes) {
	KeyboardWait(1, 0)
	
	OutB(KEYBOARD_COMMAND, (Command & 0xFF) As i8)
	
	for (i32 Index := 1, Index <= Bytes[0], Index += 1) {
		KeyboardWait(1, 0)
		OutB(KEYBOARD_DATA, Bytes[Index] As i8)
	}
	
	if (Command > 0xFF) {
		KeyboardWait(0, 1)
		
		return InB(KEYBOARD_DATA)
	}
	
	return 0
}

define void SetupKeyboard() {
	/* Called with interrupts disabled, and before the IDT is loaded */
	
	KeyboardSendCommand(CONTROLLER_DISABLE)
	KeyboardSendCommand(CONTROLLER_DISABLE_AUX)
	
	InB(KEYBOARD_DATA) /* Flush input buffer */
	
	/* Enable interrupts for both PS/2 ports, enable first port translation(?) */
	i8 ConfigByte := KeyboardSendCommand(CONTROLLER_READ_COMMAND | KEYBOARD_WAIT_INPUT)
	ConfigByte := ConfigByte | 0x43
	KeyboardSendCommand(CONTROLLER_WRITE_COMMAND, ConfigByte)
	
	KeyboardSendCommand(CONTROLLER_ENABLE)
	KeyboardSendCommand(CONTROLLER_ENABLE_AUX)
	
	InsertIDTEntry(0x21, &_KeyboardEvent, true)
	EnablePICLine(1, true)
}
