
i32 PIXEL_COUNT := SCREEN_WIDTH * SCREEN_HEIGHT
i32 FRAMEBUFFER_SIZE := (PIXEL_COUNT + 1) * BYTES_PER_PIXEL
i32 ROW_SIZE := SCREEN_WIDTH * BYTES_PER_PIXEL

#Require "./src/kernel/graphics/PixelBuffer.rlx"

struct Screen {
	PixelBuffer RawCanvas
	PixelBuffer* Canvas
	i32 FillColor
	
	define void Adopt(void* RawFrameBuffer, PixelFormat* Format, i32 Width, i32 Height, i32 FillColor) {
		this->Canvas := this~>RawCanvas
		
		this->Canvas->Initialize(RawFrameBuffer, Format, Width, Height)
		this->FillColor := FillColor
	}
	
	define void DrawRectangle(i32 X, i32 Y, i32 Width, i32 Height, i32 Color) {	
		for (i32 RowIndex := 0, RowIndex < Height, RowIndex += 1) {
			for (i32 ColumnIndex := 0, ColumnIndex < Width, ColumnIndex += 1) {
				this->Canvas->SetPixelColor(X + ColumnIndex, Y + RowIndex, Color)
			}
		}
	}
	define void DrawCharacter(i32 X, i32 Y, i8 Character, i32 ForegroundColor, i32 BackgroundColor) {
		;BochsPrint("Print %x\n", Character)
		
		if (Character = ' ') {
			this->DrawRectangle(X, Y, 8, 12, BackgroundColor)
			return
		}
		
		Glyph* CharacterGlyph := Font + (Character - FIRST_CHARACTER) * #Glyph
		
		for (i32 RowIndex := 0, RowIndex < 12, RowIndex += 1) {
			i8 RowData := CharacterGlyph~>Rows[RowIndex]
			
			i8 ColumnIndex := 0
			
			for (i8 BitIndex := 7, BitIndex >= 0, BitIndex -= 1) {
				i8 Mask := (1 << BitIndex) As i8
				
				if (RowData & Mask) {
					this->Canvas->SetPixelColor(X + ColumnIndex, Y + RowIndex, ForegroundColor)
				}
				else {
					this->Canvas->SetPixelColor(X + ColumnIndex, Y + RowIndex, BackgroundColor)
				}
				
				ColumnIndex += 1
			}
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 TextLength, i32 ForegroundColor, i32 BackgroundColor) {
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			if (X + 8 >= this->Canvas->Width) {
				X := 0
				Y += 12
			}
			
			this->DrawCharacter(X, Y, Text[Index], ForegroundColor, BackgroundColor)
			
			X += 8
		}
	}
	define void DrawText(i32 X, i32 Y, i8* Text, i32 ForegroundColor, i32 BackgroundColor) {
		this->DrawText(X, Y, Text, StringLength(Text), ForegroundColor, BackgroundColor)
	}
	
	define void Clear(i32 Color) {
		this->DrawRectangle(0, 0, this->Canvas->Width, this->Canvas->Height, Color)
	}
	define void Clear() {
		this->Clear(this->FillColor)
	}
	
	define void VerticalScroll(i32 Offset) {
		i32 RowSize := this->Canvas->Width * this->Canvas->Format->Size
		void* Buffer := this->Canvas->Buffer
		
		i32 GapSize := Offset * RowSize
		
		void* TopRow := Buffer
		void* NewTopRow := TopRow + GapSize
		
		i32 Y := 0
		
		if (Offset < 0) {
			Offset := -Offset
			
			GapSize := Offset * RowSize
			
			NewTopRow := Buffer
			TopRow := NewTopRow + GapSize
			
			Y := this->Canvas->Height - Offset
		}
		
		FastMoveMemory(NewTopRow, TopRow, (Buffer As i64) - GapSize)
		this->DrawRectangle(0, Y, this->Canvas->Width, Offset, this->FillColor)
	}
}

Screen RawScreen
Screen* NativeScreen := &RawScreen