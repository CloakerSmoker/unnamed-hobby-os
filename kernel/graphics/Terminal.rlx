
#Require "./src/kernel/graphics/Screen.rlx"
#Require "./src/kernel/graphics/Font.rlx"

i32 ASCII_TAB  := 0x9
i32 ASCII_ESC  := 0x1B
i32 ASCII_BACK := 0x7F
i32 TAB_SIZE := 4

declare void ShellPleaseSendForMe(i8*, i32)

struct Terminal {
	Screen* Screen
	
	i32 X
	i32 Y
	
	i32 ForegroundColor
	i32 BackgroundColor
	
	i32 DefaultForegroundColor
	i32 DefaultBackgroundColor
	
	i8[20] EscapeBuffer
	i32 EscapeIndex
	
	Font* Font
	
	i32 Width
	i32 Height
	
	i32 MaxColumn
	i32 MaxRow
	
	define void Clear() {
		this->Screen->Clear(this->BackgroundColor)
	}
	
	define void CalculateBounds() {
		this->X := 0
		this->Y := 0
		
		this->Width  := this->Screen->Canvas->Width  / this->Font->Width
		this->Height := this->Screen->Canvas->Height / this->Font->Height
		this->MaxColumn := this->Width  - 1
		this->MaxRow    := this->Height - 1
		
		this->Clear()
	}
	
	define void Adopt(Screen* NewScreen, Font* NewFont, i32 Foreground, i32 Background) {
		this->Screen := NewScreen
		this->Font := NewFont
		
		this->DefaultForegroundColor := Foreground
		this->DefaultBackgroundColor := Background
		
		this->ForegroundColor := Foreground
		this->BackgroundColor := Background
		
		this->EscapeIndex := 0
		
		this->CalculateBounds()
	}
	
	define void SetColors(i32 ForegroundColor, i32 BackgroundColor) {
		this->ForegroundColor := ForegroundColor
		this->BackgroundColor := BackgroundColor
	}
	
	define void ConvertToScreenCoords(i32 XIn, i32 YIn, i32* XOut, i32* YOut) {
		*XOut := XIn * this->Font->Width
		*YOut := YIn * this->Font->Height
	}
	
	define void ScrollUp(i32 LineCount) {
		i32 ScrollSize := this->Font->Height * LineCount
		
		this->Y -= LineCount
		
		this->Screen->VerticalScroll(-ScrollSize)
	}
	
	define void NewLine() {
		this->Y += 1
		
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		if (this->Y >= this->Height) {
			this->ScrollUp(4)
		}
	}
	
	i8 CursorShown
	
	define void DrawCursor(i8 Enable) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		i32 Color := this->BackgroundColor
		
		if (Enable) {
			Color := this->ForegroundColor
		}
		
		;this->Font->Draw(this->Screen->Canvas, Color, this->BackgroundColor, ScreenX, ScreenY, '_')
		
		i32 Height := 1
		i32 Right  := 0
		i32 Width  := this->Font->Width - 0
		i32 Down   := this->Font->Height - 1
		
		this->Screen->DrawRectangle(ScreenX + Right, ScreenY + Down, Width, Height, Color)
		
		this->CursorShown := Enable
	}
	define void ShowCursor() {
		this->DrawCursor(true)
	}
	define void HideCursor() {
		this->DrawCursor(false)
	}
	
	i32 IgnoreCursorTicks
	
	define void ToggleCursor() {
		if (this->IgnoreCursorTicks) {
			this->IgnoreCursorTicks--
		}
		else {
			if (this->CursorShown) {
				this->HideCursor()
			}
			else {
				this->ShowCursor()
			}
		}
	}
	
	Timer* CursorTimer
	
	define void SetCursorTimer() {
		this->CursorTimer := SetTimer(500, &Terminal.ToggleCursor, this)
	}

	define i32 GetTabLength(i32 AtIndex) {
		return TAB_SIZE - (AtIndex % TAB_SIZE)
	}
	
	define void DoEscape() {
		Info("DoEscape ")
		
		for (i32 DumpIndex := 0, DumpIndex < this->EscapeIndex, DumpIndex++) {
			Info("%B ", this~>EscapeBuffer[DumpIndex] & 0xFF)
		}
		
		Info("\n")
		
		i8* Escape := this~>EscapeBuffer
		i32 Length := this->EscapeIndex
		
		if (Escape[1] != '[' || Length < 3) {
			return
		}
		
		i8 Command := Escape[--Length]
		
		Escape += 2
		Length -= 2
		
		i32 ParameterCount := 0
		i32 LastParameterStart := 0
		
		i8*[4] Parameters
		i32[4] ParameterLengths
		
		for (i32 Index := 0, Index < Length, Index++) {
			i8 Next := Escape[Index]
			
			if (Next = ';') {
				if (ParameterCount < 4) {
					ParameterLengths[ParameterCount] := Index - LastParameterStart - 1
					Parameters[ParameterCount++] := &Escape[LastParameterStart]
					
					LastParameterStart := Index + 1
				}
			}
		}
		
		if (LastParameterStart != Length && ParameterCount < 4) {
			ParameterLengths[ParameterCount] := Index - LastParameterStart
			Parameters[ParameterCount++] := &Escape[LastParameterStart]
		}
		
		if (Command = 'n' && Parameters[0][0] = '6') {
			i8[40] CursorPositionEscape
			
			i32 FormatLength := FormatString(CursorPositionEscape, 40, "^E%i;%iR", this->Y + 1, this->X + 1)
			
			Info("Formatted '%s' %x\n", CursorPositionEscape, FormatLength)
			
			ShellPleaseSendForMe(CursorPositionEscape, FormatLength)
		}
		else if (Command = 'm') {
			if (ParameterCount != 1) { return }
			
			i32 StyleLength := ParameterLengths[0]
			i8* StyleText := Parameters[0]
			
			;BochsPrint("'%s', len %i\n", StyleText, StyleLength)
			
			i32 Style := 0
			
			for (i32 StyleIndex := 0, StyleIndex < StyleLength, StyleIndex++) {
				Style *= 10
				Style += StyleText[StyleIndex] - '0'
			}
			
			;BochsPrint("Switch to style %i\n", Style)
			
			;                        Black     Red       Green     Yellow    Blue      Magenta   Cyan      Grey
			i32* DarkColors   := i32[0x000000, 0xAA0000, 0x00AA00, 0xFFC706, 0x00007F, 0x9C009C, 0x008080, 0xC0C0C0]
			i32* BrightColors := i32[0x808080, 0xFF0000, 0x00FF00, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FFFF, 0xFFFFFF]
			
			if (Style >= 30 && Style <= 37) {
				Style -= 30
				
				this->ForegroundColor := DarkColors[Style]
			}
			else if (Style >= 40 && Style <= 47) {
				Style -= 40
				
				this->BackgroundColor := DarkColors[Style]
			}
			else if (Style >= 90 && Style <= 97) {
				Style -= 90
				
				this->ForegroundColor := BrightColors[Style]
			}
			else if (Style >= 100 && Style <= 107) {
				Style -= 100
				
				this->BackgroundColor := BrightColors[Style]				
			}
			else if (Style = 0) {
				this->ForegroundColor := this->DefaultForegroundColor
				this->BackgroundColor := this->DefaultBackgroundColor
			}
		}
		else if (Command = 'c') {
			this->Clear()
		}
		else if (Command = 'S') {
			i32 ScrollDistance := 0
			
			if (ParameterCount != 0) {
				i32 ScrollDistanceLength := ParameterLengths[0]
				i8* ScrollDistanceText := Parameters[0]
			
				for (i32 ScrollDistanceIndex := 0, ScrollDistanceIndex < ScrollDistanceLength, ScrollDistanceIndex++) {
					ScrollDistance *= 10
					ScrollDistance += ScrollDistanceText[ScrollDistanceIndex] - '0'
				}
			}
			else {
				ScrollDistance := 1
			}
			
			this->ScrollUp(ScrollDistance)
		}
		else if ('A' <= Command && Command <= 'D') {
			i32 CursorDistance := 0
			
			if (ParameterCount != 0) {
				i32 CursorDistanceLength := ParameterLengths[0]
				i8* CursorDistanceText := Parameters[0]
			
				for (i32 CursorDistanceIndex := 0, CursorDistanceIndex < CursorDistanceLength, CursorDistanceIndex++) {
					CursorDistance *= 10
					CursorDistance += CursorDistanceText[CursorDistanceIndex] - '0'
				}
			}
			else {
				CursorDistance := 1
			}
			
			i32 NewX := this->X
			i32 NewY := this->Y
			
			if (Command = 'A' || Command = 'B') {
				if (Command = 'A') {
					NewY -= CursorDistance
				}
				else {
					NewY += CursorDistance
				}
			}
			else if (Command = 'C' || Command = 'D') {
				if (Command = 'C') {
					NewX += CursorDistance
				}
				else {
					NewX -= CursorDistance
				}
			}
			
			if (NewX <= 0) {
				this->X := 0
			}
			else if (NewX >= this->MaxColumn) {
				this->X := this->MaxColumn - 1
			}
			else {
				this->X := NewX
			}
			
			if (NewY <= 0) {
				this->Y := 0
			}
			else if (NewY >= this->MaxRow) {
				this->Y := this->MaxRow - 1
			}
			else {
				this->Y := NewY
			}
			
			;if      (Command = 'A' && this->Y != 0)              { this->Y -= 1 } ; Cursor Up
			;else if (Command = 'C' && this->X != 0)              { this->X -= 1 } ; Cursor Down
			;else if (Command = 'B' && this->Y < this->MaxRow)    { this->Y += 1 } ; Cursor Right
			;else if (Command = 'D' && this->X < this->MaxColumn) { this->X += 1 } ; Cursor Left
		}
		else if (Command = 'H') {
			if (ParameterCount >= 1) {
				this->X := AToI(Parameters[0]) As i32
				
				if (ParameterCount >= 2) {
					this->Y := AToI(Parameters[1]) As i32
				}
				else {
					this->Y := 0
				}
			}
			else {
				this->X := 0
				this->Y := 0
			}
		}
		else if (Command = 'J') {
			if (ParameterCount = 0) {
				this->Clear()
			}
		}
	}
	
	define i8 IsEscapeCharacter(i8 Character) {
		if ('0' <= Character && Character <= '9') {
			return true
		}
		else if (Character = '[') { return true }
		else if (Character = '-') { return true }
		else if (Character = ';') { return true }
		
		return false
	}
	
	define void RawPrintCharacter(i32* ScreenX, i32* ScreenY, i8 Character) {		
		;this->Screen->DrawCharacter(*ScreenX, *ScreenY, Character, this->ForegroundColor, this->BackgroundColor)
		this->Font->Draw(this->Screen->Canvas, this->ForegroundColor, this->BackgroundColor, *ScreenX, *ScreenY, Character)
		
		this->X += 1
		
		if (this->X >= this->Width) {
			this->NewLine()
			this->X := 0
		}
		
		this->ConvertToScreenCoords(this->X, this->Y, ScreenX, ScreenY)
	}
	
	define void PrintMarkedUpLine(i8* Line, i32 LineLength) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		for (i32 Index := 0, Index < LineLength, Index++) {
			i8 Next := Line[Index]
			
			if (Next = ASCII_TAB) {
				i32 TabLength := this->GetTabLength(this->X + Index)
				
				for (i32 TabIndex := 0, TabIndex < TabLength, TabIndex++) {
					this->RawPrintCharacter(&ScreenX, &ScreenY, ' ')
				}
			}
			else if (Next = ASCII_BACK) {
				if (this->X) {
					this->X -= 1
					
					this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
					this->Font->Draw(this->Screen->Canvas, this->ForegroundColor, this->BackgroundColor, ScreenX, ScreenY, ' ')
				}
			}
			else if (Next = ASCII_ESC) {
				this~>EscapeBuffer[0] := 0x1B
				this->EscapeIndex := 1
			}
			else if (this->EscapeIndex) {
				if (this->EscapeIndex = 1 && Next != '[') {
					this->EscapeIndex := 0
				}
				else {
					this~>EscapeBuffer[this->EscapeIndex++] := Next
					
					i8 NextIsEscape := this->IsEscapeCharacter(Next)
					
					if !(NextIsEscape) {
						this->DoEscape()
						this->EscapeIndex := 0
					}
				}
			}
			else {
				this->RawPrintCharacter(&ScreenX, &ScreenY, Line[Index])
			}
		}
	}
	
	define void Print(i8* Text, i32 TextLength) {
		if (this->CursorShown) {
			this->HideCursor()
		}
		
		this->IgnoreCursorTicks := -1
		
		i32 LastLineStart := 0
		
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			i8 NextCharacter := Text[Index]
			
			if (NextCharacter = 0x0A || NextCharacter = 0x0D) {
				if (NextCharacter = 0x0A) {
					this->NewLine()
					this->X := 0 ; TODO: Make this only apply when a dumb linux program is running
				}
				else if (NextCharacter = 0x0D) {
					this->X := 0
				}
				
				i32 LastLineLength := Index - LastLineStart
				
				if (LastLineLength) {
					this->PrintMarkedUpLine(&Text[LastLineStart], LastLineLength)
				}
				
				LastLineStart := Index + 1
			}
		}
		
		if (LastLineStart < TextLength) {
			this->PrintMarkedUpLine(&Text[LastLineStart], TextLength - LastLineStart)
		}
		
		this->IgnoreCursorTicks := 1
		
		this->ShowCursor()
	}
	
	define void Print(i8* Text) {
		this->Print(Text, StringLength(Text))
	}
	define void PrintLine(i8* Text) {
		this->Print(Text)
		this->Print("\n")
	}
	
	define void Seek(i32 X, i32 Y) {
		this->X := X
		this->Y := Y
	}
	
	define void OnScroll(i32 CharacterOffset) {
		this->Y += CharacterOffset
	}
}


Terminal RawKernelTerminal
Terminal* KernelTerminal := &RawKernelTerminal