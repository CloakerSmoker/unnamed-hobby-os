
#Require "./src/kernel/graphics/Screen.rlx"

i32 ASCII_TAB := 0x9
i32 TAB_SIZE := 4

struct Terminal {
	Screen* Screen
	
	i32 X
	i32 Y
	
	i32 ForegroundColor
	i32 BackgroundColor
	
	define void Adopt(Screen* NewScreen) {
		this->Screen := NewScreen
		this->ForegroundColor := 0x00_00_00
		this->BackgroundColor := 0xFF_FF_FF
		
		this->X := 0
		this->Y := 0
	}
	
	define void Clear() {
		this->Screen->Clear()
		this->X := 0
		this->Y := 0
	}
	
	define void SetColors(i32 ForegroundColor, i32 BackgroundColor) {
		this->ForegroundColor := ForegroundColor
		this->BackgroundColor := BackgroundColor
	}
	
	define void ConvertToScreenCoords(i32 XIn, i32 YIn, i32* XOut, i32* YOut) {
		XOut[0] := XIn * 8
		YOut[0] := YIn * 12
	}
	
	define void NewLine() {
		this->X := 0
		this->Y += 1
		
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		if (ScreenY > this->Screen->Height) {
			this->Clear()
		}
	}
	
	define void DrawCursor(i8 Enable) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		i32 Color := this->BackgroundColor
		
		if (Enable) {
			Color := this->ForegroundColor
		}
		
		this->Screen->DrawRectangle(ScreenX, ScreenY + 10, 8, 2, Color)
	}
	define void ShowCursor() {
		this->DrawCursor(true)
	}
	define void HideCursor() {
		this->DrawCursor(false)
	}
	
	define i32 MeasureText(i32 StartDisplayIndex, i8* Text, i32 TextLength) {
		i32 DisplayIndex := StartDisplayIndex
		
		for (i32 Index := 0, Index < TextLength, Index++) {
			i8 Next := Text[Index]
			
			if (Next = ASCII_TAB) {
				i32 NextAlignmentPointOffset := TAB_SIZE - (DisplayIndex % TAB_SIZE)
				
				DisplayIndex += NextAlignmentPointOffset
			}
			else {
				DisplayIndex++
			}
		}
		
		return DisplayIndex - StartDisplayIndex
	}
	define i32 GetTabLength(i32 AtIndex) {
		return TAB_SIZE - (AtIndex % TAB_SIZE)
	}
	
	define void RawPrintCharacter(i32* ScreenX, i32* ScreenY, i8 Character) {
		this->Screen->DrawCharacter(*ScreenX, *ScreenY, Character, this->ForegroundColor, this->BackgroundColor)
		*ScreenX += FONT_WIDTH
	}
	
	define void RawPrintLine(i8* Line, i32 LineLength) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		for (i32 Index := 0, Index < LineLength, Index++) {
			i8 Next := Line[Index]
			
			if (Next = ASCII_TAB) {
				i32 TabLength := this->GetTabLength(this->X + Index)
				
				for (i32 TabIndex := 0, TabIndex < TabLength, TabIndex++) {
					this->RawPrintCharacter(&ScreenX, &ScreenY, ' ')
				}
			}
			else {
				this->RawPrintCharacter(&ScreenX, &ScreenY, Next)
			}
		}
		
		this->X += this->MeasureText(this->X, Line, LineLength)
	}
	
	define void PrintWrappedLine(i8* Line, i32 LineLength) {
		this->RawPrintLine(Line, LineLength)
	}
	
	define void Print(i8* Text, i32 TextLength) {
		;this->HideCursor()
		
		i32 LastLineStart := 0
		
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			i8 NextCharacter := Text[Index]
			
			if (NextCharacter = 0x0A || NextCharacter = 0x0D) {
				if (NextCharacter = 0x0A) {
					this->Y += 1
				}
				else if (NextCharacter = 0x0D) {
					this->X := 0
				}
				
				i32 LastLineLength := Index - LastLineStart
				
				if (LastLineLength) {
					this->PrintWrappedLine(&Text[LastLineStart], LastLineLength)
				}
				
				LastLineStart := Index + 1
			}
		}
		
		if (LastLineStart < TextLength) {
			this->PrintWrappedLine(&Text[LastLineStart], TextLength - LastLineStart)
		}
	}
	
	;define void PrintSingleLine(i8* Text, i32 TextLength) {
	;	i32 ScreenX := 0
	;	i32 ScreenY := 0
	;	
	;	this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
	;	
	;	i32 PixelsLeft := this->Screen->Width - ScreenX
	;	i32 CharactersLeft := PixelsLeft / FONT_WIDTH
	;	
	;	i32 TextDisplayLength := this->MeasureText(this->X, Text, TextLength)
	;	
	;	while (TextDisplayLength > CharactersLeft) {
	;		i32 DisplayIndex := this->X
	;		
	;		for (i32 Index := 0, Index < CharactersLeft, Index++) {
	;			i8 Next := Text[Index]
	;			
	;			if (Next = ASCII_TAB) {
	;				i32 TabLength := this->GetTabLength(DisplayIndex + Index)
	;				
	;				for (i32 Tab := 0, Tab < TabLength, Tab++) {
	;					Print(" ")
	;				}
	;			}
	;			
	;		}
	;		
	;		
	;		
	;		this->Screen->DrawText(ScreenX, ScreenY, Text, CharactersLeft, this->ForegroundColor, this->BackgroundColor)
	;		
	;		Text += CharactersLeft
	;		TextLength -= CharactersLeft
	;		
	;		TextDisplayLength := this->MeasureText(this->X, Text, TextLength)
	;		
	;		this->NewLine()
	;		
	;		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
	;		
	;		PixelsLeft := this->Screen->Width - ScreenX
	;		CharactersLeft := PixelsLeft / FONT_WIDTH
	;	}
	;	
	;	if (TextDisplayLength) {
	;		this->Screen->DrawText(ScreenX, ScreenY, Text, TextLength, this->ForegroundColor, this->BackgroundColor)
	;	}
	;	
	;	i32 NewX := this->X + TextDisplayLength
	;	
	;	this->Y += NewX / this->Screen->Width
	;	this->X := NewX % this->Screen->Width
	;}
	;
	;define void Print(i8* Text, i32 TextLength) {
	;	;this->HideCursor()
	;	
	;	i32 LastLineStart := 0
	;	
	;	for (i32 Index := 0, Index < TextLength, Index += 1) {
	;		i8 NextCharacter := Text[Index]
	;		
	;		if (NextCharacter = 0x0A || NextCharacter = 0x0D) {
	;			if (NextCharacter = 0x0A) {
	;				this->Y += 1
	;			}
	;			else if (NextCharacter = 0x0D) {
	;				this->X := 0
	;			}
	;			
	;			i32 LastLineLength := Index - LastLineStart
	;			
	;			if (LastLineLength) {
	;				this->RawPrint(&Text[LastLineStart], LastLineLength)
	;			}
	;			
	;			LastLineStart := Index + 1
	;		}
	;	}
	;	
	;	if (LastLineStart < TextLength) {
	;		this->RawPrint(&Text[LastLineStart], TextLength - LastLineStart)
	;	}
	;}
	define void Print(i8* Text) {
		this->Print(Text, StringLength(Text))
	}
	define void PrintLine(i8* Text) {
		this->Print(Text)
		this->NewLine()
	}
	
	define void Seek(i32 X, i32 Y) {
		this->X := X
		this->Y := Y
	}
	
	define void OnScroll(i32 CharacterOffset) {
		this->Y += CharacterOffset
	}
}

Terminal RawTerminal {Screen: null}
Terminal* Terminal

define void PrintNewLine() {
	Terminal->NewLine()
}
define void PrintCharacters(i8* Characters, i32 Count) {
	for (i32 Index := 0, Index < Count, Index += 1) {
		BochsPrintCharacter(Characters[Index])
	}
	
	Terminal->Print(Characters, Count)
}

define void PrintLiteral(i64 PackedCharacters) {
	i8* Characters := (&PackedCharacters) As i8*
	
	for (i32 Length := 0, (Length < 8) && (Characters[Length] != 0), Length += 1) {}
	
	PrintCharacters(Characters, Length)
}
define void PrintCharacter(i8 Character) {
	PrintCharacters(&Character, 1)
}

i8{96} PrintBuffer

define void PrintString(i8* AString) {
	PrintCharacters(AString, StringLength(AString))
}

define void ClearPrintBuffer() {
	for (i32 Index := 0, Index < 12, Index += 1) {
		(PrintBuffer As i64*)[Index] := 0
	}
}
define void Print(i64 Number) {
	ClearPrintBuffer()
	IToA(Number, 10, PrintBuffer)
	PrintString(PrintBuffer)
}
define void PrintHex(i64 Number, i8 WithZeroX) {
	ClearPrintBuffer()
	IToA(Number, 16, PrintBuffer, WithZeroX)
	PrintString(PrintBuffer)
}
define void PrintHex(i64 Number) {
	PrintHex(Number, true)
}
define void PrintBinary(i64 Number) {
	ClearPrintBuffer()
	IToA(Number, 2, PrintBuffer)
	PrintString(PrintBuffer)
}

define void Print(i8* Format, ... Args) {
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				Print(NextArg As i64)
			}
			else if (Next = 'x') {
				PrintHex(NextArg As i64)
			}
			else if (Next = 'c') {
				PrintCharacter(NextArg As i8)
			}
			else if (Next = 's') {
				PrintString(NextArg As i8*)
			}
			else if (Next = 'l') {
				PrintLiteral(NextArg As i64)
			}
			else if (Next = 'b') {
				PrintBinary(NextArg As i64)
			}
			
			ArgIndex += 1
		}
		else {
			PrintCharacter(Next)
		}
	}
}

i8{0x200} FormatBuffer

define i8* FormatString(i8* Format, ... Args) {
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	i8* Buffer := FormatBuffer
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				Buffer := IToA(NextArg As i64, 10, Buffer)
			}
			else if (Next = 'x') {
				Buffer := IToA(NextArg As i64, 16, Buffer)
			}
			else if (Next = 'c') {
				*Buffer := NextArg As i8
				Buffer += 1
			}
			else if (Next = 's') {
				i8* NextArgString := NextArg As i8*
				i32 NextArgStringLength := StringLength(NextArgString)
				
				MoveMemory(Buffer, NextArgString, NextArgStringLength)
				
				Buffer += NextArgStringLength
			}
			
			ArgIndex += 1
		}
		else {
			*Buffer := Next
			Buffer += 1
		}
	}
	
	*Buffer := 0
	
	return FormatBuffer
}