
#Require "./src/kernel/graphics/Screen.rlx"

i32 ASCII_TAB := 0x9
i32 TAB_SIZE := 4

struct Terminal {
	Screen* Screen
	
	i32 X
	i32 Y
	
	i32 ForegroundColor
	i32 BackgroundColor
	
	i32 DefaultForegroundColor
	i32 DefaultBackgroundColor
	
	i8[20] EscapeBuffer
	i32 EscapeIndex
	
	define void Clear() {
		this->Screen->Clear()
		this->X := 0
		this->Y := 0
	}
	
	define void Adopt(Screen* NewScreen, i32 Foreground, i32 Background) {
		this->Screen := NewScreen
		
		this->DefaultForegroundColor := Foreground
		this->DefaultBackgroundColor := Background
		
		this->ForegroundColor := Foreground
		this->BackgroundColor := Background
		
		this->X := 0
		this->Y := 0
		
		this->EscapeIndex := 0
	}
	
	define void SetColors(i32 ForegroundColor, i32 BackgroundColor) {
		this->ForegroundColor := ForegroundColor
		this->BackgroundColor := BackgroundColor
	}
	
	define void ConvertToScreenCoords(i32 XIn, i32 YIn, i32* XOut, i32* YOut) {
		*XOut := XIn * 8
		*YOut := YIn * 12
	}
	
	define void NewLine() {
		this->X := 0
		this->Y += 1
		
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		if (ScreenY > this->Screen->Height) {
			this->Clear()
		}
	}
	
	define void DrawCursor(i8 Enable) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		i32 Color := this->BackgroundColor
		
		if (Enable) {
			Color := this->ForegroundColor
		}
		
		this->Screen->DrawRectangle(ScreenX, ScreenY + 10, 8, 2, Color)
	}
	define void ShowCursor() {
		this->DrawCursor(true)
	}
	define void HideCursor() {
		this->DrawCursor(false)
	}
	
	define i32 MeasureText(i32 StartDisplayIndex, i8* Text, i32 TextLength) {
		i32 DisplayIndex := StartDisplayIndex
		
		for (i32 Index := 0, Index < TextLength, Index++) {
			i8 Next := Text[Index]
			
			if (Next = ASCII_TAB) {
				i32 NextAlignmentPointOffset := TAB_SIZE - (DisplayIndex % TAB_SIZE)
				
				DisplayIndex += NextAlignmentPointOffset
			}
			else {
				DisplayIndex++
			}
		}
		
		return DisplayIndex - StartDisplayIndex
	}
	define i32 GetTabLength(i32 AtIndex) {
		return TAB_SIZE - (AtIndex % TAB_SIZE)
	}
	
	define void RawPrintCharacter(i32* ScreenX, i32* ScreenY, i8 Character) {
		this->Screen->DrawCharacter(*ScreenX, *ScreenY, Character, this->ForegroundColor, this->BackgroundColor)
		*ScreenX += FONT_WIDTH
	}
	
	define void RawPrintLine(i8* Line, i32 LineLength) {
		i32 ScreenX := 0
		i32 ScreenY := 0
		
		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
		
		for (i32 Index := 0, Index < LineLength, Index++) {
			i8 Next := Line[Index]
			
			if (Next = ASCII_TAB) {
				i32 TabLength := this->GetTabLength(this->X + Index)
				
				for (i32 TabIndex := 0, TabIndex < TabLength, TabIndex++) {
					this->RawPrintCharacter(&ScreenX, &ScreenY, ' ')
				}
			}
			else {
				this->RawPrintCharacter(&ScreenX, &ScreenY, Next)
			}
		}
		
		this->X += this->MeasureText(this->X, Line, LineLength)
	}
	
	define void PrintWrappedLine(i8* Line, i32 LineLength) {
		this->RawPrintLine(Line, LineLength)
	}
	
	define void DoEscape() {
		BochsPrint("DoEscape '%s', ", this~>EscapeBuffer)
		
		for (i32 DumpIndex := 0, DumpIndex < this->EscapeIndex, DumpIndex++) {
			BochsPrint("%x ", this~>EscapeBuffer[DumpIndex] & 0xFF)
		}
		
		BochsPrint("\n")
		
		i8* Escape := this~>EscapeBuffer
		i32 Length := this->EscapeIndex
		
		if (Escape[1] != '[' || Length < 3) {
			return
		}
		
		i8 Command := Escape[--Length]
		
		Escape += 2
		Length -= 2
		
		i32 ParameterCount := 0
		i32 LastParameterStart := 0
		
		i8*[4] Parameters
		i32[4] ParameterLengths
		
		for (i32 Index := 0, Index < Length, Index++) {
			i8 Next := Escape[Index]
			
			if (Next = ';') {
				if (ParameterCount < 4) {
					ParameterLengths[ParameterCount] := Index - LastParameterStart - 1
					Parameters[ParameterCount++] := &Escape[LastParameterStart]
					
					LastParameterStart := Index + 1
				}
			}
		}
		
		if (LastParameterStart != Length && ParameterCount < 4) {
			ParameterLengths[ParameterCount] := Index - LastParameterStart
			Parameters[ParameterCount++] := &Escape[LastParameterStart]
		}
		
		if (Command = 'm') {
			if (ParameterCount != 1) { return }
			
			i32 StyleLength := ParameterLengths[0]
			i8* StyleText := Parameters[0]
			
			;BochsPrint("'%s', len %i\n", StyleText, StyleLength)
			
			i32 Style := 0
			
			for (i32 StyleIndex := 0, StyleIndex < StyleLength, StyleIndex++) {
				Style *= 10
				Style += StyleText[StyleIndex] - '0'
			}
			
			;BochsPrint("Switch to style %i\n", Style)
			
			;                        Black     Red       Green     Yellow    Blue      Magenta   Cyan      Grey
			i32* DarkColors   := i32[0x000000, 0xAA0000, 0x00AA00, 0xFFC706, 0x00007F, 0x9C009C, 0x008080, 0xC0C0C0]
			i32* BrightColors := i32[0x808080, 0xFF0000, 0x00FF00, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FFFF, 0xFFFFFF]
			
			if (Style >= 30 && Style <= 37) {
				Style -= 30
				
				this->ForegroundColor := DarkColors[Style]
			}
			else if (Style >= 40 && Style <= 47) {
				Style -= 40
				
				this->BackgroundColor := DarkColors[Style]
			}
			else if (Style >= 90 && Style <= 97) {
				Style -= 90
				
				this->ForegroundColor := BrightColors[Style]
			}
			else if (Style >= 100 && Style <= 107) {
				Style -= 100
				
				this->BackgroundColor := BrightColors[Style]				
			}
			else if (Style = 0) {
				this->ForegroundColor := this->DefaultForegroundColor
				this->BackgroundColor := this->DefaultBackgroundColor
			}
		}
		else if (Command = 'c') {
			this->Clear()
		}
	}
	
	define i8 IsEscapeCharacter(i8 Character) {
		if ('0' <= Character && Character <= '9') {
			return true
		}
		else if (Character = '[') { return true }
		else if (Character = '-') { return true }
		else if (Character = ';') { return true }
		
		return false
	}
	
	define void PrintMarkedUpLine(i8* Line, i32 LineLength) {
		i32 LineMaxIndex := LineLength - 1
		
		for (i32 Index := 0, Index < LineLength, Index++) {
			i8 Next := Line[Index]
			
			if (Next = 0x1B) {
				this~>EscapeBuffer[0] := 0x1B
				this->EscapeIndex := 1
			}
			else if (Next = 0x7F) {
				if (this->X) {
					this->X -= 1
					
					i32 ScreenX := 0
					i32 ScreenY := 0
					
					this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
					this->Screen->DrawCharacter(ScreenX, ScreenY, ' ', this->ForegroundColor, this->BackgroundColor)
				}
			}
			else if (this->EscapeIndex) {
				if (this->EscapeIndex = 1 && Next != '[') {
					this->EscapeIndex := 0
				}
				else {
					this~>EscapeBuffer[this->EscapeIndex++] := Next
					
					i8 NextIsEscape := this->IsEscapeCharacter(Next)
					
					if !(NextIsEscape) {
						this->DoEscape()
						this->EscapeIndex := 0
					}
				}
			}
			else {
				this->RawPrintLine(&Line[Index], 1)
			}
		}
		
		
	}
	
	define void Print(i8* Text, i32 TextLength) {
		;this->HideCursor()
		
		i32 LastLineStart := 0
		
		for (i32 Index := 0, Index < TextLength, Index += 1) {
			i8 NextCharacter := Text[Index]
			
			if (NextCharacter = 0x0A || NextCharacter = 0x0D) {
				if (NextCharacter = 0x0A) {
					this->Y += 1
				}
				else if (NextCharacter = 0x0D) {
					this->X := 0
				}
				
				i32 LastLineLength := Index - LastLineStart
				
				if (LastLineLength) {
					this->PrintMarkedUpLine(&Text[LastLineStart], LastLineLength)
				}
				
				LastLineStart := Index + 1
			}
		}
		
		if (LastLineStart < TextLength) {
			this->PrintMarkedUpLine(&Text[LastLineStart], TextLength - LastLineStart)
		}
	}
	
	;define void PrintSingleLine(i8* Text, i32 TextLength) {
	;	i32 ScreenX := 0
	;	i32 ScreenY := 0
	;	
	;	this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
	;	
	;	i32 PixelsLeft := this->Screen->Width - ScreenX
	;	i32 CharactersLeft := PixelsLeft / FONT_WIDTH
	;	
	;	i32 TextDisplayLength := this->MeasureText(this->X, Text, TextLength)
	;	
	;	while (TextDisplayLength > CharactersLeft) {
	;		i32 DisplayIndex := this->X
	;		
	;		for (i32 Index := 0, Index < CharactersLeft, Index++) {
	;			i8 Next := Text[Index]
	;			
	;			if (Next = ASCII_TAB) {
	;				i32 TabLength := this->GetTabLength(DisplayIndex + Index)
	;				
	;				for (i32 Tab := 0, Tab < TabLength, Tab++) {
	;					Print(" ")
	;				}
	;			}
	;			
	;		}
	;		
	;		
	;		
	;		this->Screen->DrawText(ScreenX, ScreenY, Text, CharactersLeft, this->ForegroundColor, this->BackgroundColor)
	;		
	;		Text += CharactersLeft
	;		TextLength -= CharactersLeft
	;		
	;		TextDisplayLength := this->MeasureText(this->X, Text, TextLength)
	;		
	;		this->NewLine()
	;		
	;		this->ConvertToScreenCoords(this->X, this->Y, &ScreenX, &ScreenY)
	;		
	;		PixelsLeft := this->Screen->Width - ScreenX
	;		CharactersLeft := PixelsLeft / FONT_WIDTH
	;	}
	;	
	;	if (TextDisplayLength) {
	;		this->Screen->DrawText(ScreenX, ScreenY, Text, TextLength, this->ForegroundColor, this->BackgroundColor)
	;	}
	;	
	;	i32 NewX := this->X + TextDisplayLength
	;	
	;	this->Y += NewX / this->Screen->Width
	;	this->X := NewX % this->Screen->Width
	;}
	;
	;define void Print(i8* Text, i32 TextLength) {
	;	;this->HideCursor()
	;	
	;	i32 LastLineStart := 0
	;	
	;	for (i32 Index := 0, Index < TextLength, Index += 1) {
	;		i8 NextCharacter := Text[Index]
	;		
	;		if (NextCharacter = 0x0A || NextCharacter = 0x0D) {
	;			if (NextCharacter = 0x0A) {
	;				this->Y += 1
	;			}
	;			else if (NextCharacter = 0x0D) {
	;				this->X := 0
	;			}
	;			
	;			i32 LastLineLength := Index - LastLineStart
	;			
	;			if (LastLineLength) {
	;				this->RawPrint(&Text[LastLineStart], LastLineLength)
	;			}
	;			
	;			LastLineStart := Index + 1
	;		}
	;	}
	;	
	;	if (LastLineStart < TextLength) {
	;		this->RawPrint(&Text[LastLineStart], TextLength - LastLineStart)
	;	}
	;}
	define void Print(i8* Text) {
		this->Print(Text, StringLength(Text))
	}
	define void PrintLine(i8* Text) {
		this->Print(Text)
		this->NewLine()
	}
	
	define void Seek(i32 X, i32 Y) {
		this->X := X
		this->Y := Y
	}
	
	define void OnScroll(i32 CharacterOffset) {
		this->Y += CharacterOffset
	}
}

Terminal* KernelTerminal := null

define void PrintNewLine() {
	KernelTerminal->NewLine()
}
define void PrintCharacters(i8* Characters, i32 Count) {
	KernelTerminal->Print(Characters, Count)
}

define void PrintLiteral(i64 PackedCharacters) {
	i8* Characters := (&PackedCharacters) As i8*
	
	for (i32 Length := 0, (Length < 8) && (Characters[Length] != 0), Length += 1) {}
	
	PrintCharacters(Characters, Length)
}
define void PrintCharacter(i8 Character) {
	PrintCharacters(&Character, 1)
}

i8[96] PrintBuffer

define void PrintString(i8* AString) {
	PrintCharacters(AString, StringLength(AString))
}

define void ClearPrintBuffer() {
	for (i32 Index := 0, Index < 12, Index += 1) {
		(PrintBuffer As i64*)[Index] := 0
	}
}
define void Print(i64 Number) {
	ClearPrintBuffer()
	IToA(Number, 10, PrintBuffer)
	PrintString(PrintBuffer)
}
define void PrintHex(i64 Number, i8 WithZeroX) {
	ClearPrintBuffer()
	IToA(Number, 16, PrintBuffer, WithZeroX)
	PrintString(PrintBuffer)
}
define void PrintHex(i64 Number) {
	PrintHex(Number, true)
}
define void PrintBinary(i64 Number) {
	ClearPrintBuffer()
	IToA(Number, 2, PrintBuffer)
	PrintString(PrintBuffer)
}

i8 Black  := 0x00
i8 Red    := 0x01
i8 Green  := 0x02
i8 Blue   := 0x04
i8 Bright := 0x08
i8 White  := 0x0F

define i8 TranslateColor(i8 Color) {
	if (Color & Bright) {
		Color &= ~Bright
		
		return (Color + 90) As i8
	}
	else {
		return (Color + 30) As i8
	}
}

i8* ESC := i8[0x1B, '[', 0]

define void SetColor(i8 Foreground, i8 Background) {
	/* Writes a pair of ANSI escape sequences to change the terminal colors to Foreground/Background */
	
	PrintCharacter(0x1B)
	PrintCharacter('[')
	Print(TranslateColor(Foreground))
	PrintCharacter('m')
	
	PrintCharacter(0x1B)
	PrintCharacter('[')
	Print(TranslateColor(Background) + 10)
	PrintCharacter('m')
}

define void Print(i8* Format, ... Args) {
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				Print(NextArg As i64)
			}
			else if (Next = 'x') {
				PrintHex(NextArg As i64)
			}
			else if (Next = 'c') {
				PrintCharacter(NextArg As i8)
			}
			else if (Next = 's') {
				PrintString(NextArg As i8*)
			}
			else if (Next = 'l') {
				PrintLiteral(NextArg As i64)
			}
			else if (Next = 'b') {
				PrintBinary(NextArg As i64)
			}
			
			ArgIndex += 1
		}
		else if (Next = '^') {
			i8 First := Format[++Index]
			
			if (First = 'R') {
				Print(ESC)
				PrintLiteral('0m')
			}
			else if (First = 'S') {
				i8 Fore := GetCharacterValue(Format[++Index])
				
				Print("%s%im", ESC, TranslateColor(Fore))
			}
			else if (First = 'H') {
				i8 Back := GetCharacterValue(Format[++Index])
				
				Print("%s%im", ESC, TranslateColor(Back) + 10)
			}
			else {
				Fore := GetCharacterValue(First)
				Back := GetCharacterValue(Format[++Index])
				
				;BochsPrint("Fore %x, Back %x (%x) (format %s)\n", Fore, Back, Format[Index], Format)
				
				Print("%s%im", ESC, TranslateColor(Fore))
				Print("%s%im", ESC, TranslateColor(Back) + 10)
			}
		}
		else {
			PrintCharacter(Next)
		}
	}
}

i8[0x200] FormatBuffer

define i8* FormatString(i8* Format, ... Args) {
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	i8* Buffer := FormatBuffer
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				Buffer := IToA(NextArg As i64, 10, Buffer)
			}
			else if (Next = 'x') {
				Buffer := IToA(NextArg As i64, 16, Buffer)
			}
			else if (Next = 'c') {
				*Buffer := NextArg As i8
				Buffer += 1
			}
			else if (Next = 's') {
				i8* NextArgString := NextArg As i8*
				i32 NextArgStringLength := StringLength(NextArgString)
				
				MoveMemory(Buffer, NextArgString, NextArgStringLength)
				
				Buffer += NextArgStringLength
			}
			
			ArgIndex += 1
		}
		else {
			*Buffer := Next
			Buffer += 1
		}
	}
	
	*Buffer := 0
	
	return FormatBuffer
}