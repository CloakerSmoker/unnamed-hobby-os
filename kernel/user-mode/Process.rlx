#Require "./src/utility/ELF.rlx"
#Require "./src/kernel/core/MemoryMapping.rlx"
#Require "./src/linux/Signals.rlx"

declare void HandleSystemCall(AMD64Context*)

UserThread* CurrentThread := null

struct UserThread {
	Task* UserTask ; Just holds state
	Task* KernelTask ; Actually scheduled
	
	i8 HasPendingSystemCall
	
	define void DoKernelThread() {
		AMD64Context BeforeSystemCallCheck
		
		; Since this thread "manually" yeilds to the user-mode task, we need to do a bit
		;  of a dance to make sure that control ends up in the right place when this thread
		;   is interrupted and resumed
		
		; Each time this thread resumes, we need to do a few things:
		;  1) Handle system calls
		;  2) Dispatch signals (TODO)
		; and finally
		;  3) Resume the user task
		
		; We can get interrupted during 1/2 which will save our context, but once we reach
		;  3 there's nothing left to save our context, making a bit of a problem.
		
		; We need to persist any interrupted state during 1/2, but need to reset state back
		;  to the top of this function before 3 (otherwise the next time we're resumed, then
		;   we'd actually end up resuming previous code which was already interrupted and
		;    likely finished executing)
		
		; This is accomplished by only saving the "top of function" state into the actual
		;  task once steps 1/2 are completely done and we know that any state in our task
		;   is just garbage.
		
	
		SaveContext(&BeforeSystemCallCheck)
		
		if (this->HasPendingSystemCall) {
			Info("Handling system call\n")
			EnableInterrupts()
			HandleSystemCall(this->UserTask~>Context)
			DisableInterrupts()
			Info("Handled system call\n")
			
			this->HasPendingSystemCall := false
		}
		
		MoveMemory(this->KernelTask~>Context, &BeforeSystemCallCheck, #AMD64Context)
		
		CurrentThread := this
		
		Scheduler->RunNow(this->UserTask)
	}
	
	define void Start(void* Stack, void* Code) {
		this->UserTask~>Context->RSP := Stack
		this->UserTask~>Context->RIP := Code
		this->UserTask->NeedsUserMode := true
		
		this->KernelTask~>Context->RIP := &UserThread.DoKernelThread
		this->KernelTask~>Context->RDI := this As i64
		this->KernelTask~>Context->Flags := 0
		
		Scheduler->Enqueue(this->KernelTask)
	}
	
	define void FireSystemCall() {
		this->HasPendingSystemCall := true
		
		Scheduler->RunNow(this->KernelTask)
	}
}

struct Process {
	i64[10] FileDescriptorsToHandles
	i32 FileDescriptorCount
	
	ELFHeader* ELF
	MemoryMappingGroup* Mappings
	PageHeap* PageAllocator
	
	void* BreakStart
	i64 BreakPages
	
	UserThread MainThread
	
	Event OnKilled
	
	i32 ExitCode
	
	define void Initialize(ELFHeader* Header, MemoryMappingGroup* Mappings) {
		this->ELF := Header
		this->Mappings := Mappings
		
		i64 MaxAddress := 0
	
		ELFProgramHeader* ProgramHeaders := Header->GetProgramHeaders()

		for (i32 Index := 0, Index < Header->ProgramHeaderEntryCount, Index++) {
			ELFProgramHeader* NextProgramHeader := ProgramHeaders[Index]
			
			if (NextProgramHeader->Type = ELF_SEGMENT_TYPE_LOAD) {
				i64 NextEnd := NextProgramHeader->VirtualAddress + NextProgramHeader->MemorySize
				
				if (NextEnd > MaxAddress) {
					MaxAddress := NextEnd
				}
			}
		}
		
		this->BreakStart := ((MaxAddress + PAGE_SIZE) & 0x7FFF_FFFF_FFFF_F000) As void*
		this->BreakPages := 0
		
		this~>MainThread->UserTask   := Task:New(0)
		this~>MainThread->KernelTask := Task:NewWithStack(0, 1)
	}
	
	define void* GetBreak() {
		return this->BreakStart + (this->BreakPages * PAGE_SIZE)
	}
	define void* SetBreak(void* NewBreakEnd) {
		i32 AdditionalBreakPages := ((NewBreakEnd - this->GetBreak()) As i32) / PAGE_SIZE
		
		void* FirstNewBreakPage := this->GetBreak()
		
		this->Mappings->AllocateAddress(FirstNewBreakPage, AdditionalBreakPages, PAGE_USER | PAGE_WRITE)
		
		SetMemory(FirstNewBreakPage, AdditionalBreakPages * PAGE_SIZE, 0)
		
		this->BreakPages += AdditionalBreakPages
		
		return this->GetBreak()
	}
	
	define void Exit(i32 Code) {
		this->ExitCode := Code
		this~>OnKilled->Fire(Code As void*)
		
		DisableInterrupts()
		SchedulerEnd()
		
		;KernelHeap->Free(CurrentProcess)
		;Mappings->Delete()
	}
	
	LinuxSignalAction[31] Actions
	
	i32[31] PendingErrorNumbers
	i32[31] PendingSignalCodes
	
	i64 SignalMask
	i64 PendingSignals
	
	i32 CurrentSignal
	LinuxSignalAction* CurrentSignalAction
	LinuxSignalInfo* CurrentSignalInfo
	LinuxSignalUserContext* CurrentSignalContext
	
	define i64 SignalMask(i32 Number) {
		return (1 As i64) << ((Number & 0xFF) As i8)
	}
	
	define void DoDefaultSignalAction(i32 Number, i32 ErrorNumber, i32 SignalCode) {
		this->Exit(Number)
	}
	
	define void FireSignal(i32 Number, i32 ErrorNumber, i32 SignalCode) {
		i64 Mask := this->SignalMask(Number)
		
		if (this->SignalMask & Mask) {
			return
		}
		else if (this->PendingSignals & Mask) {
			return
		}
		
		i64 OldMask := this->SignalMask
		
		LinuxSignalAction* Action := this->Actions[Number]
		
		if (Action->Handler = LINUX_SIGNAL_HANDLER_DEFAULT) {
			this->DoDefaultSignalAction(Number, ErrorNumber, SignalCode)
			
			return
		}
		else if (Action->Handler = LINUX_SIGNAL_HANDLER_IGNORE) {
			return
		}
		
		this->SignalMask |= Mask
		this->SignalMask |= Action->Mask
		
		AMD64Context* Context := this~>MainThread->UserTask~>Context
		
		void* OriginalRSP := Context->RSP
		
		LinuxSignalInfo* Info := Context->StackAllocate(#LinuxSignalInfo)
		
		Info->SignalNumber := Number
		Info->ErrorNumber := ErrorNumber
		Info->SignalCode := SignalCode
		
		LinuxSignalUserContext* UserContext := Context->StackAllocate(#LinuxSignalUserContext)
		
		LinuxSignalRegisters* Registers := UserContext~>Registers
		LinuxSignalStack* Stack := UserContext~>Stack
		
		Registers->PopulateFromContext(Context)
		Registers->RSP := OriginalRSP
		
		UserContext->Mask := OldMask
		
		if (Action->Flags & LINUX_SIGNAL_ATTRIBUTE_RESTORER) {
			Context->Push(Action->Restorer As i64)
		}
		
		this->CurrentSignal := Number
		this->CurrentSignalAction := Action
		this->CurrentSignalInfo := Info
		this->CurrentSignalContext := UserContext
		
		Context->RDI := Number
		Context->RSI := Info As i64
		Context->RDX := UserContext As i64
		Context->RIP := Action->Handler
	}
	
	define void FireSignals() {
		; Doesn't return if a signal is fired
		
		for (i32 Index := 0, Index < 31, Index++) {
			i64 Mask := this->SignalMask(Index)
			
			if (this->PendingSignals & Mask) {
				i32 ErrorNumber := this->PendingErrorNumbers[Index]
				i32 SignalCode := this->PendingSignalCodes[Index]
				
				this->FireSignal(Index, ErrorNumber, SignalCode)
			}
		}
	}
	
	define void Resume() {
		this->FireSignals() ; Doesn't return if a signal is fired
	}
	
	define void QueueSignal(i32 Number, i32 Error, i32 Code) {
		; TODO: If urgent, this->FireSignal now
		
		this->PendingSignals |= this->SignalMask(Number)
		
		this->PendingErrorNumbers[Number] := Error
		this->PendingSignalCodes[Number] := Code
	}
	
	define void SignalReturn() {
		; Called from syscall handler, shouldn't return
		
		;this->CurrentSignalContext~>Registers->PopulateContext(this~>Context)
		this->SignalMask := this->CurrentSignalContext->Mask
		this->CurrentSignal := 0
		
		this->Resume()
	}
	
	INode* WorkingDirectory
}

Process* CurrentProcess := null