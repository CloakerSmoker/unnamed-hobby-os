#Require "./src/utility/ELF.rlx"
#Require "./src/kernel/core/MemoryMapping.rlx"
#Require "./src/linux/Signals.rlx"

struct Process {
	i64[10] FileDescriptorsToHandles
	i32 FileDescriptorCount
	
	ELFHeader* ELF
	MemoryMappingGroup* Mappings
	PageHeap* PageAllocator
	
	void* BreakStart
	i64 BreakPages
	
	union {
		AMD64Context Context
		Task Task
	}
	
	Event OnKilled
	
	i32 ExitCode
	
	define void Initialize(ELFHeader* Header, MemoryMappingGroup* Mappings) {
		this->ELF := Header
		this->Mappings := Mappings
		
		i64 MaxAddress := 0
	
		ELFProgramHeader* ProgramHeaders := Header->GetProgramHeaders()

		for (i32 Index := 0, Index < Header->ProgramHeaderEntryCount, Index++) {
			ELFProgramHeader* NextProgramHeader := ProgramHeaders[Index]
			
			if (NextProgramHeader->Type = ELF_SEGMENT_TYPE_LOAD) {
				i64 NextEnd := NextProgramHeader->VirtualAddress + NextProgramHeader->MemorySize
				
				if (NextEnd > MaxAddress) {
					MaxAddress := NextEnd
				}
			}
		}
		
		this->BreakStart := ((MaxAddress + PAGE_SIZE) & 0x7FFF_FFFF_FFFF_F000) As void*
		this->BreakPages := 0
	}
	
	define void Run() {
		this~>Task->Resume()
	}
	
	define void Start() {
		this~>Task->NeedsUserMode := true
		this->Run()
	}
	
	define void* GetBreak() {
		return this->BreakStart + (this->BreakPages * PAGE_SIZE)
	}
	define void* SetBreak(void* NewBreakEnd) {
		i32 AdditionalBreakPages := ((NewBreakEnd - this->GetBreak()) As i32) / PAGE_SIZE
		
		void* FirstNewBreakPage := this->GetBreak()
		
		this->Mappings->AllocateAddress(FirstNewBreakPage, AdditionalBreakPages, PAGE_USER | PAGE_WRITE)
		
		SetMemory(FirstNewBreakPage, AdditionalBreakPages * PAGE_SIZE, 0)
		
		this->BreakPages += AdditionalBreakPages
		
		return this->GetBreak()
	}
	
	define void Exit(i32 Code) {
		this->ExitCode := Code
		this~>OnKilled->Fire(Code As void*)
		
		SchedulerEnd()
		
		;KernelHeap->Free(CurrentProcess)
		;Mappings->Delete()
	}
	
	LinuxSignalAction[31] Actions
	
	i32[31] PendingErrorNumbers
	i32[31] PendingSignalCodes
	
	i64 SignalMask
	i64 PendingSignals
	
	i32 CurrentSignal
	LinuxSignalAction* CurrentSignalAction
	LinuxSignalInfo* CurrentSignalInfo
	LinuxSignalUserContext* CurrentSignalContext
	
	define i64 SignalMask(i32 Number) {
		return (1 As i64) << ((Number & 0xFF) As i8)
	}
	
	define void DoDefaultSignalAction(i32 Number, i32 ErrorNumber, i32 SignalCode) {
		this->Exit(Number)
	}
	
	define void FireSignal(i32 Number, i32 ErrorNumber, i32 SignalCode) {
		i64 Mask := this->SignalMask(Number)
		
		if (this->SignalMask & Mask) {
			return
		}
		else if (this->PendingSignals & Mask) {
			return
		}
		
		i64 OldMask := this->SignalMask
		
		LinuxSignalAction* Action := this->Actions[Number]
		
		if (Action->Handler = LINUX_SIGNAL_HANDLER_DEFAULT) {
			this->DoDefaultSignalAction(Number, ErrorNumber, SignalCode)
			
			return
		}
		else if (Action->Handler = LINUX_SIGNAL_HANDLER_IGNORE) {
			return
		}
		
		this->SignalMask |= Mask
		this->SignalMask |= Action->Mask
		
		AMD64Context* Context := this~>Context
		
		void* OriginalRSP := Context->RSP
		
		LinuxSignalInfo* Info := Context->StackAllocate(#LinuxSignalInfo)
		
		Info->SignalNumber := Number
		Info->ErrorNumber := ErrorNumber
		Info->SignalCode := SignalCode
		
		LinuxSignalUserContext* UserContext := Context->StackAllocate(#LinuxSignalUserContext)
		
		LinuxSignalRegisters* Registers := UserContext~>Registers
		LinuxSignalStack* Stack := UserContext~>Stack
		
		Registers->PopulateFromContext(Context)
		Registers->RSP := OriginalRSP
		
		UserContext->Mask := OldMask
		
		if (Action->Flags & LINUX_SIGNAL_ATTRIBUTE_RESTORER) {
			Context->Push(Action->Restorer As i64)
		}
		
		this->CurrentSignal := Number
		this->CurrentSignalAction := Action
		this->CurrentSignalInfo := Info
		this->CurrentSignalContext := UserContext
		
		Context->RDI := Number
		Context->RSI := Info As i64
		Context->RDX := UserContext As i64
		Context->RIP := Action->Handler
		
		this->Run()
	}
	
	define void FireSignals() {
		; Doesn't return if a signal is fired
		
		for (i32 Index := 0, Index < 31, Index++) {
			i64 Mask := this->SignalMask(Index)
			
			if (this->PendingSignals & Mask) {
				i32 ErrorNumber := this->PendingErrorNumbers[Index]
				i32 SignalCode := this->PendingSignalCodes[Index]
				
				this->FireSignal(Index, ErrorNumber, SignalCode)
			}
		}
	}
	
	define void Resume() {
		this->FireSignals() ; Doesn't return if a signal is fired
		
		this->Run() ; Doesn't return at all
	}
	
	define void QueueSignal(i32 Number, i32 Error, i32 Code) {
		; TODO: If urgent, this->FireSignal now
		
		this->PendingSignals |= this->SignalMask(Number)
		
		this->PendingErrorNumbers[Number] := Error
		this->PendingSignalCodes[Number] := Code
	}
	
	define void SignalReturn() {
		; Called from syscall handler, shouldn't return
		
		this->CurrentSignalContext~>Registers->PopulateContext(this~>Context)
		this->SignalMask := this->CurrentSignalContext->Mask
		this->CurrentSignal := 0
		
		this->Resume()
	}
	
	INode* WorkingDirectory
}

Process* CurrentProcess := null