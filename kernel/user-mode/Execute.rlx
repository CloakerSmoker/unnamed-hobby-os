#Require "./src/kernel/core/ELFLoader.rlx"
#Require "./src/kernel/user-mode/Process.rlx"

define i64* SetupExecuteStack(void* Stack, i32 ArgumentCount, i8** Arguments, i32 EnvironmentCount, i8** Environment) {
	i32 StringsLength := 0
	
	for (i32 Index := 0, Index < ArgumentCount, Index++) {
		i8* NextArgument := Arguments[Index]
		i32 NextArgumentLength := StringLength(NextArgument)
		
		StringsLength += NextArgumentLength + 1
	}
	for (i32 Index := 0, Index < EnvironmentCount, Index++) {
		i8* NextEnvironment := Arguments[Index]
		i32 NextEnvironmentLength := StringLength(NextEnvironment)
		
		StringsLength += NextEnvironmentLength + 1
	}
	
	if (StringsLength % 16) {
		StringsLength += 16 - (StringsLength % 16)
	}
	
	i32 EnvironmentLength := (EnvironmentCount + 1) * 8
	i32 ArgumentLength := (ArgumentCount + 2) * 8
	
	i64* RSP := Stack - StringsLength - 8 - 16 - EnvironmentLength - ArgumentLength
	
	;Print("RSP (Unaligned) %x\n", RSP)
	
	if (RSP & 16) {
		RSP -= 8
	}
	
	;Print("RSP %x\n", RSP)
	
	i32 TopOffset := 0
	i32 BottomOffset := 0
	
	RSP[BottomOffset++] := ArgumentCount
	
	for (i32 Index := 0, Index < ArgumentCount, Index++) {
		i8* NextArgument := Arguments[Index]
		i32 NextArgumentLength := StringLength(NextArgument)
		
		TopOffset += NextArgumentLength + 1
		
		i8* NextArgumentBuffer := Stack - TopOffset
		
		MoveMemory(NextArgumentBuffer, NextArgument, NextArgumentLength)
		
		RSP[BottomOffset++] := NextArgumentBuffer As i64
	}
	
	RSP[BottomOffset++] := 0
	
	for (i32 Index := 0, Index < EnvironmentCount, Index++) {
		i8* NextEnvironment := Arguments[Index]
		i32 NextEnvironmentLength := StringLength(NextEnvironment)
		
		TopOffset += NextEnvironmentLength + 1
		
		i8* NextEnvironmentBuffer := Stack - TopOffset
		
		MoveMemory(NextEnvironmentBuffer, NextArgument, NextEnvironmentLength)
		
		RSP[BottomOffset++] := NextEnvironmentBuffer As i64
	}
	
	RSP[BottomOffset++] := 0
	RSP[BottomOffset++] := 0
	
	return RSP
}

i8** NULL_ARGUMENTS := null As i8**
i8** NULL_ENVIRONMENT := null As i8**

PageHeap* UserVirtualAddresses := PageHeap:Adopt(ADDRESS_OF_USER_PAGES As i64, 0x100)

define i32 Execute(void* Buffer, i32 ArgumentCount, i8** Arguments, i32 EnvironmentCount, i8** Environment) {
	ELFHeader* ELFData := Buffer As ELFHeader*
	
	UserVirtualAddresses->FreeAll()
	
	MemoryMappingGroup* Mappings := MemoryMappingGroup:New(KernelAddressSpace, PhysicalMemory, UserVirtualAddresses)
	
	MapELF(Mappings, ELFData)
	
	void* StackBottom := ADDRESS_OF_USER_STACK
	
	Mappings->AllocateAddress(StackBottom, 20, PAGE_USER | PAGE_WRITE)
	
	SetMemory(StackBottom, 20 * PAGE_SIZE, 0)
	
	void* StackTop := StackBottom + (20 * PAGE_SIZE)
	
	Info("Stack Top %x\nStack Bottom %x\n", StackTop, StackBottom)
	
	i64* RSP := SetupExecuteStack(StackTop, ArgumentCount, Arguments, EnvironmentCount, Environment)
	
	Process* LastProcess := CurrentProcess
	
	CurrentProcess := KernelHeap->Allocate('PROC', #Process)
	CurrentProcess->Initialize(ELFData, Mappings)
	
	AMD64Context* Context := CurrentProcess~>Task~>Context
	Context->Zero()
	Context->RSP := RSP
	Context->RawRIP := ELFData->EntryPoint
	
	CurrentProcess->Run()
	
	i32 ExitCode := CurrentProcess->ExitCode
	
	KernelHeap->Free(CurrentProcess)
	Mappings->Delete()
	
	CurrentProcess := LastProcess
	
	return ExitCode
}