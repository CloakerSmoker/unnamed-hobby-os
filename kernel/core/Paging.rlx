i32 PAGE_COUNT_FOR_1MB := 0x100
i32 PAGE_COUNT_FOR_2MB := 0x200
i32 PAGE_COUNT_FOR_4MB := 0x400
i32 PAGE_COUNT_FOR_6MB := 0x600
i32 PAGE_COUNT_FOR_8MB := 0x800

i32 BYTES_IN_1MB := 0x10_0000
i32 BYTES_IN_2MB := 0x20_0000
i32 BYTES_IN_4MB := 0x40_0000
i32 BYTES_IN_6MB := 0x60_0000
i32 BYTES_IN_8MB := 0x80_0000

i32 PAGES_PER_PT        := 0x0000_0200
i32 PAGES_PER_PD        := 0x0004_0000
i32 PAGES_PER_PDP       := 0x0800_0000

i64 PAGE_FRAMES_BASE := 0x20_0000

i32 PAGE_SIZE               := 0x1000

i64 PAGE_NOT_PRESENT := 0
i64 PAGE_PRESENT     := 0b001
i64 PAGE_WRITE       := 0b010
i64 PAGE_USER        := 0b100

struct Page {
	i8[0x1000] Data
}

define void SetCR3(i64**** PML4T, void* Continuation, void* Parameter) asm {
	movcr3, rdi
	mov, rdi, rdx
	jmp, rsi
}

define i32 GetPML4Index(void* Address) {
	return ((Address & 0b_111111111_000000000_000000000_000000000_000000000000) >> 39) As i32
}
define i32 GetPDPIndex(void* Address) {
	return ((Address &           0b_111111111_000000000_000000000_000000000000) >> 30) As i32
}
define i32 GetPDIndex(void* Address) {
	return ((Address &                     0b_111111111_000000000_000000000000) >> 21) As i32
}
define i32 GetPTIndex(void* Address) {
	return ((Address &                               0b_111111111_000000000000) >> 12) As i32
}

define i64**** GetPML4Entry(i64**** PML4, void* Address) {
	i32 Index      := ((Address & 0b_111111111_000000000_000000000_000000000_000000000000) >> 39) As i32
	return &PML4[Index]
}
define i64*** GetPDPEntry(i64*** PDT, void* Address) {
	PDT            &=             0b_111111111_111111111_111111111_111111111_000000000000
	i32 Index      := ((Address &           0b_111111111_000000000_000000000_000000000000) >> 30) As i32
	return &PDT[Index]
}
define i64** GetPDEntry(i64** PD, void* Address) {
	PD             &=             0b_111111111_111111111_111111111_111111111_000000000000
	i32 Index      := ((Address &                     0b_111111111_000000000_000000000000) >> 21) As i32
	return &PD[Index]
}
define i64* GetPTEntry(i64* PT, void* Address) {
	PT             &=             0b_111111111_111111111_111111111_111111111_000000000000
	i32 Index      := ((Address &                               0b_111111111_000000000000) >> 12) As i32
	return &PT[Index]
}

define void* RemovePageFlags(void* Entry) {
	Entry &= 0b_111111111_111111111_111111111_111111111_000000000000
	
	return Entry
}
define i64 PackPageFlags(i64 PageNumber, i64 Flags) {
	return (PageNumber << 12) | Flags
}


define i32 ExternalMapPage(void* CR3, void* RawTempPages, void* From, i64 To) {
	Page* TempPages := RawTempPages
	i32 TempPagesUsed := 0
	
	i64**** PML4E := GetPML4Entry(i64****{CR3}, From)
	i64*** PDP := *PML4E
	
	if !(PDP & PAGE_PRESENT) {
		PDP := i64***{&TempPages[TempPagesUsed++]}
		*PML4E := PDP | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
	}
	
	i64*** PDPE := GetPDPEntry(*PML4E, From)
	i64** PD := *PDPE
	
	if !(PD & PAGE_PRESENT) {
		PD := i64**{&TempPages[TempPagesUsed++]}
		*PDPE := PD | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
	}

	i64** PDE := GetPDEntry(*PDPE, From)
	i64* PT := *PDE
	
	if !(PT & PAGE_PRESENT) {
		PT := i64*{&TempPages[TempPagesUsed++]}
		*PDE := PT | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
	}
	
	i64* PTE := RemovePageFlags(GetPTEntry(*PDE, From))
	
	*PTE := To
	
	return TempPagesUsed
}

struct PagePath {
	i32 PML4Index
	i32 PDPIndex
	i32 PDIndex
	i32 PTIndex
}

struct AddressSpaceManager {
	void* Base
	
	union {
		i64**** PML4
		void* RawPML4
	}
	
	i32 NextFreePageFrame
	i32 PageFrameCount
	
	define void* GetPageFrame(i32 Index) {
		return this->Base + (Index * PAGE_SIZE)
	}
	define i32 AllocatePageFrameIndex() {
		return this->NextFreePageFrame++
	}
	define void* AllocatePageFrame() {
		return this->GetPageFrame(this->NextFreePageFrame++)
	}
	
	define void Initialize(void* Base, i32 FrameCount) {
		this->Base := Base
		this->PageFrameCount := FrameCount
		
		this->RawPML4 := this->AllocatePageFrame()
	}
	
	define i64**** FindOrAddPML4Entry(void* Address) {
		i64**** PML4E := GetPML4Entry(this->PML4, Address)
		i64*** PDP := *PML4E
		
		if !(PDP & PAGE_PRESENT) {
			PDP := this->AllocatePageFrame()
			*PML4E := PDP | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
		}
		
		return PML4E
	}
	define i64*** FindOrAddPDPEntry(i64**** PML4E, void* Address) {
		i64*** PDPE := GetPDPEntry(*PML4E, Address)
		i64** PD := *PDPE
		
		if !(PD & PAGE_PRESENT) {
			PD := this->AllocatePageFrame()
			*PDPE := PD | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
		}
		
		return PDPE
	}
	define i64** FindOrAddPDEntry(i64*** PDPE, void* Address) {
		i64** PDE := GetPDEntry(*PDPE, Address)
		i64* PT := *PDE
		
		if !(PT & PAGE_PRESENT) {
			PT := this->AllocatePageFrame()
			*PDE := PT | PAGE_PRESENT | PAGE_WRITE | PAGE_USER
		}
		
		return PDE
	}
	define i64* FindOrAddPTEntry(i64** PDE, void* Address) {
		i64* PTE := GetPTEntry(*PDE, Address)
		
		return PTE
	}
	
	define i64*** FindOrAddPDPEntry(void* Address) {
		i64**** PML4E := this->FindOrAddPML4Entry(Address)
		i64*** PDPE := this->FindOrAddPDPEntry(PML4E, Address)
		
		return PDPE
	}
	define i64** FindOrAddPDEntry(void* Address) {
		i64*** PDPE := this->FindOrAddPDPEntry(Address)
		i64** PDE := this->FindOrAddPDEntry(PDPE, Address)
		
		return PDE
	}
	define i64* FindOrAddPTEntry(void* Address) {
		i64** PDE := this->FindOrAddPDEntry(Address)
		i64* PTE := this->FindOrAddPTEntry(PDE, Address)
		
		return PTE
	}
	
	define void Map(void* Address, i64 PageNumber) {
		i64* PageTableEntry := RemovePageFlags(this->FindOrAddPTEntry(Address))
		
		*PageTableEntry := PackPageFlags(PageNumber, PAGE_PRESENT | PAGE_WRITE | PAGE_USER)
	}
	define void Map(void* Address, i64 PageNumber, i64 Flags) {
		i64* PageTableEntry := RemovePageFlags(this->FindOrAddPTEntry(Address))
		
		*PageTableEntry := PackPageFlags(PageNumber, Flags)
	}
	
	define void MapRange(void* Address, i64 StartPage, i32 Count, i64 Flags) {
		while (Count != 0) {
			i64** PDE := this->FindOrAddPDEntry(Address)
			i64* PT := RemovePageFlags(*PDE)
			i32 PTIndex := GetPTIndex(Address)
			
			i32 PTSpace := PAGES_PER_PT - PTIndex
			
			i32 PTMax := Count
			
			if (Count > PTSpace) {
				PTMax := PTSpace
			}
			
			;BochsPrint("Map PT @ %x [%x-%x] to %x-%x\n", PT, PTIndex, PTMax, StartPage, StartPage + PTMax)
			
			for (i32 Index := 0, Index < PTMax, Index++) {
				PT[PTIndex + Index] := PackPageFlags(StartPage + Index, Flags)
			}
			
			Count -= PTMax
			StartPage += PTMax
			Address += PTMax * PAGE_SIZE
		}
	}
	define void MapRange(void* Address, i64 StartPage, i32 Count) {
		this->MapRange(Address, StartPage, Count, PAGE_PRESENT | PAGE_WRITE | PAGE_USER)
	}
	
	define void Takeover(void* Continuation, void* Parameter){
		SetCR3(this->PML4, Continuation, Parameter)
	}
	
	define i64 EndRun(i64 RunStartAddress, i64 RunStart, i64 RunLastAddress, i64 RunLast, i64 RunLength) {
		if (RunLength) {
			Print("%x -> %x\n", RunStartAddress, RunStart)
			
			if (RunLength > 1) {
				Print("...\n")
				Print("%x -> %x\n\n", RunLastAddress, RunLast)
			}
		}
		
		return 0
	}
	
	define void Print() {
		i64**** PML4 := this->PML4
		
		i64 RunStartAddress := 0
		i64 RunStart := 0
		i64 RunLastAddress := 0
		i64 RunLast := 0
		i64 RunLength := 0
		
		for (i64 PML4Index := 0, PML4Index < 512, PML4Index++) {
			i64**** PML4E := GetPML4Entry(PML4, (PML4Index << 39) As void*)
			
			if (*PML4E & PAGE_PRESENT) {
				for (i64 PDPIndex := 0, PDPIndex < 512, PDPIndex++) {
					i64*** PDPE := GetPDPEntry(*PML4E, (PDPIndex << 30) As void*)
					
					if (*PDPE & PAGE_PRESENT) {
						for (i64 PDIndex := 0, PDIndex < 512, PDIndex++) {
							i64** PDE := GetPDEntry(*PDPE, (PDIndex << 21) As void*)
							
							if (*PDE & PAGE_PRESENT) {
								for (i64 PTIndex := 0, PTIndex < 512, PTIndex++) {
									i64* PTE := GetPTEntry(*PDE, (PTIndex << 12) As void*)
									
									if (*PTE & PAGE_PRESENT) {
										i64 Address := (PML4Index << 39) | (PDPIndex << 30) | (PDIndex << 21) | (PTIndex << 12) 
										
										if (RunStart = 0 && RunLength = 0) {
											RunStartAddress := Address
											RunStart := *PTE
										}
										else if ((*PTE) - RunLast >= 0x1300) {
											RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
											
											RunStartAddress := Address
											RunStart := *PTE
											
											i8* a := "aaaaaaaaaaaaaaaaaaaaaaa"
										}
										
										RunLength += 1
										RunLastAddress := Address
										RunLast := *PTE
									}
									else {
										RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
										RunStart := 0
									}
								}
							}
							else {
								RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
								RunStart := 0
							}
						}
					}
					else {
						RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
						RunStart := 0
					}
				}
			}
			else {
				RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
				RunStart := 0
			}
		}
		
		RunLength := this->EndRun(RunStartAddress, RunStart, RunLastAddress, RunLast, RunLength)
	}
}

define i32 SizeToPageCount(i32 Size) {
	i32 PageCount := Size / PAGE_SIZE
	
	if (Size % PAGE_SIZE) {
		PageCount += 1
	}
	
	return PageCount
}
define void* PageNumberToPointer(i64 PageNumber) {
	return (PageNumber * PAGE_SIZE) As void*
}
define i64 PointerToPageNumber(void* PageMemory) {
	return (PageMemory / PAGE_SIZE) As i64
}

AddressSpaceManager RawKernelAddressSpace
AddressSpaceManager* KernelAddressSpace := &RawKernelAddressSpace