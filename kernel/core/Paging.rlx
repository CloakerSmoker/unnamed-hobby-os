i32 PAGE_COUNT_FOR_1MB := 0x100
i32 PAGE_COUNT_FOR_2MB := 0x200
i32 PAGE_COUNT_FOR_4MB := 0x400
i32 PAGE_COUNT_FOR_6MB := 0x600
i32 PAGE_COUNT_FOR_8MB := 0x800

i32 BYTES_IN_1MB := 0x10_0000
i32 BYTES_IN_2MB := 0x20_0000
i32 BYTES_IN_4MB := 0x40_0000
i32 BYTES_IN_6MB := 0x60_0000
i32 BYTES_IN_8MB := 0x80_0000

i32 PAGES_PER_PT        := 0x0000_0200
i32 PAGES_PER_PD        := 0x0004_0000
i32 PAGES_PER_PDP       := 0x0800_0000

i64 PAGE_FRAMES_BASE := 0x20_0000

i32 PAGE_SIZE               := 0x1000

i64 PAGE_NOT_PRESENT := 0
i64 PAGE_PRESENT     := 1
i64 PAGE_WRITE       := 2

define void SetCR3(i64**** PML4T) asm {
	movcr3, rdi
	ret
}

struct PagePath {
	i32 PML4Index
	i32 PDPIndex
	i32 PDIndex
	i32 PTIndex
}

struct AddressSpaceManager {
	void* Base
	
	union {
		i64**** PML4
		void* RawPML4
	}
	
	i32 NextFreePageFrame
	i32 PageFrameCount
	
	define void* GetPageFrame(i32 Index) {
		return this->Base + (Index * PAGE_SIZE)
	}
	define i32 AllocatePageFrameIndex() {
		return this->NextFreePageFrame++
	}
	define void* AllocatePageFrame() {
		return this->GetPageFrame(this->NextFreePageFrame++)
	}
	
	define void Initialize(void* Base, i32 FrameCount) {
		this->Base := Base
		this->PageFrameCount := FrameCount
		
		this->RawPML4 := this->AllocatePageFrame()
	}
	
	define i32 GetPML4Index(void* Address) {
		return ((Address & 0b_111111111_000000000_000000000_000000000_000000000000) >> 39) As i32
	}
	define i32 GetPDPIndex(void* Address) {
		return ((Address &           0b_111111111_000000000_000000000_000000000000) >> 30) As i32
	}
	define i32 GetPDIndex(void* Address) {
		return ((Address &                     0b_111111111_000000000_000000000000) >> 21) As i32
	}
	define i32 GetPTIndex(void* Address) {
		return ((Address &                               0b_111111111_000000000000) >> 12) As i32
	}
	
	define i64**** GetPML4Entry(void* Address) {
		i32 Index      := ((Address & 0b_111111111_000000000_000000000_000000000_000000000000) >> 39) As i32
		return &this->PML4[Index]
	}
	define i64*** GetPDPEntry(i64*** PDT, void* Address) {
		PDT            &=             0b_111111111_111111111_111111111_111111111_000000000000
		i32 Index      := ((Address &           0b_111111111_000000000_000000000_000000000000) >> 30) As i32
		return &PDT[Index]
	}
	define i64** GetPDEntry(i64** PD, void* Address) {
		PD             &=             0b_111111111_111111111_111111111_111111111_000000000000
		i32 Index      := ((Address &                     0b_111111111_000000000_000000000000) >> 21) As i32
		return &PD[Index]
	}
	define i64* GetPTEntry(i64* PT, void* Address) {
		PT             &=             0b_111111111_111111111_111111111_111111111_000000000000
		i32 Index      := ((Address &                               0b_111111111_000000000000) >> 12) As i32
		return &PT[Index]
	}
	
	define i64**** FindOrAddPML4Entry(void* Address) {
		i64**** PML4E := this->GetPML4Entry(Address)
		i64*** PDP := *PML4E
		
		if !(PDP & PAGE_PRESENT) {
			PDP := this->AllocatePageFrame()
			*PML4E := PDP | PAGE_PRESENT | PAGE_WRITE
		}
		
		return PML4E
	}
	define i64*** FindOrAddPDPEntry(i64**** PML4E, void* Address) {
		i64*** PDPE := this->GetPDPEntry(*PML4E, Address)
		i64** PD := *PDPE
		
		if !(PD & PAGE_PRESENT) {
			PD := this->AllocatePageFrame()
			*PDPE := PD | PAGE_PRESENT | PAGE_WRITE
		}
		
		return PDPE
	}
	define i64** FindOrAddPDEntry(i64*** PDPE, void* Address) {
		i64** PDE := this->GetPDEntry(*PDPE, Address)
		i64* PT := *PDE
		
		if !(PT & PAGE_PRESENT) {
			PT := this->AllocatePageFrame()
			*PDE := PT | PAGE_PRESENT | PAGE_WRITE
		}
		
		return PDE
	}
	define i64* FindOrAddPTEntry(i64** PDE, void* Address) {
		i64* PTE := this->GetPTEntry(*PDE, Address)
		
		return PTE
	}
	
	define i64*** FindOrAddPDPEntry(void* Address) {
		i64**** PML4E := this->FindOrAddPML4Entry(Address)
		i64*** PDPE := this->FindOrAddPDPEntry(PML4E, Address)
		
		return PDPE
	}
	define i64** FindOrAddPDEntry(void* Address) {
		i64*** PDPE := this->FindOrAddPDPEntry(Address)
		i64** PDE := this->FindOrAddPDEntry(PDPE, Address)
		
		return PDE
	}
	define i64* FindOrAddPTEntry(void* Address) {
		i64** PDE := this->FindOrAddPDEntry(Address)
		i64* PTE := this->FindOrAddPTEntry(PDE, Address)
		
		return PTE
	}
	
	define void* RemoveFlags(void* Entry) {
		Entry &= 0b_111111111_111111111_111111111_111111111_000000000000
		
		return Entry
	}
	define i64 PackPTEntry(i64 Page, i64 Flags) {
		return (Page << 12) | Flags
	}
	
	define void Map(void* Address, i64 Page) {
		i64* PageTableEntry := this->RemoveFlags(this->FindOrAddPTEntry(Address))
		
		*PageTableEntry := this->PackPTEntry(Page, PAGE_PRESENT | PAGE_WRITE)
	}
	define void Map(void* Address, i64 Page, i64 Flags) {
		i64* PageTableEntry := this->RemoveFlags(this->FindOrAddPTEntry(Address))
		
		*PageTableEntry := this->PackPTEntry(Page, Flags)
	}
	
	define void MapRange(void* Address, i64 StartPage, i32 Count) {
		while (Count != 0) {
			i64** PDE := this->FindOrAddPDEntry(Address)
			i64* PT := this->RemoveFlags(*PDE)
			i32 PTIndex := this->GetPTIndex(Address)
			
			i32 PTSpace := PAGES_PER_PT - PTIndex
			
			i32 PTMax := Count
			
			if (Count > PTSpace) {
				PTMax := PTSpace
			}
			
			;BochsPrint("Map PT @ %x [%x-%x] to %x-%x\n", PT, PTIndex, PTMax, StartPage, StartPage + PTMax)
			
			for (i32 Index := 0, Index < PTMax, Index++) {
				PT[PTIndex + Index] := this->PackPTEntry(StartPage + Index, PAGE_PRESENT | PAGE_WRITE)
			}
			
			Count -= PTMax
			StartPage += PTMax
			Address += PTMax * PAGE_SIZE
		}
	}
	
	define void Takeover() {
		SetCR3(this->PML4)
	}
	
	define i32 SizeToPageCount(i32 Size) {
		i32 PageCount := Size / PAGE_SIZE
		
		if (Size % PAGE_SIZE) {
			PageCount += 1
		}
		
		return PageCount
	}
	define void* PageNumberToPointer(i64 PageNumber) {
		return (PageNumber * 0x1000) As void*
	}
	define i64 PointerToPageNumber(void* PageMemory) {
		return (PageMemory / 0x1000) As i64
	}
}

AddressSpaceManager RawAddressSpace
AddressSpaceManager* AddressSpace := &RawAddressSpace