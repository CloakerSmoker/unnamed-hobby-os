
#Require "./src/utility/x64.rlx"
#Require "./src/kernel/core/Descriptors.rlx"
#Require "./src/kernel/core/UserMode.rlx"
#Require "./src/linux/SystemCalls.rlx"

void*[20] SystemCalls

i32 SYSCALL_MAX_INDEX := 19
i32 SYSCALL_COUNT := 20

define i64 DoSystemCall(i64 One, i64 Two, i64 Three, i64 Four, AMD64Context* Context, void* Function) asm {
	jmp, r9
}

i32 SYSCALL_MAP_MEMORY := 9
i32 SYSCALL_UNMAP_MEMORY := 11
i32 SYSCALL_BREAK := 12
i32 SYSCALL_DEVICE_CONTROL := 16
i32 SYSCALL_WRITE_MULTIPLE := 20
i32 SYSCALL_SENDFILE := 40
i32 SYSCALL_EXIT := 60
i32 SYSCALL_ARCH_PRCTL := 158
i32 SYSCALL_SET_TID_PTR := 218
i32 SYSCALL_EXIT_GROUP := 231

declare i32 SystemCallPoll(LinuxPollTarget*, i32, i32)
declare void SystemCallSendFile(i64, i64, i64*, i64)
declare void SystemCallArchPrctl(i64, void*)
declare i64 SystemCallDeviceControl(i64, i32, void*)
declare i64 SystemCallWriteMultiple(i64, void*, i32)
declare void SystemCallExit(i64)
declare void* SystemCallProgramBreak(void*)
declare void* SystemCallMapMemory(void*, i32, i32, i32, i32, i32)
declare i64 SystemCallUnMapMemory(void*, i32)

declare void SystemCallSetSignalAction(i32, LinuxSignalAction*, LinuxSignalAction*)
declare void SystemCallSetSignalMask(i32, i64*, i64*)

define void HandleSystemCall(AMD64Context* Context) {
	SendEOI(0) ; HACK: PIC gets confused into thinking we've handling a very high priority interrupt
	SendEOI(8) ;  so we need to convince it otherwise in order to get interrupts while handling syscalls
	
	i64 Number := Context->RAX
	
	;Print("Syscall %x\n", Number)
	
	i8* Name := GetLinuxSysCallName(Number)
	
	Info("%s(%x, %x, %x, %x, %x, %x)\n", Name, Context->RDI, Context->RSI, Context->RDX, Context->R10, Context->R8, Context->R9)
	
	if (Number = SYSCALL_EXIT_GROUP) {
		Number := SYSCALL_EXIT
	}
	
	try {
		if (Number = SYSCALL_EXIT) {
			SystemCallExit(Context->RDI)
		}
		else if (Number = LINUX_SYSCALL_RT_SIGACTION) {
			SystemCallSetSignalAction(Context->EDI, Context->RSI As void*, Context->RDX As void*)
			
			ResumeUserMode(Context)
		}
		else if (Number = LINUX_SYSCALL_RT_SIGPROCMASK) {
			SystemCallSetSignalMask(Context->EDI, Context->RSI As i64*, Context->RDX As i64*)
			
			ResumeUserMode(Context)
		}
		else if (Number = LINUX_SYSCALL_POLL) {
			Context->RAX := SystemCallPoll(Context->RDI As void*, Context->ESI, Context->EDX) As i64
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_MAP_MEMORY) {
			Context->RAX := SystemCallMapMemory(Context->RDI As void*, Context->ESI, Context->EDX, Context->R10D, Context->R8D, Context->R9D) As i64
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_UNMAP_MEMORY) {
			Context->RAX := SystemCallUnMapMemory(Context->RDI As void*, Context->ESI)
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_ARCH_PRCTL) {
			DoSystemCall(Context->RDI, Context->RSI, Context->RDX, Context->R10, Context, &SystemCallArchPrctl)
			
			Context->RAX := 0
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_SET_TID_PTR) {
			Context->RAX := 1
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_DEVICE_CONTROL) {
			Context->RAX := SystemCallDeviceControl(Context->RDI, Context->ESI, Context->RDX As void*)
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_WRITE_MULTIPLE) {
			Context->RAX := SystemCallWriteMultiple(Context->RDI, Context->RSI As void*, Context->EDX)
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_SENDFILE) {
			DoSystemCall(Context->RDI, Context->RSI, Context->RDX, Context->R10, Context, &SystemCallSendFile)
			
			Context->RAX := 0
			
			ResumeUserMode(Context)
		}
		else if (Number = SYSCALL_BREAK) {
			Context->RAX := SystemCallProgramBreak(Context->RDI As void*) As i64
			
			ResumeUserMode(Context)
		}
		
		if (Number > SYSCALL_MAX_INDEX) {
			Context->RAX := -1
			Context->RDI := -1
			
			Print("UNIMPLEMENTED SYSCALL %x\n", Number)
			
			RestoreContext(&KernelContext)
			
			;ResumeUserMode(Context)
		}
		
		void* Function := SystemCalls[Number]
		
		if (Function = null) {
			Print("UNIMPLEMENTED SYSCALL %x\n", Number)
			
			RestoreContext(&KernelContext)
		}
		else {
			Context->RAX := DoSystemCall(Context->RDI, Context->RSI, Context->RDX, Context->R10, Context, Function)
		}
	}
	catch (i64 Code) {
		Print("Exception %l during syscall\n", Code)
		Print("%x(%x, %x, %x, %x, %x, %x)\n", Number, Context->RDI, Context->RSI, Context->RDX, Context->R10, Context->R8, Context->R9)
		SystemCallExit(-100123)
	}
	
	ResumeUserMode(Context)
}

define void RegisterSystemCall(i32 Index, void* Function) {
	SystemCalls[Index] := Function
}

define void SystemCallExit(i64 Code) {
	CurrentProcess->Exit(Code As i32)
}

declare void ShellGatherInput(i8*, i32)
declare void ShellPollForInput(i32)

#Require "./src/linux/Poll.rlx"

define i32 SystemCallPoll(LinuxPollTarget* Targets, i32 TargetCount, i32 Timeout) {
	if (Timeout < 0) {
		Timeout := 0x7FFF_FFFF
	}
	
	i32 CountWithReturnEvents := 0
	
	for (i32 Index := 0, Index < TargetCount, Index++) {
		LinuxPollTarget* Target := Targets[Index]
		
		if (Target->FileDescriptor = 0 && Target->RequestedEvents & LINUX_POLL_EVENT_INPUT_READY) {
			if (ShellPollForInput(Timeout)) {
				Target->ReturnedEvents |= LINUX_POLL_EVENT_INPUT_READY
				
				CountWithReturnEvents++
			}
		}
	}
	
	return CountWithReturnEvents
}


define void SystemCallSetSignalAction(i32 Number, LinuxSignalAction* New, LinuxSignalAction* Old) {
	if (Old) {
		MoveMemory(Old, CurrentProcess->Actions[Number], #LinuxSignalAction)
	}
	
	MoveMemory(CurrentProcess->Actions[Number], New, #LinuxSignalAction)
}

define void SystemCallSetSignalMask(i32 Operation, i64* New, i64* Old) {
	i64 Mask := CurrentProcess->SignalMask
	
	if (Old != null) {
		*Old := Mask
	}
	
	if (New != null) {
		if (Operation = LINUX_SIGNAL_MASK_BLOCK) {
			Mask |= *New
		}
		else if (Operation = LINUX_SIGNAL_MASK_UNBLOCK) {
			Mask &= ~(*New)
		}
		else if (Operation = LINUX_SIGNAL_MASK_SET) {
			Mask := *New
		}
	}
	
	CurrentProcess->SignalMask := Mask
}

define i64 SystemCallRead(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 0) {
		return ShellGatherInput(Buffer, Size)
	}
	
	FileDescriptor -= 3
	
	i32 BytesRead := 0
	i64 NewHandle := Ext2Read(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Buffer, Size, &BytesRead)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return BytesRead
}

define i64 SystemCallWrite(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 1 || FileDescriptor = 2) {
		PrintCharacters(Buffer, Size)
		
		return Size
	}
	
	FileDescriptor -= 3
	
	i64 NewHandle := Ext2Write(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Buffer, Size)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return Size
}

define void SystemCallSendFile(i64 Out, i64 In, i64* Offset, i64 Count) {
	;Print("SendFile(%x, %x, %x, %x)\n", Out, In, Offset, Count)
	
	for (i32 Index := 0, Index < Count, Index++) {
		i8 Byte := 0
		
		i64 Result := SystemCallRead(In, &Byte, 1)
		
		;Print("Read %i bytes\n", Result)
		
		if (Result != 1) {
			break
		}
		
		i64 Written := SystemCallWrite(Out, &Byte, 1)
		
		;Print("Wrote %i bytes\n", Written)
	}
}

define void* SystemCallProgramBreak(void* NewBreak) {
	if (NewBreak = null) {
		return CurrentProcess->GetBreak()
	}
	else {
		return CurrentProcess->SetBreak(NewBreak)
	}
}

#Require "./src/linux/Termios.rlx"

declare void ShellSetMode(TermiosConfig*)
declare void ShellGetMode(TermiosConfig*)

define i64 SystemCallDeviceControl(i64 FileDescriptor, i32 Command, void* Argument) {
	if (FileDescriptor = 0 || FileDescriptor = 1) {
		if (Command = TERMIOS_GET_WINDOW_SIZE) {
			TermiosWindowSize* Window := Argument
			
			Window->Rows := KernelTerminal->Height As i16
			Window->Columns := KernelTerminal->Width As i16
			
			return 0
		}
		else if (Command = TERMIOS_GET_CONFIG) {
			TermiosConfig* Config := Argument
			
			ShellGetMode(Config)
		}
		else if (Command = TERMIOS_SET_CONFIG) {
			TermiosConfig* Config := Argument
			
			ShellSetMode(Config)
		}
	}
	
	return 0
}

#Require "./src/linux/MultipleIO.rlx"

define i64 SystemCallWriteMultiple(i64 FileDescriptor, void* Data, i32 Count) {
	i64 TotalWritten := 0
	
	LinuxIOVector* Vectors := Data
	
	for (i32 Index := 0, Index < Count, Index++) {
		LinuxIOVector* Next := Vectors[Index]
		
		TotalWritten += SystemCallWrite(FileDescriptor, Next->Base, Next->Size As i32)
	}
	
	return TotalWritten
}

i32 LINUX_PROTECTION_READ  := 0x1
i32 LINUX_PROTECTION_WRITE := 0x2
i32 LINUX_PROTECTION_EXECUTE  := 0x4
i32 LINUX_PROTECTION_NONE  := 0x0

i32 LINUX_MAP_SHARED := 0x1
i32 LINUX_MAP_PRIVATE := 0x2
i32 LINUX_MAP_TYPE_MASK := 0xF

i32 LINUX_MAP_FIXED := 0x10
i32 LINUX_MAP_ANONYMOUS := 0x20

define i64 ConvertLinuxMemoryProtection(i32 Protection) {
	if (Protection = LINUX_PROTECTION_NONE) {
		return 0
	}
	
	i64 Result := PAGE_USER
	
	if (Protection & LINUX_PROTECTION_WRITE) {
		Result |= PAGE_WRITE
	}
	
	return Result
}

define MemoryMapping* LocateMemoryMapping(void* Address, i32 Size) {
	i32 PageCount := SizeToPageCount(Size)
	
	Address &= 0x7FFF_FFFF_FFFF_F000
	
	MemoryMapping* Mapping := CurrentProcess->Mappings->FindVirtual(Address)
	
	if (Mapping) {
		if (Mapping->PageCount != PageCount) { 
			; Address is the exact start of a mapping, but with less pages than the
			;  mapping actually has. So we split the mapping into a PageCount sized 
			;   chunk and whatever's left over
			
			CurrentProcess->Mappings->Split(Mapping, PageCount)
		}
		
		return Mapping
	}
	else {
		Mapping := CurrentProcess->Mappings->FindVirtualContaining(Address)
		
		if (Mapping) {
			if (Mapping->PageCount != PageCount) {
				; Existing mapping, but not the start of said mapping
				; Which means we need to split it, potentially twice
				; Like         Turns into    by doing two splits
				;  |XXXXXXXX|   |XX|XXX|X|
				;     ^---^
				; Of course, a middle->end segment will only split once
				
				i32 OffsetInMapping := (Address - Mapping->Virtual) As i32
				i32 PageIndexInMapping := OffsetInMapping / PAGE_SIZE
				
				MemoryMapping* Middle := null
				MemoryMapping* End := null
				
				CurrentProcess->Mappings->Split(Mapping, PageIndexInMapping, PageCount, &Middle, &End)
				
				if (Mapping->Virtual = Address) {
					return Mapping
				}
				else if (Middle->Virtual = Address) {
					return Middle
				}
				else if (End->Virtual = Address) {
					return End
				}
				else {
					Throw('OH-NO')
				}
			}
		}
	}
	
	return null
}

define void* SystemCallMapMemory(void* Address, i32 Size, i32 Protection, i32 Flags, i32 File, i32 Offset) {
	i64 MemoryFlags := ConvertLinuxMemoryProtection(Protection)
	
	i32 PageCount := SizeToPageCount(Size)
	MemoryMapping* Mapping := null
	
	if (Address = null) {
		Mapping := CurrentProcess->Mappings->AllocateMapping(PageCount, MemoryFlags)
		Address := Mapping->Virtual
		
		if (Flags & LINUX_MAP_ANONYMOUS) {
			SetMemory(Address, Size, 0)
		}
	}
	else {
		Mapping := LocateMemoryMapping(Address, Size)
		
		if (Mapping) {
			CurrentProcess->Mappings->UpdateFlags(Mapping, MemoryFlags)
		}
		else {
			Mapping := CurrentProcess->Mappings->AllocateAddress(Address, PageCount, MemoryFlags)
			
			if (Flags & LINUX_MAP_ANONYMOUS) {
				SetMemory(Address, Size, 0)
			}
		}
	}
	
	return Address
}

define i64 SystemCallUnMapMemory(void* Address, i32 Size) {
	MemoryMapping* Mapping := LocateMemoryMapping(Address, Size)
	
	if (Mapping) {
		CurrentProcess->Mappings->UnMap(Mapping)
	}
	else {
		return -1
	}
	
	return 0
}

i8 LINUX_FILE_READ := 0
i8 LINUX_FILE_WRITE := 1
i8 LINUX_FILE_READ_WRITE := 3
i8 LINUX_FILE_CREATE_NEW := 0x40

define i64 SystemCallOpen(i8* Path, i32 Flags, i32 Mode) {
	i8 Ext2Flags := OPEN_IF_EXISTS
	
	if (Flags & LINUX_FILE_CREATE_NEW) {
		Ext2Flags := OPEN_CREATE
	}
	
	i32 FileDescriptor := CurrentProcess->FileDescriptorCount++
	
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := Ext2Open(FS, Path, Ext2Flags)
	
	return FileDescriptor + 3
}

define i64 SystemCallClose(i64 FileDescriptor) {
	i64 NewHandle := Ext2Close(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor])
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return 0
}

define i64 SystemCallSeek(i64 FileDescriptor, i32 Offset, i8 Mode) {
	i64 NewHandle := Ext2Seek(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Offset, Mode)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	Offset := 0
	Ext2UnpackHandle(NewHandle, &Offset)
	
	return Offset
}

define i64 SystemCallDebug(i64 One) {
	Print("Hello from debug syscall handler, rdi = %x\n", One)
	
	return 0
}

i32 ARCH_PRCTL_SET_GS := 0x1001
i32 ARCH_PRCTL_SET_FS := 0x1002
i32 ARCH_PRCTL_GET_FS := 0x1003
i32 ARCH_PRCTL_GET_GS := 0x1004

define void SystemCallArchPrctl(i64 SubFunction, void* Parameter) {
	if (SubFunction = ARCH_PRCTL_SET_GS) {
		SetGS(Parameter)
	}
	else if (SubFunction = ARCH_PRCTL_GET_GS) {
		*(Parameter As i64*) := GetGS() As i64
	}
	else if (SubFunction = ARCH_PRCTL_SET_FS) {
		SetFS(Parameter)
	}
	else if (SubFunction = ARCH_PRCTL_GET_FS) {
		*(Parameter As i64*) := GetFS() As i64
	}
}

define void* GetKernelSystemCallStack() {
	return Kernel->SystemCallStack
}

define void OnSystemCall() asm {
	push, rax          ; Clobbered by GetCurrentTaskContext
	push, rdi          ; Clobbered by SaveContext(GetCurrentTaskContext())
	
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure user-mode RSP and everything else (only rcx/r11 are clobbered)
	; Of course, RIP and flags are lost (but the processor saved them for us)
	
	mov, {rdi} As i64*, rcx        ; Context.RIP = rcx
	mov, {rdi + 0x80} As i64*, r11 ; Context.Flags = r11
	
	pop, rax
	mov, {rdi + 0x38} As i64*, rax ; Context.RDI = UserRDI
	
	pop, rax
	mov, {rdi + 0x88} As i64*, rax ; Context.RAX = UserRAX
	
	mov, {rdi + 0x20} As i64*, rsp ; Context.RSP = UserRSP
	; (since we push rax/rdi, we need to update the saved RSP after our pops)
	
	call, @GetKernelSystemCallStack   ; Get stack for kernel code
	mov, rsp, rax
	
	push, rdi ; Save the user-mode context (and also pass it as a parameter to HandleSystemCall)
	
	sti
	jmp, @HandleSystemCall
}

define void SetupSystemCalls() {
	i64 OldEFER := ReadMSR(AMD64_MSR_EFER)
	WriteMSR(AMD64_MSR_EFER, OldEFER | 1)
	
	WriteMSR(AMD64_MSR_STAR, (KERNEL_CS << 32) | (USER_NULL << 48))
	
	WriteMSR(AMD64_MSR_LSTAR, &OnSystemCall As i64)
	
	WriteMSR(AMD64_MSR_SFMASK, 0x600)
	
	RegisterSystemCall(0, &SystemCallRead)
	RegisterSystemCall(1, &SystemCallWrite)
	RegisterSystemCall(2, &SystemCallOpen)
	RegisterSystemCall(3, &SystemCallClose)
	RegisterSystemCall(4, &SystemCallDebug)
	RegisterSystemCall(8, &SystemCallSeek)
}

define void UserModeReturnStub() asm {
	mov, rax, 60
	syscall
}

