
#Require "./src/utility/x64.rlx"
#Require "./src/kernel/core/Descriptors.rlx"

void*[20] SystemCalls

i32 SYSCALL_MAX_INDEX := 19
i32 SYSCALL_COUNT := 20

define i64 DoSystemCall(i64 One, i64 Two, i64 Three, i64 Four, void* RSP, void* Function) asm {
	jmp, r9
}

i32 SYSCALL_EXIT := 60

define i64 HandleSystemCall(i64 One, i64 Two, i64 Three, i64 Four, void* RSP, i64 Number) {
	SendEOI(0) ; HACK: PIC gets confused into thinking we've handling a very high priority interrupt
	SendEOI(8) ;  so we need to convince it otherwise in order to get interrupts while handling syscalls
	
	if (Number = SYSCALL_EXIT) {
		RestoreContext(&KernelContext)
	}
	
	if (Number > SYSCALL_MAX_INDEX) {
		return -1
	}
	
	void* Function := SystemCalls[Number]
	
	if (Function != null) {
		return DoSystemCall(One, Two, Three, Four, RSP, Function)
	}
	
	return -1
}

define void RegisterSystemCall(i32 Index, void* Function) {
	SystemCalls[Index] := Function
}

declare void ShellGatherInput(i8*, i32)

define i64 SystemCallRead(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 1) {
		ShellGatherInput(Buffer, Size)
	}
	
	return -2
}

define i64 SystemCallWrite(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 0) {
		PrintCharacters(Buffer, Size)
		
		return Size
	}
	
	return -2
}
define i64 SystemCallDebug(i64 One) {
	Print("Hello from debug syscall handler, rdi = %x\n", One)
	
	return 0
}

define void* GetKernelReEntryStack() {
	return Kernel->ReEntryStack
}

define void RestoreUserModeContext(AMD64Context* Context) {
	Print("Context @ %x\n", Context)
	Print("New RIP: %x\n", Context->RIP)
	
	RestoreContext(Context)
}

define void OnSystemCall() asm {
	mov, r8, rsp
	mov, r9, rax
	
	call, @GetKernelReEntryStack
	mov, rsp, rax
	
	push, rcx
	push, r8
	push, r11
	
	sti
	call, @HandleSystemCall
	
	pop, r11
	pop, r8
	pop, rcx
	
	mov, rsp, r8
	
	sysret
}

define void SetupSystemCalls() {
	i64 OldEFER := ReadMSR(AMD64_MSR_EFER)
	WriteMSR(AMD64_MSR_EFER, OldEFER | 1)
	
	WriteMSR(AMD64_MSR_STAR, (KERNEL_CS << 32) | (USER_NULL << 48))
	
	WriteMSR(AMD64_MSR_LSTAR, &OnSystemCall As i64)
	
	WriteMSR(AMD64_MSR_SFMASK, 0x600)
	
	RegisterSystemCall(0, &SystemCallRead)
	RegisterSystemCall(1, &SystemCallWrite)
	RegisterSystemCall(2, &SystemCallDebug)
}

define void UserModeReturnStub() asm {
	mov, rax, 60
	syscall
}

define void EnterUserMode(AMD64Context* Context) {
	Print("EnterUserMode(%x, %x)\n", Context->RIP, Context->RSP)
	
	if (SaveContext(&KernelContext)) {
		return
	}
	
	Context->RSP -= 8
	
	Context->RSP[0] := &UserModeReturnStub As i64
	
	void* TerribleHack := &RestoreUserModeContext
	
	asm (rax := Context->RSP, rdi := Context, rcx := TerribleHack) {
		mov, r11, 0x200
		mov, rsp, rax
		xchg, bx, bx
		sysret
	}
}

define void UserModeTest() {
	;FastSetMemory8(0x80_0000 As void*, 0, 1024 * 768 * 3)
	
	asm {
		mov, rax, 2
		mov, rdi, 1
		syscall
		
		mov, rax, 2
		mov, rdi, 2
		syscall
		
		xchg, bx, bx
	}
	
	Print("\t^SCHello from userland!^R\n")
}

define void Test() {
	i64 UserStackPages := PhysicalMemory->Reserve('STK', PAGE_SIZE * 10, PAGE_SIZE)
	void* UserStack    := UserStackPages As void*
	KernelAddressSpace->MapRange(UserStack, UserStackPages / PAGE_SIZE, 10)
	
	
	AMD64Context Context
	
	Context.Zero()
	Context.RSP := UserStack + (PAGE_SIZE * 10)
	Context.RIP := &UserModeTest
	
	EnterUserMode(&Context)
}