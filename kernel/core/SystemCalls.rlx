
#Require "./src/utility/x64.rlx"
#Require "./src/kernel/core/Descriptors.rlx"

void*[20] SystemCalls

i32 SYSCALL_MAX_INDEX := 19
i32 SYSCALL_COUNT := 20

define i64 DoSystemCall(i64 One, i64 Two, i64 Three, i64 Four, AMD64Context* Context, void* Function) asm {
	jmp, r9
}

i32 SYSCALL_EXIT := 60
i32 SYSCALL_ARCH_PRCTL := 158
i32 SYSCALL_SET_TID_PTR := 218
i32 SYSCALL_EXIT_GROUP := 231

declare void ResumeUserMode(AMD64Context*)

declare void SystemCallArchPrctl(i64, void*)

define void HandleSystemCall(AMD64Context* Context) {
	SendEOI(0) ; HACK: PIC gets confused into thinking we've handling a very high priority interrupt
	SendEOI(8) ;  so we need to convince it otherwise in order to get interrupts while handling syscalls
	
	i64 Number := Context->RAX
	
	Print("Syscall %x\n", Number)
	
	if (Number = SYSCALL_EXIT_GROUP) {
		Number := SYSCALL_EXIT
	}
	
	if (Number = SYSCALL_EXIT) {
		if (CurrentProcess && CurrentTask = CurrentProcess~>Task) {
			CurrentProcess->ExitCode := Context->RDI As i32
		}
		
		RestoreContext(&KernelContext)
	}
	else if (Number = SYSCALL_ARCH_PRCTL) {
		DoSystemCall(Context->RDI, Context->RSI, Context->RDX, Context->R10, Context, &SystemCallArchPrctl)
		
		Context->RAX := 0
		
		ResumeUserMode(Context)
	}
	else if (Number = SYSCALL_SET_TID_PTR) {
		Context->RAX := 1
		
		ResumeUserMode(Context)
	}
	
	if (Number > SYSCALL_MAX_INDEX) {
		Context->RAX := -1
		Context->RDI := -1
		
		Print("UNIMPLEMENTED SYSCALL %x\n", Number)
		
		RestoreContext(&KernelContext)
		
		;ResumeUserMode(Context)
	}
	
	void* Function := SystemCalls[Number]
	
	if (Function = null) {
		Context->RAX := -1
	}
	else {
		Context->RAX := DoSystemCall(Context->RDI, Context->RSI, Context->RDX, Context->R10, Context, Function)
	}
	
	ResumeUserMode(Context)
}

define void RegisterSystemCall(i32 Index, void* Function) {
	SystemCalls[Index] := Function
}

declare void ShellGatherInput(i8*, i32)

define i64 SystemCallRead(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 0) {
		ShellGatherInput(Buffer, Size)
		
		return Size
	}
	
	i32 BytesRead := 0
	i64 NewHandle := Ext2Read(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Buffer, Size, &BytesRead)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return BytesRead
}

define i64 SystemCallWrite(i64 FileDescriptor, i8* Buffer, i32 Size) {
	if (FileDescriptor = 1) {
		PrintCharacters(Buffer, Size)
		
		return Size
	}
	
	i64 NewHandle := Ext2Write(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Buffer, Size)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return Size
}

i8 LINUX_FILE_READ := 0
i8 LINUX_FILE_WRITE := 1
i8 LINUX_FILE_READ_WRITE := 3
i8 LINUX_FILE_CREATE_NEW := 0x40

define i64 SystemCallOpen(i8* Path, i32 Flags, i32 Mode) {
	i8 Ext2Flags := OPEN_IF_EXISTS
	
	if (Flags & LINUX_FILE_CREATE_NEW) {
		Ext2Flags := OPEN_CREATE
	}
	
	i32 FileDescriptor := CurrentProcess->FileDescriptorCount++
	
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := Ext2Open(FS, Path, Ext2Flags)
	
	return FileDescriptor
}

define i64 SystemCallClose(i64 FileDescriptor) {
	i64 NewHandle := Ext2Close(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor])
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	return 0
}

define i64 SystemCallSeek(i64 FileDescriptor, i32 Offset, i8 Mode) {
	i64 NewHandle := Ext2Seek(FS, CurrentProcess->FileDescriptorsToHandles[FileDescriptor], Offset, Mode)
	CurrentProcess->FileDescriptorsToHandles[FileDescriptor] := NewHandle
	
	Offset := 0
	Ext2UnpackHandle(NewHandle, &Offset)
	
	return Offset
}

define i64 SystemCallDebug(i64 One) {
	Print("Hello from debug syscall handler, rdi = %x\n", One)
	
	return 0
}

i32 ARCH_PRCTL_SET_GS := 0x1001
i32 ARCH_PRCTL_SET_FS := 0x1002
i32 ARCH_PRCTL_GET_FS := 0x1003
i32 ARCH_PRCTL_GET_GS := 0x1004

define void SystemCallArchPrctl(i64 SubFunction, void* Parameter) {
	if (SubFunction = ARCH_PRCTL_SET_GS) {
		SetGS(Parameter)
	}
	else if (SubFunction = ARCH_PRCTL_GET_GS) {
		*(Parameter As i64*) := GetGS() As i64
	}
	else if (SubFunction = ARCH_PRCTL_SET_FS) {
		SetFS(Parameter)
	}
	else if (SubFunction = ARCH_PRCTL_GET_FS) {
		*(Parameter As i64*) := GetFS() As i64
	}
}

define void* GetKernelSystemCallStack() {
	return Kernel->SystemCallStack
}

define void RestoreUserModeContext(AMD64Context* Context) {
	;Print("Context @ %x\n", Context)
	;Print("New RIP: %x\n", Context->RIP)
	
	RestoreFullContext(Context)
}

define void OnSystemCall() asm {
	push, rax          ; Clobbered by GetCurrentTaskContext
	push, rdi          ; Clobbered by SaveContext(GetCurrentTaskContext())
	
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure user-mode RSP and everything else (only rcx/r11 are clobbered)
	; Of course, RIP and flags are lost (but the processor saved them for us)
	
	mov, {rdi} As i64*, rcx        ; Context.RIP = rcx
	mov, {rdi + 0x80} As i64*, r11 ; Context.Flags = r11
	
	pop, rax
	mov, {rdi + 0x38} As i64*, rax ; Context.RDI = UserRDI
	
	pop, rax
	mov, {rdi + 0x88} As i64*, rax ; Context.RAX = UserRAX
	
	mov, {rdi + 0x20} As i64*, rsp ; Context.RSP = UserRSP
	; (since we push rax/rdi, we need to update the saved RSP after our pops)
	
	call, @GetKernelSystemCallStack   ; Get stack for kernel code
	mov, rsp, rax
	
	push, rdi ; Save the user-mode context (and also pass it as a parameter to HandleSystemCall)
	
	sti
	jmp, @HandleSystemCall
}

define void SetupSystemCalls() {
	i64 OldEFER := ReadMSR(AMD64_MSR_EFER)
	WriteMSR(AMD64_MSR_EFER, OldEFER | 1)
	
	WriteMSR(AMD64_MSR_STAR, (KERNEL_CS << 32) | (USER_NULL << 48))
	
	WriteMSR(AMD64_MSR_LSTAR, &OnSystemCall As i64)
	
	WriteMSR(AMD64_MSR_SFMASK, 0x600)
	
	RegisterSystemCall(0, &SystemCallRead)
	RegisterSystemCall(1, &SystemCallWrite)
	RegisterSystemCall(2, &SystemCallOpen)
	RegisterSystemCall(3, &SystemCallClose)
	RegisterSystemCall(4, &SystemCallDebug)
	RegisterSystemCall(8, &SystemCallSeek)
}

define void UserModeReturnStub() asm {
	mov, rax, 60
	syscall
}

define void ResumeUserMode(AMD64Context* Context) {
	;Print("[ResumeUserMode %x]", Context->RIP)
	
	void* TerribleHack := &RestoreUserModeContext
	
	asm (rax := Context->RSP, rdi := Context, rcx := TerribleHack) {
		mov, r11, 0x200
		mov, rsp, rax
		xchg, bx, bx
		sysret
	}
}

define void EnterUserMode(AMD64Context* Context) {
	;Print("EnterUserMode(%x, %x)\n", Context->RIP, Context->RSP)
	
	if (SaveContext(&KernelContext)) {
		return
	}
	
	;Context->RSP -= 8
	
	;Context->RSP[0] := &UserModeReturnStub As i64
	
	ResumeUserMode(Context)
}