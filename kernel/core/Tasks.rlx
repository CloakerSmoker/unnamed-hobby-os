#Require "./src/kernel/core/UserMode.rlx"

Task* CurrentTask := null

define Task* GetCurrentTaskContext() {
	return CurrentTask ; For inline assembly to call
}

i8 TASK_CAN_RUN := 0
i8 TASK_RUNNING := 1
i8 TASK_BLOCKED := 2
i8 TASK_PAUSED  := 3
i8 TASK_KILLED  := 4

struct Task {
	AMD64Context Context ; MUST be the first field
	
	Task* Next
	Task* AwaitedBy
	
	void* InitialRIP
	void* InitialRSP
	
	i32 Priority
	i8 NeedsUserMode
	i8 State
	
	static Task* New(i32 Priority) {
		Task* this := Alloc(#Task)
		
		this->Priority := Priority
		
		return this
	}
	
	define void Resume() {
		; Doesn't return
		
		CurrentTask := this

		if (this->NeedsUserMode) {
			ResumeUserMode(this~>Context)
		}
		else {
			RestoreFullContext(this~>Context)
		}
	}
	
	define void Yield() {
		this->State := TASK_CAN_RUN
	}
	define void Block() {
		this->State := TASK_BLOCKED
	}
	define void End() {
		this->State := TASK_KILLED
		
		Task* Waiter := this->AwaitedBy
		
		while (Waiter) {
			Waiter->State := TASK_CAN_RUN
			
			Waiter := Waiter->AwaitedBy
		}
	}
	
	define i8 CouldRun() {
		return this->State <= TASK_RUNNING
	}
}

Task* RootTask := null
Task* DelayTask := null

struct TaskScheduler {
	define void RunCurrent() {
		CurrentTask->State := TASK_RUNNING
		CurrentTask->Resume()
	}
	
	define void PickNext() {
		DisableInterrupts()
		
		Task* Current := RootTask
		
		;Info("Task %x can run? %i\n", Current, Current->CouldRun())
		
		Info("@%i.%i [%x, %x] ", PITWhole, PITFraction, RootTask, CurrentTask)
		
		while (Current) {
			Info("(%x %i), ", Current, Current->State)
			
			Current := Current->Next
		}
		
		Current := RootTask
		
		while (Current && !Current->CouldRun()) {
			Current := Current->Next
		}
		
		Info(" = %x\n", Current)
		
		if !(Current) {
			CurrentTask := DelayTask
		}
		else {
			CurrentTask := Current
		}
		
		;Info("Picked %x to run next\n", CurrentTask)
	}
	define void RunNext() {
		this->PickNext()
		this->RunCurrent()
	}
	
	define void YieldCurrent() {
		CurrentTask->State := TASK_PAUSED
		this->RunNext()
	}
	define void BlockCurrent() {
		CurrentTask->State := TASK_BLOCKED
		this->RunNext()
	}
	define void EndCurrent() {
		CurrentTask->State := TASK_KILLED
		this->RunNext()
	}
	
	define Task* OnExternalControlTransfer(Task* NewCurrent) {
		CurrentTask->State := TASK_CAN_RUN
		
		Task* Result := CurrentTask
		CurrentTask := NewCurrent
		
		return Result
	}
	
	define void Enqueue(Task* NewTask) {
		if (RootTask = null) {
			RootTask := NewTask
		}
		else {
			Task* Next := RootTask
			
			while (Next->Next && Next->Priority > NewTask->Priority) {
				Next := Next->Next
			}
			
			NewTask->Next := Next->Next
			Next->Next := NewTask
		}
	}
	
	define void Add(Task* NewTask) {
		this->Enqueue(NewTask)
	}
	
	define Task* MakeLightTask(void* Function) {
		Task* NewTask := KernelPageAllocator->AllocateVirtual(3)
		
		AMD64Context* NewContext := NewTask~>Context
		
		NewContext->RIP   := Function
		NewContext->RSP   := (NewTask + (PAGE_SIZE * 3)) As void*
		NewContext->Flags := X64_RFLAGS_IF
		
		KernelAddressSpace->UnmapRange(NewTask + (PAGE_SIZE * 1), 1)
		
		return NewTask
	}
	define Task* AddLightTask(void* Function) {
		Task* NewTask := this->MakeLightTask(Function)
		
		this->Add(NewTask)
		
		return NewTask
	}
	
	define i8 Quantum(i64 CurrentTickCount) {
		;Info("%x,", CurrentTask~>Context->RIP)
		
		this->PickNext()
		
		return EVENT_CALL_NEXT_LISTENER
	}
}

TaskScheduler _Scheduler
TaskScheduler* Scheduler := &_Scheduler

define void _SchedulerYield() {
	Scheduler->YieldCurrent()
}
define void SchedulerYield() asm {
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure interrupted context, with anything extra cleaned up below
	
	pop, rbx ; grab return address, store into context
	mov, {rdi} As i64*, rbx        ; Context.RIP = rax
	
	jmp, @_SchedulerYield
}

define void _SchedulerBlock() {
	Scheduler->BlockCurrent()
}
define void SchedulerBlock() asm {
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure interrupted context, with anything extra cleaned up below
	
	pop, rbx ; grab return address, store into context
	mov, {rdi} As i64*, rbx        ; Context.RIP = rax
	
	jmp, @_SchedulerBlock
}
define void SchedulerEnd() {
	Scheduler->EndCurrent()
}
define void SchedulerRestart() {
	; Called after non-task code 
	
	Scheduler->RunCurrent()
}

define void DoSchedulerDelay() {
	loop {
		; Nothing better to do
		
		;Info("D")
		
		asm {emit, 0xF4}
	}
}

define void StartScheduler() {
	DisableInterrupts()
	
	DelayTask := Scheduler->MakeLightTask(&DoSchedulerDelay)
	
	;Info("1")
	
	OnHardwareTimerTick->ListenLast(&TaskScheduler.Quantum, Scheduler)
	
	;Info("2")
	
	Scheduler->RunNext() ; Will resume the delay loop above unless other tasks can be run
	
	;Info("3")
}