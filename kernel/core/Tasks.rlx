#Require "./src/kernel/core/UserMode.rlx"

Task* CurrentTask := null

define Task* GetCurrentTaskContext() {
	return CurrentTask ; For inline assembly to call
}

i8 TASK_CAN_RUN := 0
i8 TASK_BLOCKED := 1
i8 TASK_STOPPED := 2

struct Task {
	AMD64Context Context ; MUST be the first field
	
	i32 Priority
	
	Task* Next
	Task* AwaitedBy
	
	i8 NeedsUserMode
	i8 State
	
	static Task* New(i32 Priority) {
		Task* this := Alloc(#Task)
		
		this->Priority := Priority
		
		return this
	}
	
	define void Resume() {
		; Doesn't return
		
		CurrentTask := this

		if (this->NeedsUserMode) {
			ResumeUserMode(this~>Context)
		}
		else {
			RestoreContext(this~>Context)
		}
	}
	
	define Task* FindNextRunnable() {
		return null
	}
	
	define void End() {
		Task* Waiter := this->AwaitedBy
		
		if (Waiter) {
			Waiter->State := TASK_CAN_RUN
		}
		
		Task* Next := this->Next
		
		Free(this)
		
		Next->Resume()
	}
}

Task RawDispatchTask
Task* DispatchTask := &RawDispatchTask

define void EndCurrentTask() {
	CurrentTask->End()
}

struct TaskQueue {
	Task* Next
	
	define Task* Allocate() {
		return Alloc(#Task)
	}
	
	define void Enqueue(Task* NewTask) {
		if (this->Next = null) {
			this->Next := NewTask
		}
		else {
			Task* Next := this->Next
			
			while (Next->Next && Next->Priority > NewTask->Priority) {
				Next := Next->Next
			}
			
			NewTask->Next := Next->Next
			Next->Next := NewTask
		}
	}
	define Task* Dequeue() {
		Task* Result := this->Next
		
		this->Next := Result->Next
		
		return Result
	}
	define void RunNext() {
		Task* Target := this->Dequeue()
		
		if !(Target) {
			return
		}
		
		Target->Resume()
	}
}

define void DispatchTask() {
	Task* Tail := CurrentTask->Next
	
	while (Tail != null) {
		if (Tail~>Context->RIP = &DispatchTask) {
			return
		}
		
	}
}