#Require "./src/utility/x64.rlx"
#Require "./src/drivers/PIC.rlx"

define void _InterruptSetup() asm {
	xchg, rax, {rsp + 0x10} As i64*
	
	push, rbx
	push, rcx
	push, rdx
	push, rbp
	push, r8
	push, r9
	push, r10
	push, r11
	push, r12
	push, r13
	push, r14
	push, r15
	mov, rsi, rsp
	
	jmp, rax
}
define void InterruptCodeSetup() asm {
	push, rdi
	xchg, rsi, {rsp + 0x10} As i64*
	lea, rdi, {rsp + 0x18} As i64*
	jmp, @_InterruptSetup
}
define void InterruptSetup() asm {
	push, rsi
	push, rdi
	lea, rdi, {rsp + 0x18} As i64*  /* Get interrupt context, which is above RDI,RSI,RIP on the stack */ 
	jmp, @_InterruptSetup
}
define void InterruptReturn() asm {
	pop, r15
	pop, r14
	pop, r13
	pop, r12
	pop, r11
	pop, r10
	pop, r9
	pop, r8
	pop, rbp
	pop, rdx
	pop, rcx
	pop, rbx
	pop, rdi
	pop, rsi
	pop, rax
	
	iret
}

struct InterruptRegisters {
	i64 R15, i64 R14, i64 R13, i64 R12, i64 R11, i64 R10, i64 R9, i64 R8,
	i64 RBP, i64 RDX, i64 RCX, i64 RBX, i64 RDI, i64 RSI, i64 RAX
}
struct InterruptContext {
	i64 RIP
	i64 CS
	i64 Flags
	i64 RSP
	i64 SS
}

struct IDTEntry unaligned {
	i16 OffsetLow16,
	i16 Selector,
	i8 PaddingZero,
	i8 Flags,
	i16 OffsetHigh16,
	i32 OffsetHigh32,
	i32 Padding
}

IDTEntry* IDT

define void InsertIDTEntry(i32 Index, void* Function, i8 Present) {
	IDTEntry* E := IDT[Index]
	
	MemorySet64(E As i64*, 0, 2)
	
	E->OffsetLow16 := (Function & 0xFFFF) As i16
	E->OffsetHigh16 := ((Function >> 16) & 0xFFFF) As i16
	E->OffsetHigh32 := ((Function >> 32) & 0xFFFFFFFF) As i32
	
	E->Selector := 0x08
	E->Flags := 0x0E | (Present << 7) As i8
}

i32 IDT_MAX := 50
i32 IDT_SIZE := IDT_MAX * #IDTEntry

declare void AddHandlerStubs()
declare void AddKernelHandlers()
declare void SetupDeviceInterrupts()

define void SetupInterrupts() {
	asm {cli}
	
	DescriptorTableHeader IDTHeader
	
	IDT := KernelHeap->Allocate('IDT', IDT_SIZE)
	
	IDTHeader.Base := IDT
	IDTHeader.Limit := IDT_SIZE As i16
	
	RemapPIC(0x20, 0x28)
	
	if (USE_INTERRUPT_STUBS) {
		AddHandlerStubs()
	}
	
	AddKernelHandlers()
	SetupDeviceInterrupts()
	
	asm (rax := &IDTHeader) {
		lidt, {rax} As i64*
		sti
	}
}

define void GenericInterrupt(InterruptContext* Context, InterruptRegisters* Registers, i32 InterruptNumber) {
	BochsPrint("UNHANDLED INTERRUPT %i (%x)\n", InterruptNumber, InterruptNumber)
	
	BochsPrint("Interrupt Context: {\n")
	BochsPrint("\tRIP: %x\n", Context->RIP)
	BochsPrint("\tCS: %i (%x)\n", Context->CS, Context->CS)
	BochsPrint("\tFlags: %i (%x, %b)\n", Context->Flags, Context->Flags, Context->Flags)
	BochsPrint("\tRSP: %x\n", Context->RSP)
	BochsPrint("\tSS: %x\n", Context->SS)
	BochsPrint("}\n")
	
	BochsPrint("Registers: {\n")
	BochsPrint("\tRAX: %x\n", Registers->RAX)
	BochsPrint("\tRBX: %x\n", Registers->RBX)
	BochsPrint("\tRCX: %x\n", Registers->RCX)
	BochsPrint("\tRDX: %x\n", Registers->RDX)
	BochsPrint("\tRSP: %x (copy from context)\n", Context->RSP)
	BochsPrint("\tRBP: %x\n", Registers->RBP)
	BochsPrint("\tRSI: %x\n", Registers->RSI)
	BochsPrint("\tRDI: %x\n", Registers->RDI)
	BochsPrint("\tR8 : %x\n", Registers->R8)
	BochsPrint("\tR9 : %x\n", Registers->R9)
	BochsPrint("\tR10: %x\n", Registers->R10)
	BochsPrint("\tR11: %x\n", Registers->R11)
	BochsPrint("\tR12: %x\n", Registers->R12)
	BochsPrint("\tR13: %x\n", Registers->R13)
	BochsPrint("\tR14: %x\n", Registers->R14)
	BochsPrint("\tR15: %x\n", Registers->R15)
	BochsPrint("}\n")
	
	BochsPrint("\nStack dump:\n")
	
	StackFrame* Last := Registers->RBP As StackFrame*
	i32 Index := 1
	
	while (Last) {
		if (Last->LastFrame & 1) {
			StackFrame* Temp := Last->LastFrame - 1
			
			BochsPrint("\tStack[%i] Try catch address = %x\n", Index, Last->ReturnAddress, Temp)
			Index += 1
			
			Last := Temp
		}
		else {
			i64* MaybeMagic := (Last - 0x8) As i64*
			i8** MaybeName := (Last - 0x10) As i8**
			
			if (Debug && *MaybeMagic = 0x12345678) {
				BochsPrint("\tStack[%i] Fn = %s\n", Index, *MaybeName)
			}
			else {
				BochsPrint("\tStack[%i] Fn callsite = %x\n", Index, Last->ReturnAddress, Last->LastFrame)
			}
			
			Index += 1
			
			Last := Last->LastFrame
		}
	}
	
	asm {cli}	
	
	loop {}
}

#Require "./src/kernel/core/InterruptStubs.rlx"
#Require "./src/kernel/core/InterruptHandlers.rlx"
