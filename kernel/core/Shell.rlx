
#Require "./src/utility/ScanCodes.rlx"
#Require "./src/utility/MemoryFIFO.rlx"
#Require "./src/utility/Paths.rlx"
#Require "./src/kernel/user-mode/Execute.rlx"

define void Prompt() {
	Print("(>")
}

i8*[0x20] CommandParameters

i8 RunningProgram := false
MemoryFIFO* RunningProgramInput := null

i32 LastStatus := 0

define EventState OnChildKilled(Process* Child, Event* Fired) {
	LastStatus := Child->ExitCode
	RunningProgram := false
	
	Child->Free()
	Free(Child)
	
	Prompt()
	
	return EventState:CallNextListener
}

FileHandle* CWD := null
i8[40] PWD

define void OnCommand(i8* CommandLine) {
	i32 ParameterStart := 0
	i32 ParameterCount := 0
	
	for (i32 Index := 0, CommandLine[Index] != 0, Index += 1) {
		i8 NextCharacter := CommandLine[Index]
		
		if (NextCharacter = ' ') {
			CommandParameters[ParameterCount] := CommandLine + ParameterStart
			ParameterCount += 1

			CommandLine[Index] := 0
			
			while (CommandLine[Index + 1] = ' ') {
				Index += 1
			}
			
			ParameterStart := Index + 1
		}
	}
	
	CommandParameters[ParameterCount] := CommandLine + ParameterStart
	
	i8* Command := CommandParameters[0]
	i8** Parameters := CommandParameters + 8
	
	if (StringEquals(Command, "status")) {
		Print("$ = %i\n", LastStatus)
	}
	else if (StringEquals(Command, "uptime")) {
		i64 MS := GetUptimeMS()
		i64 Seconds := MS / 1000
		i64 Minutes := Seconds / 60
		Seconds := Seconds % 60
		i64 Hours := Minutes / 60
		Minutes := Minutes % 60
		
		Print(" Uptime [ %ih %im %is | %ims ]\n Ticks [ %i ]\n", Hours, Minutes, Seconds, GetUptimeMS(), GetTickCount())
	}
	else if (StringEquals(Command, "crash")) {
		breakpoint:()
	}
	else if (StringEquals(Command, "mkfile")) {
		i8* Path := CommandParameters[1]
		
		CWD->Open(Path, EXT2_OPEN_CREATE)->Close()
	}
	else if (StringEquals(Command, "mkdirectory")) {
		i8* Path := CommandParameters[1]
		
		CWD->Open(Path, EXT2_OPEN_CREATE_DIRECTORY)->Close()
	}
	else if (StringEquals(Command, "ls")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* Handle := CWD->Open(Path)
		
		if (Handle) {
			DirectoryEntry Entry
			
			loop {
				i32 EntriesRead := Handle->ReadDirectoryEntries(&Entry, 1)
				
				if (EntriesRead != 1) {
					break
				}
				
				FileHandle* EntryHandle := Handle->Open(Entry~>Name)
				
				if (EntryHandle < 0) {
					Print("%s doesn't exist???\n", Entry~>Name)
				}
				else {
					FileStatus EntryInfo
					
					EntryHandle->Status(&EntryInfo)
					
					if (EntryInfo.IsFile()) {
						Print("F\t")
					}
					else {
						Print("D\t")
					}
					
					Print("\t%x\t%s\n", EntryInfo.Size, Entry~>Name)
					
					EntryHandle->Close()
				}
			}
			
			Handle->Close()
		}
	}
	else if (StringEquals(Command, "hex")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* Handle := CWD->Open(Path)
		
		if (Handle = null) {
			Print(" Could not find file '^%s'\n", Path)
		}
		else {
			i8[16] HexBuffer
			
			loop {
				i32 BytesRead := Handle->Read(HexBuffer, 16)
				
				if (BytesRead = 0) {
					Handle->Close()
					
					break
				}
				
				for (i32 Index := 0, Index < BytesRead, Index++) {
					i8 NextByte := HexBuffer[Index]
					
					Print("%c%c ", NumberToCharacter((NextByte >> 4) As i8 & 0xF), NumberToCharacter(NextByte & 0xF))
				}
				
				Print("\n")
			}
		}
	}
	else if (StringEquals(Command, "cat")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* Handle := CWD->Open(Path)
		
		if (Handle = null) {
			Print(" Could not find file '^S1%s^R'\n", Path)
		}
		else {
			void* FileData := KernelPageAllocator->AllocateVirtual(1)
			
			loop {
				i32 BytesRead := Handle->Read(FileData, PAGE_SIZE)
				
				if (BytesRead = 0) {
					Handle->Close()
					
					break
				}
				
				PrintCharacters(FileData, BytesRead)
			}
			
			KernelPageAllocator->FreeVirtual(FileData, 1)
		}
	}
	else if (StringEquals(Command, "reset_time")) {
		asm {cli}
		
		PITWhole := 0
		PITFraction := 0
		TickCount := 0
		
		asm {sti}
	}
	else if (StringEquals(Command, "clear")) {
		Print("\e[H\e[J")
	}
	else if (StringEquals(Command, "colors")) {
		for (i8 Fore := 0, Fore < 16, Fore++) {
			for (i8 Back := 0, Back < 16, Back++) {
				Print("\e[%im\e[%im", TranslateColorToANSI(Fore), TranslateColorToANSI(Back) + 10)
				Print("Test")
			}
			
			Print("^R\n")
		}
	}
	else if (StringEquals(Command, "color")) {
		Print(Parameters[0], ESC)
	}
	else if (StringEquals(Command, "scroll")) {
		if (ParameterCount = 1) {
			i64 LineOffset := AToI(Parameters[0], 10)
			
			Print("^\e[iS", LineOffset)
		}
		else {
			Print("\e[S")
		}
	}
	else if (StringEquals(Command, "peek")) {
		i64 TargetAddress := AToI(Parameters[0], 10)
		i64 AddressValue := *(TargetAddress As i64*)
		
		if (ParameterCount = 2 && StringLength(Parameters[1]) = 1) {
			i8 Size := Parameters[1][0]
			
			if (IsNumeric(Size, 8)) {
				if (Size = '1') {
					AddressValue := AddressValue & 0xFF
				}
				else if (Size = '2') {
					AddressValue := AddressValue & 0xFFFF
				}
				else if (Size = '4') {
					AddressValue := AddressValue & 0xFFFFFFFF
				}
				else if (Size = '8') {
					AddressValue := AddressValue
				}
				else {
					Print(" Unknown size '%c', must be 1/2/4/8\n", Size)
					return
				}
				
				Print(" *(%x As i%i*) = %x\n", TargetAddress, (Size - '0') * 8, AddressValue)
				
				Prompt()
				return
			}
		}
		
		Print(" *(%x) = %x\n", TargetAddress, AddressValue)
	}
	else if (StringEquals(Command, "phys")) {
		PhysicalMemory->Print()
	}
	else if (StringEquals(Command, "virt")) {
		KernelAddressSpace->PrintMeta()
		Print("\n")
		KernelAddressSpace->PrintMappings()
	}
	else if (StringEquals(Command, "heap")) {
		KernelHeap->Print()
	}
	else if (StringEquals(Command, "exec")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* File := CWD->Open(Path)
		
		if !(File) {
			Print(" Could not find file '%s'\n", Path)
		}
		else {
			RunningProgram := true
			
			FileStatus Status
			File->Status(&Status)
			
			i32 FileBlockCount := Status.Size / 1024
			
			if (Status.Size % 1024) {
				FileBlockCount += 1
			}
			
			i32 FilePages := SizeToPageCount(FileBlockCount * 1024)
			
			void* FileData := KernelPageAllocator->AllocateVirtual(FilePages)
			
			File->Read(FileData, Status.Size)
			File->Close()
			
			;Print("Loaded %x byte image @ %x\n", FoundFileNode.FileSizeLow, FileData)
			
			i8* User := "USER=root"
			
			Process* Child := Execute(CWD, FileData, ParameterCount, Parameters, 1, &User)
			
			KernelPageAllocator->FreeVirtual(FileData, FilePages)
			
			Child~>OnKilled->ListenFunction(&OnChildKilled)
			
			return
		}
	}
	else if (StringEquals(Command, "ksyscall")) {
		i64 Value := AToI(CommandParameters[0], 16)
		
		syscall:(1, Value)
	}
	else if (StringEquals(Command, "cd")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* NewCWD := CWD->Open(Path)
		
		if !(NewCWD) {
			Print("Could not find '%s'\n", Path)
			Prompt()
			return
		}
		
		FileStatus NewCWDStatus
		NewCWD->Status(&NewCWDStatus)
		
		if !(NewCWDStatus.IsDirectory()) {
			Print("'%s' is not a directory\n", Path)
		}
		else {
			CWD->Close()
			CWD := NewCWD
			
			i32 PWDLength := StringLength(PWD)
			i32 PathLength := StringLength(Path)
			MoveMemory(&PWD[PWDLength + 1], Path, PathLength)
			PWD[PWDLength] := '/'
			PWD[PWDLength + 1 + PathLength] := 0
			
			i8* NewPWD := ExpandPath(PWD)
			MoveMemory(PWD, NewPWD, StringLength(NewPWD))
			Free(NewPWD)
		}
	}
	else if (StringEquals(Command, "pwd")) {
		FileStatus CWDStatus
		CWD->Status(&CWDStatus)
		
		FileStatus RootStatus
		RootDirectory->Status(&RootStatus)
		
		if (CWDStatus.INodeNumber = RootStatus.INodeNumber) {
			Print("/\n")
		}
		else {
			Print("%s\n", PWD)
		}
	}
	else if (StringEquals(Command, "capture")) {
		i8* Path := CommandParameters[1]
		
		FileHandle* OutputFile := CWD->Open(Path, EXT2_OPEN_CREATE)
		
		if !(OutputFile) {
			Print("Could not open '%s'\n", Path)
			Prompt()
			return
		}
		
		void* ChunkBuffer := KernelPageAllocator->AllocateVirtual(1)
		
		PixelBufferCapture Capture
		Capture.Initialize(NativeScreen->Canvas)
		i32 tot := 0
		
		loop {
			i32 ChunkSize := Capture.NextChunkSize()
			
			tot += ChunkSize
			
			if (ChunkSize = 0) {
				break
			}
			
			Capture.ReadChunk(ChunkBuffer)
			OutputFile->Write(ChunkBuffer, ChunkSize)
		}
		
		Print("Wrote %x bytes\n", tot)
		
		OutputFile->Close()
		
		KernelPageAllocator->FreeVirtual(ChunkBuffer, 1)
	}
	else {
		Print(" Unknown command '%s'\n", Command)
	}
	
	Prompt()
}

#Require "./src/linux/Termios.rlx"

TermiosConfig DefaultTermios {
	InputFlags: LINUX_TERMIOS_INPUT_FLAG_IGNBRK | LINUX_TERMIOS_INPUT_FLAG_IGNPAR,
	OutputFlags: LINUX_TERMIOS_OUTPUT_FLAG_OPOST | LINUX_TERMIOS_OUTPUT_FLAG_ONLCR,
	ControlFlags: LINUX_TERMIOS_CONTROL_FLAG_CS8 | LINUX_TERMIOS_CONTROL_FLAG_B9600 | LINUX_TERMIOS_CONTROL_FLAG_CLOCAL,
	LocalFlags: LINUX_TERMIOS_LOCAL_FLAG_ISIG | LINUX_TERMIOS_LOCAL_FLAG_ICANON | LINUX_TERMIOS_LOCAL_FLAG_ECHO,
	InterruptCharacter: 0xFE As i8,
	EOFCharacter: 0xFF As i8,
	Timeout: 0,
	MinimumReadSize: 1
}

TermiosConfig* ShellConfig := &DefaultTermios

i32 SHELL_NON_BLOCKING   := 0
i32 SHELL_BLOCK_FOR_ONE  := 1
i32 SHELL_BLOCK_FOR_LINE := 2

i32 ShellInputMode := SHELL_BLOCK_FOR_LINE

i8 ShellShouldEcho := true

define void ShellSetMode(TermiosConfig* Config) {
	MoveMemory(ShellConfig, Config, #TermiosConfig)
}
define void ShellGetMode(TermiosConfig* Out) {
	MoveMemory(Out, ShellConfig, #TermiosConfig)
}

i8[0x100] RawKeyboardBuffer
MemoryFIFO _KeyboardBuffer {
	Buffer: RawKeyboardBuffer,
	Size: 0x100
}
MemoryFIFO* KeyboardBuffer := &_KeyboardBuffer

i8[0x100] RawInputBuffer
MemoryFIFO _InputBuffer {
	Buffer: RawInputBuffer,
	Size: 0x100
}
MemoryFIFO* InputBuffer := &_InputBuffer

i8[100] ShellInputLine
i32 ShellInputIndex := 0

i8 ControlHeld := false

define EventState ShellOnKey(KeyEventInfo* KeyEvent, Event* Fired) {
	;Info("%x %x\n", ScanCode, ASCIICode)
	
	i32 ScanCode := KeyEvent->ScanCode
	i32 ASCIICode := KeyEvent->ASCIICode
	
	if (ScanCode = SCANCODE_CONTROL_DOWN) {
		ControlHeld := true
	}
	else if (ScanCode = SCANCODE_CONTROL_UP) {
		ControlHeld := false
	}
	else if (ScanCode = SCANCODE_ENTER_DOWN) {
		if !(RunningProgram) {
			; TODO: figure out how to let a program tell us to do this or not
			;  over termios
			
			i8 EOL := ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VEOL]
			
			KeyboardBuffer->Write(&EOL, 1)
		}
		
		i8 EOL2 := ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VEOL2]
		
		if (EOL2) {
			KeyboardBuffer->Write(&EOL2, 1)
		}
	}
	else if (ScanCode = SCANCODE_BACKSPACE_DOWN) {
		KeyboardBuffer->Write(&ASCII_BACK, 1)
	}
	else if (ScanCode = SCANCODE_INSERT) {
		KeyboardBuffer->Write(ESC, 2)
		KeyboardBuffer->Write("2~", 2)
	}
	else {
		if (ControlHeld) {
			if (ASCIICode = 'c') {
				; Somehow, this works in kernel mode even when I check CurrentProcess
				;  Just don't press in kernel mode.
				
				if (ShellConfig->LocalFlags & LINUX_TERMIOS_LOCAL_FLAG_ISIG) {
					CurrentProcess->QueueSignal(LINUX_SIGNAL_NUMBER_INT, 0, 0)
				}
				else {
					KeyboardBuffer->Write(ShellConfig~>InterruptCharacter, 1)
				}
				
				return EventState:CallNextListener
			}
			else if (ASCIICode = 'q') {
				ShellInputIndex := 0
				InputBuffer->Clear()
				
				return EventState:CallNextListener
			}
			else if (ASCIICode = 'd') {
				KeyboardBuffer->Write(ShellConfig~>EOFCharacter, 1)
				
				return EventState:CallNextListener
			}
			else {
				i8 Escape := 0x1B
				
				KeyboardBuffer->Write(&Escape, 1)
				KeyboardBuffer->Write("[4", 2)
			}
		}
		
		if (ScanCode = SCANCODE_UP_ARROW) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'A'
		}
		else if (ScanCode = SCANCODE_DOWN_ARROW) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'B'
		}
		else if (ScanCode = SCANCODE_RIGHT_ARROW) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'C'
		}
		else if (ScanCode = SCANCODE_LEFT_ARROW) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'D'
		}
		else if (ScanCode = SCANCODE_END) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'F'
		}
		else if (ScanCode = SCANCODE_HOME) {
			KeyboardBuffer->Write(ESC, 2)
			ASCIICode := 'H'
		}
		
		KeyboardBuffer->Write(&ASCIICode, 1)
	}
	
	i32 Size := KeyboardBuffer->Available()
	
	i8 BlockForLine := (ShellConfig->LocalFlags & LINUX_TERMIOS_LOCAL_FLAG_ICANON) != 0
	i8 ShouldEcho := (ShellConfig->LocalFlags & LINUX_TERMIOS_LOCAL_FLAG_ECHO) != 0
	
	if (Size) {
		KeyboardBuffer->Read(&ShellInputLine[ShellInputIndex], Size)
		
		if (RunningProgram && !BlockForLine) {
			if (ShouldEcho) {
				Print("%s", &ShellInputLine[ShellInputIndex])
			}
			
			InputBuffer->Write(&ShellInputLine[ShellInputIndex], Size)
			
			return EventState:CallNextListener
		}
		
		i16 Tail := *(&ShellInputLine[ShellInputIndex + Size - 2] As i16*)
		i16 LineEnding := 0x0A0D
		
		ShellInputLine[ShellInputIndex + Size] := 0
		
		if (ShellInputLine[ShellInputIndex] = ASCII_BACK) {
			if (ShellInputIndex != 0) {
				if (ShouldEcho) {
					Print("%s", &ShellInputLine[ShellInputIndex])
				}
				
				if (RunningProgram && !BlockForLine) {
					InputBuffer->Write(&ShellInputLine[ShellInputIndex], Size)
				}
				
				ShellInputIndex -= 1
			}
		}
		else {
			if (ShouldEcho) {
				Print("%s", &ShellInputLine[ShellInputIndex])
			}
			
			if (RunningProgram && !BlockForLine) {
				InputBuffer->Write(&ShellInputLine[ShellInputIndex], Size)
			}
			
			ShellInputIndex += Size
		}
		
		if (RunningProgram) {
			Tail := ((Tail >> 8) & 0xFF) As i8
			LineEnding := ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VEOL2]
		}
		
		if (Tail = LineEnding) {
			if (RunningProgram) {
				ShellInputLine[ShellInputIndex - 1] := 0
			}
			else {
				ShellInputLine[ShellInputIndex - 2] := 0
			}
			
			if (RunningProgram && BlockForLine) {
				ShellInputLine[ShellInputIndex - 1] := 0x0A
				ShellInputLine[ShellInputIndex] := 0
				
				InputBuffer->Write(ShellInputLine, ShellInputIndex)
				ShellInputIndex := 0
			}
			else {
				InputBuffer->Clear()
				ShellInputIndex := 0
				OnCommand(ShellInputLine)
			}
		}
	}
	
	return EventState:CallNextListener
}

define void ShellPleaseSendForMe(i8* Data, i32 Size) {
	;Info("%s", Data)
	InputBuffer->Write(Data, Size)
}

define i32 ShellPollForInput(i32 Timeout) {
	i64 End := GetUptimeMS() + Timeout
	
	while (GetUptimeMS() <= End) {
		if (InputBuffer->Available()) {
			return InputBuffer->Available()
		}
	}
	
	return 0
}

define i32 ShellGatherInput(i8* Destination, i32 Size) {
	;Print("GatherInput(%x, %i)", Destination, Size)
	
	i8 BlockForLine := (ShellConfig->LocalFlags & LINUX_TERMIOS_LOCAL_FLAG_ICANON) != 0
	
	if (BlockForLine) {
		while (InputBuffer->Available() < ShellConfig->MinimumReadSize) { SchedulerYield() }
	}
	
	i32 Available := InputBuffer->Available()
	
	if (Available < Size) {
		Size := Available
	}
	
	InputBuffer->Read(Destination, Size)
	
	if (DEBUG_SYS_WRITE) {
		Info("%hexdump", Destination, Size)
	}
	
	return Size
}

define void SetupShell() {
	OnKeyEvent->ListenFunction(&ShellOnKey)
	
	ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VERASE] := ASCII_BACK As i8
	ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VEOL  ] := 0xD
	ShellConfig->ControlCharacters[LINUX_TERMIOS_CHARACTER_VEOL2 ] := 0xA
	
	CWD := RootDirectory
	
	Prompt()
}