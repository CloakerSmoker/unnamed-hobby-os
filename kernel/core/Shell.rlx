
#Require "./src/utility/ScanCodes.rlx"
#Require "./src/utility/MemoryFIFO.rlx"
#Require "./src/kernel/user-mode/Execute.rlx"

define void Prompt() {
	Print("(>")
}

i8*[0x20] CommandParameters

i8 RunningProgram := false
MemoryFIFO* RunningProgramInput := null

define void OnCommand(i8* CommandLine) {
	i32 ParameterStart := 0
	i32 ParameterCount := 0
	
	for (i32 Index := 0, CommandLine[Index] != 0, Index += 1) {
		i8 NextCharacter := CommandLine[Index]
		
		if (NextCharacter = ' ') {
			CommandParameters[ParameterCount] := CommandLine + ParameterStart
			ParameterCount += 1

			CommandLine[Index] := 0
			
			while (CommandLine[Index + 1] = ' ') {
				Index += 1
			}
			
			ParameterStart := Index + 1
		}
	}
	
	CommandParameters[ParameterCount] := CommandLine + ParameterStart
	
	i8* Command := CommandParameters[0]
	i8** Parameters := CommandParameters + 8
	
	if (StringEquals(Command, "uptime")) {
		i64 MS := GetUptimeMS()
		i64 Seconds := MS / 1000
		i64 Minutes := Seconds / 60
		Seconds := Seconds % 60
		i64 Hours := Minutes / 60
		Minutes := Minutes % 60
		
		Print(" Uptime [ %ih %im %is | %ims ]\n Ticks [ %i ]\n", Hours, Minutes, Seconds, GetUptimeMS(), GetTickCount())
	}
	else if (StringEquals(Command, "crash")) {
		breakpoint:()
	}
	else if (StringEquals(Command, "ls")) {
		i32 NextEntryOffset := FS->StartWalkDirectory(RootINode)
		
		loop {
			DirectoryEntry* NextEntry := FS->WalkDirectoryNext(RootINode, &NextEntryOffset)
			
			if (NextEntry = null) {
				break
			}
			
			INode* NextNode := FS->ReadINode(NextEntry->INode)
			
			if (NextNode->IsDirectory()) {
				Print(" D ")
			}
			else {
				Print(" F ")
			}
			
			Print("%x 	%x 	%s\n", NextEntry->INode, NextNode->FileSizeLow, NextEntry~>Name)
		}
	}
	else if (StringEquals(Command, "mkfile")) {
		i8* Path := CommandParameters[1]
		
		Ext2Close(FS, Ext2Open(FS, Path, OPEN_CREATE))
	}
	else if (StringEquals(Command, "mkdirectory")) {
		i8* Path := CommandParameters[1]
		
		Ext2Close(FS, Ext2Open(FS, Path, OPEN_CREATE_DIRECTORY))
	}
	else if (StringEquals(Command, "nls")) {
		i8* Path := CommandParameters[1]
		
		i64 Handle := Ext2Open(FS, Path)
		
		if (Handle) {
			Ext2DirectoryEntry Entry
			
			loop {
				i32 EntriesRead := 0
				Handle := Ext2ReadDirectoryEntries(FS, Handle, &Entry, 1, &EntriesRead)
				
				if (EntriesRead != 1) {
					break
				}
				
				i64 EntryHandle := Ext2Open(FS, Handle, Entry~>Name)
				
				if (EntryHandle < 0) {
					Print("%s doesn't exist???\n", Entry~>Name)
				}
				else {
					Ext2Status EntryInfo
					
					Ext2GetStatus(FS, EntryHandle, &EntryInfo)
					
					if (EntryInfo.IsFile) {
						Print("F\t")
					}
					else {
						Print("D\t")
					}
					
					Print("%s\n", Entry~>Name)
					
					Ext2Close(FS, EntryHandle)
				}
			}
			
			Ext2Close(FS, Handle)
			
		}
		
	}
	else if (StringEquals(Command, "hex")) {
		i8* Path := CommandParameters[1]
		
		i64 Handle := Ext2Open(FS, Path)
		
		if (Handle = null) {
			Print(" Could not find file '^%s'\n", Path)
		}
		else {
			i8[16] HexBuffer
			
			loop {
				i32 BytesRead := 0
				
				Handle := Ext2Read(FS, Handle, HexBuffer, 16, &BytesRead)
				
				if (BytesRead = 0) {
					Ext2Close(FS, Handle)
					
					break
				}
				
				for (i32 Index := 0, Index < BytesRead, Index++) {
					i8 NextByte := HexBuffer[Index]
					
					Print("%c%c ", NumberToCharacter((NextByte >> 4) As i8 & 0xF), NumberToCharacter(NextByte & 0xF))
				}
				
				Print("\n")
			}
		}
	}
	else if (StringEquals(Command, "cat")) {
		i8* Path := CommandParameters[1]
		
		DirectoryEntry* FoundFileEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
		
		if (FoundFileEntry = null || !FoundFileEntry->IsFile()) {
			Print(" Could not find file '^%s'\n", Path)
		}
		else {
			INode FoundFileNode
			
			MoveMemory(&FoundFileNode, FS->ReadINode(FoundFileEntry->INode), #INode)
			
			i32 FileBlockCount := FoundFileNode.FileSizeLow / 1024
			
			if (FoundFileNode.FileSizeLow % 1024) {
				FileBlockCount += 1
			}
			
			for (i32 FileBlockIndex := 0, FileBlockIndex < FileBlockCount, FileBlockIndex += 1) {
				i32 FileDataBlock := FS->FindINodeDataBlock(&FoundFileNode, FileBlockIndex, false)
				Print("%s", FS->ReadBlock(FileDataBlock))
			}
			
			Print("\n Done, %i blocks printed\n", FileBlockCount)
		}
	}
	else if (StringEquals(Command, "reset_time")) {
		asm {cli}
		
		PITWhole := 0
		PITFraction := 0
		TickCount := 0
		
		asm {sti}
	}
	else if (StringEquals(Command, "clear")) {
		Print("%sc", ESC)
	}
	else if (StringEquals(Command, "colors")) {
		for (i8 Fore := 0, Fore < 16, Fore++) {
			for (i8 Back := 0, Back < 16, Back++) {
				Print("^E%im^E%im", TranslateColorToANSI(Fore), TranslateColorToANSI(Back) + 10)
				Print("Test")
			}
			
			Print("^R\n")
		}
	}
	else if (StringEquals(Command, "color")) {
		Print(Parameters[0], ESC)
	}
	else if (StringEquals(Command, "scroll")) {
		if (ParameterCount = 1) {
			i64 LineOffset := AToI(Parameters[0], 10)
			
			Print("^E%iS", LineOffset)
		}
		else {
			Print("^ES")
		}
	}
	else if (StringEquals(Command, "peek")) {
		i64 TargetAddress := AToI(Parameters[0], 10)
		i64 AddressValue := *(TargetAddress As i64*)
		
		if (ParameterCount = 2 && StringLength(Parameters[1]) = 1) {
			i8 Size := Parameters[1][0]
			
			if (IsNumeric(Size, 8)) {
				if (Size = '1') {
					AddressValue := AddressValue & 0xFF
				}
				else if (Size = '2') {
					AddressValue := AddressValue & 0xFFFF
				}
				else if (Size = '4') {
					AddressValue := AddressValue & 0xFFFFFFFF
				}
				else if (Size = '8') {
					AddressValue := AddressValue
				}
				else {
					Print(" Unknown size '%c', must be 1/2/4/8\n", Size)
					return
				}
				
				Print(" *(%x As i%i*) = %x\n", TargetAddress, (Size - '0') * 8, AddressValue)
				
				Prompt()
				return
			}
		}
		
		Print(" *(%x) = %x\n", TargetAddress, AddressValue)
	}
	else if (StringEquals(Command, "phys")) {
		PhysicalMemory->Print()
	}
	else if (StringEquals(Command, "virt")) {
		KernelAddressSpace->PrintMeta()
		Print("\n")
		KernelAddressSpace->PrintMappings()
	}
	else if (StringEquals(Command, "heap")) {
		KernelHeap->Print()
	}
	else if (StringEquals(Command, "exec")) {
		i8* Path := CommandParameters[1]
		
		DirectoryEntry* FoundFileEntry := FS->FindDirectoryEntryByPath(RootINode, Path)
		
		if (FoundFileEntry = null || !FoundFileEntry->IsFile()) {
			Print(" Could not find file '^%s'\n", Path)
		}
		else {
			RunningProgram := true
			
			INode FoundFileNode
			
			MoveMemory(&FoundFileNode, FS->ReadINode(FoundFileEntry->INode), #INode)
			
			i32 FileBlockCount := FoundFileNode.FileSizeLow / 1024
			
			if (FoundFileNode.FileSizeLow % 1024) {
				FileBlockCount += 1
			}
			
			void* FileData := KernelHeap->Allocate('EXEC', FileBlockCount * 1024)
			
			for (i32 FileBlockIndex := 0, FileBlockIndex < FileBlockCount, FileBlockIndex += 1) {
				i32 FileDataBlock := FS->FindINodeDataBlock(&FoundFileNode, FileBlockIndex, false)
				
				MoveMemory(FileData + (FileBlockIndex * 1024), FS->ReadBlock(FileDataBlock), 1024)
			}
			
			Print("Loaded %x byte image @ %x\n", FoundFileNode.FileSizeLow, FileData)
			
			i32 Result := Execute(FileData, 0, NULL_ARGUMENTS, 0, NULL_ENVIRONMENT)
			
			Print("Program exited with code %i\n", Result)
			
			RunningProgram := false
		}
	}
	else if (StringEquals(Command, "ksyscall")) {
		i64 Value := AToI(CommandParameters[0], 16)
		
		syscall:(1, Value)
	}
	else {
		Print(" Unknown command '%s'\n", Command)
	}
	
	Prompt()
}

i8[0x100] RawKeyboardBuffer
MemoryFIFO _KeyboardBuffer {
	Buffer: RawKeyboardBuffer,
	Size: 0x100
}
MemoryFIFO* KeyboardBuffer := &_KeyboardBuffer

define void ShellOnKey(i16 ScanCode, i8 ASCIICode) {
	if (ScanCode = SCANCODE_ENTER_DOWN) {
		KeyboardBuffer->Write("\n", 2)
	}
	else if (ScanCode = SCANCODE_BACKSPACE_DOWN) {
		KeyboardBuffer->Write(&ASCII_BACK, 1)
	}
	else {
		KeyboardBuffer->Write(&ASCIICode, 1)
	}
}

define void ShellGatherInput(i8* Destination, i32 Size) {
	;Print("GatherInput(%x, %i)", Destination, Size)
	
	while (KeyboardBuffer->Available() < Size) {}
	
	KeyboardBuffer->Read(Destination, Size)
}

define void SetupShell() {
	SetOnKeyCallback(&ShellOnKey)
}

i8[100] CommandLine

define void Shell() {
	i32 Index := 0
	
	loop {
		i32 Size := KeyboardBuffer->Available()
		
		if (Size) {
			if (RunningProgram) {
				Index := 0
			}
			else {
				KeyboardBuffer->Read(&CommandLine[Index], Size)
				
				i16 Tail := *(&CommandLine[Index + Size - 2] As i16*)
				i16 LineEnding := 0x0A0D
				
				CommandLine[Index + Size] := 0
				
				if (CommandLine[Index] = ASCII_BACK) {
					if (Index != 0) {
						Print("%s", &CommandLine[Index])
						Index -= 1
					}
				}
				else {
					Print("%s", &CommandLine[Index])
					Index += Size
				}
				
				;Print("(%x %x)", Tail, LineEnding)
				
				if (Tail = LineEnding) {
					CommandLine[Index - 2] := 0
					
					OnCommand(CommandLine)
					
					Index := 0
				}
			}
		}
	}
	
}