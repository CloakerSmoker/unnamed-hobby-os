

#Require "./src/kernel/Config.rlx"

#Require "$/MemoryBase.rlx"
#Require "$/StringBase.rlx"

declare void TerminateAfterUnhandledException(i64)

#Require "$/ExceptionBase.rlx"

#Require "./src/utility/x64.rlx"

declare void PrintCharacter(i8)

#Require "./src/utility/Print.rlx"
#Require "./src/utility/PrintHelpers.rlx"

#Require "./src/utility/DebugOutput.rlx"

declare void* KernelHeapAllocate(i64, i32)
declare void* KernelHeapExtendAllocation(void*, i32)
declare void KernelHeapFree(void*)

#Require "./src/kernel/graphics/Font.rlx"

#Require "./src/kernel/graphics/Screen.rlx"

#Require "./src/kernel/core/Paging.rlx"
#Require "./src/kernel/core/PageHeap.rlx"
#Require "./src/kernel/core/Heap.rlx"

Heap RawKernelHeap
Heap* KernelHeap := &RawKernelHeap

PageHeap* KernelPageAllocator := null

define void* KernelHeapAllocate(i64 Tag, i32 Size) {
	return KernelHeap->Allocate(Tag, Size)
}
define void* KernelHeapExtendAllocation(void* Memory, i32 Size) {
	return KernelHeap->Extend(Memory, Size)
}
define void KernelHeapFree(void* Memory) {
	KernelHeap->Free(Memory)
}

struct KernelInfo {
	i32 Size
	i32 PageCount
	
	void* InterruptStack
	void* SystemCallStack
	
	i64 FrameBufferPages
	
	i64 Pages
	i64 PageFramesPages
	i64 StackPages
	i64 HeapPages
	i64 KernelPages
	i64 UserPages
}

KernelInfo RawKernelInfo

KernelInfo* Kernel := &RawKernelInfo

#Require "./src/kernel/core/Descriptors.rlx"

#Require "./src/utility/Memory.rlx"
#Require "./src/utility/Exception.rlx"

declare void SchedulerYield()

#Require "./src/kernel/core/Interrupts.rlx"
#Require "./src/kernel/core/Devices.rlx"

#Require "./src/kernel/multitasking/Tasks.rlx"
#Require "./src/kernel/multitasking/Scheduler.rlx"
#Require "./src/kernel/multitasking/Timers.rlx"

#Require "./src/kernel/graphics/LoadFON.rlx"
#Require "./src/kernel/graphics/Terminal.rlx"

define void PrintCharacter(i8 Character) {
	KernelTerminal->Print(&Character, 1)
}

Ext2* FS := null
INode* RootINode := null

#Require "./src/drivers/block-device/BlockDevice.rlx"
#Require "./src/drivers/block-device/ATABlockDevice.rlx"
#Require "./src/drivers/block-device/GPTBlockDevice.rlx"

#Require "./src/drivers/Ext2Interface.rlx"

#Require "./src/kernel/user-mode/Process.rlx"
#Require "./src/kernel/core/SystemCalls.rlx"

#Require "./src/kernel/core/Shell.rlx"

#Require "./src/drivers/PCI/PCI.rlx"

declare void BootStrap()

define void RawBootStrap(void* Stack) asm {
	mov, rsp, rdi
	mov, rbp, 0
	
	call, @BootStrap

stop:
	jmp, stop
}



define void Main(void* CR3, i64 PhysicalFrameBuffer, i32 MaxKernelAddress) {
	Info("Main, FrameBuffer @ %x\n", PhysicalFrameBuffer)
	
	Kernel->FrameBufferPages := PhysicalFrameBuffer
	
	;PhysicalMemory->AddReserved(0, 0x10_0000) ; < 1mb, bootloader reserved
	;PhysicalMemory->Add(0x10_0000, 0x350_0000) ; free memory
	
	PhysicalMemory := PageHeap:Adopt(0x10_0000, 0x500)
	
	i32 KernelSize := MaxKernelAddress - (ADDRESS_OF_KERNEL As i32)
	
	Kernel->Size := KernelSize
	Kernel->PageCount := SizeToPageCount(KernelSize) + 1
	
	i64 KernelLoadPages  := PhysicalMemory->Reserve(0x20_0000, Kernel->PageCount) ; Reserve the memory the kernel lives in
	i64 PageFramesPages  := PhysicalMemory->Allocate(PAGE_COUNT_FOR_1MB)
	i64 KernelStackPages := PhysicalMemory->Allocate(40)
	i64 KernelHeapPages  := PhysicalMemory->Allocate(PAGE_COUNT_FOR_2MB)
	i64 KernelPages      := PhysicalMemory->Allocate(NUMBER_OF_KERNEL_PAGES)
	i64 UserPages        := PhysicalMemory->Allocate(1)
	
	Kernel->Pages           := KernelLoadPages
	Kernel->PageFramesPages := PageFramesPages
	Kernel->StackPages      := KernelStackPages
	Kernel->HeapPages       := KernelHeapPages
	Kernel->KernelPages     := KernelPages
	Kernel->UserPages       := UserPages
	
	AddressSpaceManager* BootStrapAddressSpace := 0x14_0000 As void*
	
	BootStrapAddressSpace->Initialize(0x15_0000 As void*, 0x15_0000, 0x40)
	
	BootStrapAddressSpace->MapRange(0x10_0000 As void*, 0x100, 0x10)
	BootStrapAddressSpace->MapRange(0x15_0000 As void*, 0x150, 0x45)
	BootStrapAddressSpace->MapRange(ADDRESS_OF_KERNEL, KernelLoadPages / PAGE_SIZE, Kernel->PageCount)
	
	BootStrapAddressSpace->MapRange(ADDRESS_OF_PAGE_FRAMES, PageFramesPages / PAGE_SIZE, PAGE_COUNT_FOR_1MB)
	BootStrapAddressSpace->MapRange(ADDRESS_OF_KERNEL_STACK, KernelStackPages / PAGE_SIZE, 40)
	
	BootStrapAddressSpace->Takeover(&RawBootStrap, ADDRESS_OF_KERNEL_STACK + (PAGE_SIZE * 40))
}

declare void MainContinuation()

define void RawMainContinuation(void* Stack) asm {
	mov, rsp, rdi
	mov, rbp, 0
	
	call, @MainContinuation

stop:
	jmp, stop
}

define void BootStrap() {
	Info("Switched\n")
	
	KernelAddressSpace->Initialize(ADDRESS_OF_PAGE_FRAMES, Kernel->PageFramesPages, BYTES_IN_1MB / PAGE_SIZE)
	
	KernelAddressSpace->MapRange(0x10_0000 As void*, 0x10_0000 / PAGE_SIZE, 0x10)
	KernelAddressSpace->MapRange(0x20_0000 As void*, 0x20_0000 / PAGE_SIZE, Kernel->PageCount)
	
	KernelAddressSpace->MapRange(ADDRESS_OF_PAGE_FRAMES, Kernel->PageFramesPages / PAGE_SIZE, PAGE_COUNT_FOR_1MB)
	KernelAddressSpace->MapRange(ADDRESS_OF_KERNEL_STACK, Kernel->StackPages / PAGE_SIZE, 40)
	KernelAddressSpace->MapRange(ADDRESS_OF_KERNEL_HEAP, Kernel->HeapPages / PAGE_SIZE, BYTES_IN_2MB / PAGE_SIZE)
	
	KernelAddressSpace->MapRange(ADDRESS_OF_KERNEL_PAGES, Kernel->KernelPages / PAGE_SIZE, NUMBER_OF_KERNEL_PAGES)
	
	KernelAddressSpace->MapRange(ADDRESS_OF_USER_PAGES  , Kernel->UserPages   / PAGE_SIZE, 1)
	
	KernelAddressSpace->Takeover(&RawMainContinuation, ADDRESS_OF_KERNEL_STACK + (PAGE_SIZE * 40))
}

ATADevice* FirstDisk := null

define void VisitPCIFunction(i32 Bus, i32 Slot, i32 Function) {
	Print("%x/%x/%x: ", Bus, Slot, Function)
	
	i32 Class := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_CLASS_CODE)
	i32 SubClass := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_SUBCLASS)
	i32 Interface := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_INTERFACE)
	
	PCIClassCodes->Print(Class, SubClass, Interface)
	
	Print("\n")
	
	if (Class = PCI_CLASS_CODE_MASS_STORAGE_CONTROLLER 
	 && SubClass = PCI_SUBCLASS_IDE_INTERFACE) {
		i32 PrimaryIOBase      := IDE_LEGACY_PRIMARY_IO_BASE
		i32 PrimaryControlBase := IDE_LEGACY_PRIMARY_CONTROL_BASE
		
		if (Interface & PCI_IDE_INTERFACE_PRIMARY_PCI_NATIVE) {
			PrimaryIOBase      := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_BASE_ADDRESS_0)
			PrimaryControlBase := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_BASE_ADDRESS_1)
		}
		
		i32 SecondaryIOBase      := IDE_LEGACY_SECONDARY_IO_BASE
		i32 SecondaryControlBase := IDE_LEGACY_SECONDARY_CONTROL_BASE
		
		if (Interface & PCI_IDE_INTERFACE_SECONDARY_PCI_NATIVE) {
			SecondaryIOBase      := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_BASE_ADDRESS_2)
			SecondaryControlBase := PCIReadConfig(Bus, Slot, Function, PCI_HEADER_BASE_ADDRESS_3)
		}
		
		DiskController->Initialize(PrimaryIOBase, PrimaryControlBase, SecondaryIOBase, SecondaryControlBase)
		
		Print("Found IDE controller\n")
		Print("\tPCI address: %x/%x/%x\n", Bus, Slot, Function)
		Print("\tports: %x-%x %x-%x\n", PrimaryIOBase, PrimaryControlBase, SecondaryIOBase, SecondaryControlBase)
	}
}

Task _KernelSetupTask
Task* KernelSetupTask := &_KernelSetupTask

define void MainContinuation() {
	CurrentTask := KernelSetupTask
	
	DisableInterrupts()
	
	Info("Paging initialized, AddressSpaceManager in control\n")
	
	KernelPageAllocator := PageHeap:Adopt(ADDRESS_OF_KERNEL_PAGES As i64, NUMBER_OF_KERNEL_PAGES)
	
	Info("Built kernel virtual allocator\n")
	
	LoadBootFont()
	
	Info("Loaded font\n")
	
	; Remap the next available `FRAMEBUFFER_SIZE` bytes of virtual memory to 0xE000_0000 (or wherever int10 says)
	i32 FrameBufferPageCount := SizeToPageCount(FRAMEBUFFER_SIZE)
	KernelAddressSpace->MapRange(ADDRESS_OF_FRAME_BUFFER, Kernel->FrameBufferPages / PAGE_SIZE, FrameBufferPageCount)
	
	Info("Mapped the framebuffer\n")
	
	;NativeScreen->Adopt(FrameBuffer, SCREEN_WIDTH, SCREEN_HEIGHT, BYTES_PER_PIXEL, 0, 0x00_00_00)
	NativeScreen->Adopt(ADDRESS_OF_FRAME_BUFFER, RGB32, SCREEN_WIDTH, SCREEN_HEIGHT, 0xFF_FF_FF)
	NativeScreen->Clear()
	
	BootFont->Draw(NativeScreen->Canvas, 0x00_00_00, 0xFF_FF_FF, 0, 0, 'A')
	
	Info("Adopted screen\n")
	
	KernelTerminal->Adopt(NativeScreen, BootFont, 0xFF_FF_FF, 0x00_00_00)
	;KernelTerminal->Adopt(NativeScreen, BootFont, 0x00_00_00, 0xFF_FF_FF)
	
	KernelTerminal->Clear()
	
	KernelTerminal->PrintLine("BOOT: Screen *probably* works")
	
	KernelAddressSpace->Map(0 As void*, 0, PAGE_NOT_PRESENT)
	
	KernelTerminal->PrintLine("BOOT: Unmapped page 0")
	
	SetCR4(GetCR4() | CR4_ENABLE_FS_GS_BASE)
	
	KernelHeap->Initialize(ADDRESS_OF_KERNEL_HEAP, BYTES_IN_2MB)
	
	KernelTerminal->PrintLine("BOOT: Kernel Heap Initialized")
	
	void* InterruptStackTop    := ADDRESS_OF_KERNEL_STACK + (10 * PAGE_SIZE)
	void* InterruptStackBottom := ADDRESS_OF_KERNEL_STACK
	
	void* SystemCallStackTop    := ADDRESS_OF_KERNEL_STACK + (20 * PAGE_SIZE)
	void* SystemCallStackBottom := ADDRESS_OF_KERNEL_STACK + (11 * PAGE_SIZE)
	
	KernelAddressSpace->UnmapRange(InterruptStackBottom , 1)
	KernelAddressSpace->UnmapRange(SystemCallStackBottom, 1)
	
	Kernel->InterruptStack  := InterruptStackTop
	Kernel->SystemCallStack := SystemCallStackTop
	
	Print("Kernel {\n")
	Print("\tInterruptStack  Top   : %x,\n", InterruptStackTop)
	Print("\tInterruptStack  Guard : %x,\n", InterruptStackBottom)
	Print("\tSystemCallStack Top   : %x,\n", SystemCallStackTop)
	Print("\tSystemCallStack Guard : %x\n" , SystemCallStackBottom)
	Print("}\n")
	
	SetupGDT()
	
	KernelTerminal->PrintLine("BOOT: Setup GDT and TSS")
	
	SetupInterrupts()
	
	SetPITMode(PIT_100HZ)
	SetupTimers()
	
	Print("Set up PIT/timers\n")
	
	EnableInterrupts()
	
	SetupSystemCalls()
	
	SetupExecute()
	
	;Print("Back in kernel code\n\n")
	
	DiskController := KernelHeap->Allocate('IDE', #IDEDiskController)
	
	PCIEnumerateBusses(&VisitPCIFunction)
	
	if !(DiskController->IsInitialized) {
		Print("Didn't find disk controller, hanging\n")
		
		loop {asm {emit, 0xF4}}
	}
	
	DiskController->DetectDevices()
	
	i32 FirstDiskIndex := DiskController->FindFirstDiskIndex()
	
	if (FirstDiskIndex < -1) {
		Print("Didn't find any disks, hanging\n")
		
		loop {asm {emit, 0xF4}}
	}
	
	for (i32 Index := 0, Index < 4, Index++) {
		ATADevice* Disk := DiskController->Disk(Index)
		
		Print("\thd%c - ", 'a' + Index)
		
		if (Disk) {
			Print("%s:%s, %x blocks\n", Disk->Model, Disk->Serial, Disk->MaxLBA)
		}
		else {
			Print("not present\n")
		}
	}
	
	KernelTerminal->PrintLine("BOOT: Mounting disk")
	
	i8[2] DiskIndexString
	
	DiskIndexString[0] := ('0' + FirstDiskIndex) As i8
	DiskIndexString[1] := 0
	
	BlockDevice* BootDisk := NewBlockDevice(null, &ATABlockDevicePrototype, DiskIndexString)
	BlockDevice* OSPatition := NewBlockDevice(BootDisk, &GPTPartitionBlockDevicePrototype, "1")
	
	;BlockDevice* FSDevice := InstantiateBlockDeviceChainFromPath("ATAPIO(0)>GPT(1)")
	
	Print("Device = %x\n", OSPatition)
	
	void* Ext2Scratch := KernelPageAllocator->AllocateVirtual(2)
	
	;void* SB := KernelHeapAllocate('SB', 2048)
	;void* TI := KernelHeapAllocate('TI', 1024)
	;void* TB1 := KernelHeapAllocate('TB1', 1024)
	;void* TB2 := KernelHeapAllocate('TB2', 1024)
	;void* BMP := KernelHeapAllocate('BMP', 1024)
	
	FS := KernelHeapAllocate('RootFS', #Ext2)
	FS->Device := OSPatition
	
	FS->Initialize(Ext2Scratch, Ext2Scratch + 0x800, Ext2Scratch + 0xC00, Ext2Scratch + 0x1000, Ext2Scratch + 0x1400)
	
	RootINode := CloneMemory(FS->ReadINode(2), #INode)
	
	
	
	
	;i64 FontHandle := Ext2Open(FS, "fanta.fon")
	;
	;FontHandle := Ext2Seek(FS, FontHandle, 0, SEEK_RELATIVE_END)
	;i32 FontSize := Ext2Tell(FS, FontHandle) As i32
	;FontHandle := Ext2Seek(FS, FontHandle, 0, SEEK_SET)
	;
	;void* FontBuffer := Alloc(FontSize)
	;
	;i32 BytesRead := 0
	;FontHandle := Ext2Read(FS, FontHandle, FontBuffer, FontSize, &BytesRead)
	;
	;Ext2Close(FS, FontHandle)
	;
	;_Font* Loaded := LoadFON(FontBuffer, FontSize)
	
	;BootFont->Width := 12
	
	;Info("A @ %x\n", BootFont->Glyphs['A']->Render)
	;
	;BootFont->Draw(NativeScreen->Canvas, 0x00_00_00, 0xFF_FF_FF, 0, 0, 'A')
	
	KernelTerminal->SetCursorTimer()
	
	SetupShell()
	
	StartScheduler()
}