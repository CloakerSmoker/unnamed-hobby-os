#ImageBase 0x10_0000

#Require "./src/utility/Generic.rlx"
#Require "./src/utility/x64.rlx"
#Require "./src/utility/String.rlx"

i8 USE_BOCHS_PORT_HACK := true

#Require "./src/drivers/Bochs.rlx"

declare void* KernelHeapAllocate(i64, i32)
declare void* KernelHeapExtendAllocation(void*, i32)
declare void KernelHeapFree(void*)

#Require "./src/kernel/graphics/Font.rlx"
#Require "./src/kernel/graphics/Screen.rlx"

#Require "./src/kernel/core/Paging.rlx"
#Require "./src/kernel/core/PhysicalMemory.rlx"
#Require "./src/kernel/core/Heap.rlx"

Heap RawKernelHeap
Heap* KernelHeap := &RawKernelHeap

define void* KernelHeapAllocate(i64 Tag, i32 Size) {
	return KernelHeap->Allocate(Tag, Size)
}
define void* KernelHeapExtendAllocation(void* Memory, i32 Size) {
	return KernelHeap->Extend(Memory, Size)
}
define void KernelHeapFree(void* Memory) {
	KernelHeap->Free(Memory)
}

struct KernelInfo {
	void* Base
	i64 PhysicalBase
	i32 Size
	i32 PageCount
	
	void* FrameBuffer
	void* HeapMemory
	void* ReEntryStack
}

KernelInfo RawKernelInfo {
	Base: 0x10_0000 As void*,
	PhysicalBase: 0x10_0000
}

KernelInfo* Kernel := &RawKernelInfo

AMD64Context KernelContext

#Require "./src/kernel/core/Descriptors.rlx"

#Require "./src/utility/Memory.rlx"
#Require "./src/utility/Exception.rlx"

#Require "./src/kernel/core/Timer.rlx"

#Require "./src/kernel/graphics/Terminal.rlx"

i8 USE_INTERRUPT_STUBS := true
i8 RECOVER_FROM_USER_PAGE_FAULT := true

#Require "./src/kernel/core/Interrupts.rlx"
#Require "./src/kernel/core/Devices.rlx"

#Require "./src/kernel/core/SystemCalls.rlx"

#Require "./src/drivers/ATAExt2.rlx"

Ext2DeviceTraits* RootDevice := null
Ext2* FS := null
INode* RootINode := null

#Require "./src/kernel/core/Shell.rlx"

declare void MainContinuation()

define void RawMainContinuation(void* Stack) asm {
	mov, rsp, rdi
	mov, rbp, rsp
	
	call, @MainContinuation

stop:
	jmp, stop
}

define void Main(void* CR3, void* RawFrameBuffer, i64 MaxKernelAddress) {
	BochsPrint("Main, FrameBuffer @ %x\n", RawFrameBuffer)
	
	Kernel->FrameBuffer := RawFrameBuffer
	
	PhysicalMemory->AddReserved(0, 0x10_0000) ; < 1mb, bootloader reserved
	PhysicalMemory->Add(0x10_0000, 0x350_0000) ; free memory
	
	i32 KernelSize := (MaxKernelAddress - 0x10_0000) As i32 ; Highest address of kernel data - image base
	
	Kernel->Size := KernelSize
	Kernel->PageCount := SizeToPageCount(KernelSize)
	
	i64 KernelPages      := PhysicalMemory->Reserve('KNL', KernelSize) ; Reserve the memory the kernel lives in
	i64 PageFramesPages  := PhysicalMemory->Reserve('PFP', BYTES_IN_1MB, PAGE_SIZE)
	i64 HeapMemoryPages  := PhysicalMemory->Reserve('HMP', BYTES_IN_2MB, 8)
	i64 KernelStackPages := PhysicalMemory->Reserve('KSP', PAGE_SIZE * 20, PAGE_SIZE)
	
	void* KernelBase  := 0x10_0000 As void*
	void* PageFrames  := PageFramesPages As void*
	void* HeapMemory  := HeapMemoryPages As void*
	void* StackMemory := KernelStackPages As void*
	
	Kernel->HeapMemory := HeapMemory
	
	KernelAddressSpace->Initialize(PageFrames, BYTES_IN_1MB / PAGE_SIZE)
	
	; Identity map the memory where the page frames are being written, so after setting CR3 PageFrames resolves to the same
	;  address as before setting CR3
	KernelAddressSpace->MapRange(PageFrames, PageFramesPages / PAGE_SIZE, BYTES_IN_1MB / PAGE_SIZE)
	
	; Identity map the kernel, so RIP resolves to the same address before/after setting CR3
	KernelAddressSpace->MapRange(KernelBase, KernelPages / PAGE_SIZE, SizeToPageCount(KernelSize))
	
	; Map the heap to wherever
	KernelAddressSpace->MapRange(HeapMemory, HeapMemoryPages / PAGE_SIZE, PAGE_COUNT_FOR_2MB)
	
	; Map the stack to wherever
	KernelAddressSpace->MapRange(StackMemory, KernelStackPages / PAGE_SIZE, 20)
	
	KernelAddressSpace->Takeover(&RawMainContinuation, StackMemory + (PAGE_SIZE * 20))
}

define void MainContinuation() {
	BochsPrintString("Paging initialized, AddressSpaceManager in control\n")
	
	; Remap the next available `FRAMEBUFFER_SIZE` bytes of virtual memory to 0xE000_0000 (or wherever int10 says)
	i32 FrameBufferPageCount := SizeToPageCount(FRAMEBUFFER_SIZE)
	i8* FrameBuffer := 0x80_0000 As i8*
	KernelAddressSpace->MapRange(FrameBuffer, PointerToPageNumber(Kernel->FrameBuffer), FrameBufferPageCount)
	
	BochsPrintString("Mapped the framebuffer\n")
	
	NativeScreen->Adopt(FrameBuffer, SCREEN_WIDTH, SCREEN_HEIGHT, BYTES_PER_PIXEL, 0, 0x00_00_00)
	;NativeScreen->Adopt(FrameBuffer, SCREEN_WIDTH, SCREEN_HEIGHT, BYTES_PER_PIXEL, 0, 0xFF_FF_FF)
	NativeScreen->Clear()
	
	BochsPrintString("Adopted screen\n")
	
	KernelTerminal->Adopt(NativeScreen, 0xFF_FF_FF, 0x00_00_00)
	;KernelTerminal->Adopt(NativeScreen, 0x00_00_00, 0xFF_FF_FF)
	;KernelTerminal->SetColors(0xFF_FF_FF, 0x00_00_00)
	KernelTerminal->Clear()
	
	KernelTerminal->PrintLine("BOOT: Screen *probably* works")
	
	KernelAddressSpace->Map(0 As void*, 0, PAGE_NOT_PRESENT)
	
	KernelTerminal->PrintLine("BOOT: Unmapped page 0")
	
	KernelHeap->Initialize(Kernel->HeapMemory, BYTES_IN_2MB)
	
	KernelTerminal->Print("BOOT: Kernel Heap Initialized: ")
	KernelHeap->Allocate('Example', 0x222)
	KernelHeap->Print()
	
	
	i64 ReEntryStackPages := PhysicalMemory->Reserve('REP', PAGE_SIZE * 10, PAGE_SIZE)
	void* ReEntryStack    := ReEntryStackPages As void*
	KernelAddressSpace->MapRange(ReEntryStack, ReEntryStackPages / PAGE_SIZE, 10)
	
	Kernel->ReEntryStack := ReEntryStack + (PAGE_SIZE * 10)
	
	
	SetupGDT()
	
	KernelTerminal->PrintLine("BOOT: Setup GDT and TSS")
	
	SetupInterrupts()
	
	SetPITMode(PIT_100HZ)
	SetupTimers()
	
	Print("Set up PIT/timers\n")
	
	Print("\nTesting user-mode\n")
	
	SetupSystemCalls()
	Test()
	
	Print("Back in kernel code\n\n")
	
	KernelTerminal->SetCursorTimer()
	
	KernelTerminal->PrintLine("BOOT: Mounting disk")
	
	void* SB := KernelHeapAllocate('SB', 2048)
	void* TI := KernelHeapAllocate('TI', 1024)
	void* TB1 := KernelHeapAllocate('TB1', 1024)
	void* TB2 := KernelHeapAllocate('TB2', 1024)
	void* BMP := KernelHeapAllocate('BMP', 1024)
	
	FS := KernelHeapAllocate('Root', #Ext2)
	RootDevice := Ext2ATADevice:New()
	FS->Traits := RootDevice
	
	FS->Initialize(SB, TI, TB1, TB2, BMP)
	
	RootINode := CloneMemory(FS->ReadINode(2), #INode)
	
	SetupShell()
	
	Prompt()
	
	loop {}
}
