#Require "./src/drivers/ATA.rlx"

i8 USE_SERIAL_OUTPUT := true
i16 SERIAL_OUTPUT_PORT := 1
i8 USE_BOCHS_PORT_HACK := true

#Require "./src/utility/DebugOutput.rlx"

define void Fail(i8 Location) {
	Info("Ext2 fail at checkpoint %i\n", Location)
	
	loop {}
}

struct INode {
	union {
		i16 Permissions,
		i16 Type
	}
	
	i16 UserID,
	i32 FileSizeLow,
	
	i32 LastAccessTime,
	i32 CreationTime,
	i32 LastModificationTime,
	i32 DeletionTime,
	
	i16 GroupID,
	i16 HardLinkCount,
	i32 DiskSectorsUsed,
	i32 Flags,
	
	union {
		i32 OSValue,
		i32 INodeNumber
	}
	
	i32[12] DirectBlocks,
	i32 SingleIndirectBlock,
	i32 DoubleIndirectBlock,
	i32 TripleIndirectBlock,
	
	i32 GenerationNumber,
	i64 Reserved,
	i32 FragmentAddress,
	
	i32[3] OSValues
}

i8 DIRECTORY_ENTRY_FILE := 1
i8 DIRECTORY_ENTRY_DIRECTORY := 2

struct DirectoryEntry {
	i32 INode,
	i16 EntryLength,
	i8 NameLength,
	i8 Flags,
	i8[1] Name
	
	define i16 TrueSize() {
		i32 Result := this->NameLength + 8
		i32 Remainder := Result % 4
		
		if (Remainder) {
			Result += 4 - Remainder
		}
		
		return Result As i16
	}
	define i16 PaddingSize() {
		return this->EntryLength - this->TrueSize()
	}
	
	define DirectoryEntry* Next() {
		return this + (this->EntryLength + 0)
	}
	
	define i8 IsDirectory() {
		return this->Flags = DIRECTORY_ENTRY_DIRECTORY
	}
	define i8 IsFile() {
		return this->Flags = DIRECTORY_ENTRY_FILE
	}
	
	define i8 NameEquals(i8* OtherName) {
		if (StringLength(OtherName) != this->NameLength) {
			return false
		}
		
		for (i32 Index := 0, Index < this->NameLength, Index += 1) {
			if (OtherName[Index] != this~>Name[Index]) {
				return false
			}
		}
		
		return true
	}
}

struct MinimalExt2 {
	void* TempBlock
	void* TempINode
	
	i32 INodeTableBase
	
	define void* ReadBlock(i32 BlockNumber, void* Buffer) {
		ATARead(false, BlockNumber * 2, 2, Buffer)
		
		return Buffer
	}
	define void* ReadBlock(i32 BlockNumber) {
		return this->ReadBlock(BlockNumber, this->TempBlock)
	}
	
	define i32 FindINodeBlock(i32 INodeNumber, i32* OutINodeOffset) {
		INodeNumber -= 1
		
		i32 INodeOffset := INodeNumber * #INode
		i32 BlockNumber := INodeOffset / 0x400
		i32 OffsetInBlock := INodeOffset % 0x400
		
		*OutINodeOffset := OffsetInBlock
		
		return this->INodeTableBase + BlockNumber
	}
	
	define i32 CalculateDataBlockPath(i32 DataBlockIndex, i32* BlockPath) {
		if (DataBlockIndex < 12) {
			BlockPath[0] := DataBlockIndex
			return 1
		}
		
		DataBlockIndex -= 12
		
		if (DataBlockIndex < 0x100) {
			BlockPath[0] := 12
			BlockPath[1] := DataBlockIndex
			return 2
		}
		
		DataBlockIndex -= 0x100
		
		if (DataBlockIndex < 0x10000) {
			BlockPath[0] := 13
			BlockPath[1] := DataBlockIndex / 0x100
			BlockPath[2] := DataBlockIndex % 0x100
			return 3
		}
		
		DataBlockIndex -= 0x10000
		
		if (DataBlockIndex < 0x1000000) {
			BlockPath[0] := 14
			BlockPath[1] := DataBlockIndex / 0x10000
			BlockPath[2] := DataBlockIndex % 0x10000
			BlockPath[3] := DataBlockIndex % 0x100
			return 4
		}
		
		Fail(1)
		
		return 0
	}
	
	define i32 FindINodeDataBlock(INode* TargetNode, i32 DataBlockIndex) {
		i32[4] BlockPath
		
		i32 BlockCount := this->CalculateDataBlockPath(DataBlockIndex, BlockPath)
		i32* RootBlock := TargetNode~>DirectBlocks
		i32 RootBlockNumber := 0
		
		for (i32 WalkBlockIndex := 0, WalkBlockIndex < BlockCount, WalkBlockIndex += 1) {
			i32 NextBlockOffset := BlockPath[WalkBlockIndex]
			
			if !(RootBlock[NextBlockOffset]) {
				Fail(2)
			}
			
			RootBlockNumber := RootBlock[NextBlockOffset]
			
			if (BlockCount != 1) {
				RootBlock := this->ReadBlock(RootBlockNumber)
			}
		}
		
		return RootBlockNumber
	}
	
	define INode* ReadINode(i32 NodeNumber) {
		i32 OffsetInBlock := 0
		i32 BlockNumber := this->FindINodeBlock(NodeNumber, &OffsetInBlock)
		
		INode* Result := this->ReadBlock(BlockNumber, this->TempINode) + OffsetInBlock
		
		Result->INodeNumber := NodeNumber
		
		return Result
	}
	define i32 ReadINodeData(void* IntoBuffer, INode* TargetNode, i32 BlockIndex) {
		i32 TargetBlock := this->FindINodeDataBlock(TargetNode, BlockIndex)
		
		this->ReadBlock(TargetBlock, IntoBuffer)
		
		return TargetBlock
	}
	
	define i32 StartWalkDirectory(INode* DirectoryNode) {
		this->ReadINodeData(this->TempBlock, DirectoryNode, 0)
		return 0
	}
	define DirectoryEntry* WalkDirectoryNext(INode* DirectoryNode, i32* pWalkHandle) {
		i32 Offset := *pWalkHandle
		
		if (Offset >= DirectoryNode->FileSizeLow) {
			return null
		}
		
		i32 BlockNumber := Offset / 1024
		i32 BlockOffset := Offset % 1024
		
		if (this->ReadINodeData(this->TempBlock, DirectoryNode, BlockNumber) = 0) {
			return null
		}
		
		DirectoryEntry* NextEntry := this->TempBlock + BlockOffset
		
		pWalkHandle[0] += NextEntry->EntryLength
		
		return NextEntry
	}
	define DirectoryEntry* FindDirectoryEntryByName(INode* Directory, i8* Name) {
		i32 State := this->StartWalkDirectory(Directory)
		
		loop {
			DirectoryEntry* NextEntry := this->WalkDirectoryNext(Directory, &State)
			
			if (NextEntry = null) {
				return null
			}
			else if (NextEntry->NameEquals(Name)) {
				return NextEntry
			}
		}
		
		return null
	}
}

void* TempBlock := 0x4_0000 As void*
void* TempINode := 0x4_1000 As void*
void* TempExtra := 0x4_2000 As void*

void* ELFBuffer := 0x5_0000 As void*

define void StartKernel(void* CR3, void* FrameBuffer, i64 MaxKernelAddress, void* KernelMain) asm {
	jmp, rcx
}

#Require "./src/utility/ELF.rlx"

define void Main(void* FrameBuffer) {
	MinimalExt2 RawFS {
		TempBlock: TempBlock,
		TempINode: TempINode,
		INodeTableBase: 5
	}
	
	MinimalExt2* FS := &RawFS
	
	INode* RootNode := FS->ReadINode(2)
	
	DirectoryEntry* KernelEntry := FS->FindDirectoryEntryByName(RootNode, "kernel.elf")
	
	if (KernelEntry = null || !KernelEntry->IsFile()) {
		Fail(3)
	}
	
	Info("Found kernel\n")
	
	INode* KernelNode := FS->ReadINode(KernelEntry->INode)
	
	FS->ReadINodeData(TempExtra, KernelNode, 0)
	
	i32 KernelSize := KernelNode->FileSizeLow
	
	i32 KernelBlockCount := KernelSize / 0x400
	i32 KernelRemainder := KernelSize % 0x400
	
	void* KernelFile := ELFBuffer
	
	for (i32 KernelBlockIndex := 0, KernelBlockIndex < KernelBlockCount, KernelBlockIndex += 1) {
		FS->ReadINodeData(KernelFile, KernelNode, KernelBlockIndex)
		
		KernelFile += 0x400
	}
	
	if (KernelRemainder) {
		FS->ReadINodeData(KernelFile, KernelNode, KernelBlockIndex)
	}
	
	Info("Loaded kernel file, reading ELF\n")
	
	ELFReader Kernel {
		Data: ELFBuffer,
		Size: KernelSize
	}
	
	void* Entry := Kernel.Load()
	
	i64 MaxKernelAddress := 0
	
	ELFProgramHeader* ProgramHeaders := Kernel.Header->GetProgramHeaders()

	for (i32 Index := 0, Index < Kernel.Header->ProgramHeaderEntryCount, Index++) {
		ELFProgramHeader* Next := ProgramHeaders[Index]
		
		if (Next->Type = ELF_SEGMENT_TYPE_LOAD) {
			i64 NextEnd := Next->VirtualAddress + Next->MemorySize
			
			if (NextEnd > MaxKernelAddress) {
				MaxKernelAddress := NextEnd
			}
		}
	}
	
	StartKernel(0x1_0000 As void*, FrameBuffer, MaxKernelAddress, Entry)
}