#Require "./src/drivers/EFI.rlx"

define void Info(i8* Format, ... Parameters) {
	
}

EFI_HANDLE* IMAGE_HANDLE
EFI_SYSTEM_TABLE* SYSTEM_TABLE

define void PrintCharacter(i8 Character) {
	i8[4] Temp {Character, 0, 0, 0}
	
	SYSTEM_TABLE->ConsoleOutput->OutputString(Temp As i16*)
}

#Require "./src/utility/Print.rlx"

define void DoWideStringPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
	i32 Index := 0
	i16* String := Parameters[*ParameterIndex] As i16*
	
	loop {
		i16 Next := String[Index++]
		
		if (Next = 0) {
			break
		}
		
		this->PrintCharacter(Next As i8)
	}
	
	*ParameterIndex += 1
}

PrintFormatPrototype WideStringFormatPrototype {
	Name: "w",
	Format: &DoWideStringPrint
}

i32 WIDE_STRING_FORMAT_PROTOTYPE_ID := AddPrintFormat(&WideStringFormatPrototype)

define void DoGUIDPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
	i8* GUID := Parameters[*ParameterIndex] As i8*
	
	this->Print("{")
	
	for (i32 Index := 3, Index >= 0, Index--) {
		this->PrintByte(GUID[Index])
	}
	
	this->Print("-")
	
	for (i32 Index := 5, Index >= 4, Index--) {
		this->PrintByte(GUID[Index])
	}
	
	this->Print("-")
	
	for (i32 Index := 7, Index >= 6, Index--) {
		this->PrintByte(GUID[Index])
	}
	
	this->Print("-")
	
	for (i32 Index := 8, Index < 10, Index++) {
		this->PrintByte(GUID[Index])
	}
	
	this->Print("-")
	
	for (i32 Index := 10, Index < 16, Index++) {
		this->PrintByte(GUID[Index])
	}
	
	this->Print("}")
	
	*ParameterIndex += 1
}

PrintFormatPrototype GUIDFormatPrototype {
	Name: "guid",
	Format: &DoGUIDPrint
}

i32 GUID_FORMAT_PROTOTYPE_ID := AddPrintFormat(&GUIDFormatPrototype)


declare void PrintStackDump(void*)
declare void* GetRBP()

define void TerminateAfterUnhandledException(i64 Code) {
	Print("Unhandled exception %l (%x)\n", Code, Code)
	PrintStackDump(GetRBP())
}

#Require "$/ExceptionBase.rlx"

define void PrintStackDump(void* RBP) {
	StackFrame* Last := RBP As StackFrame*
	i32 Index := 1
	
	while (Last) {
		if (Last->LastFrame & 1) {
			StackFrame* Temp := Last->LastFrame - 1
		
			Print("	^10Stack[%i]^F0 ^D0Try catch address^F0 = %x\n", Index, Last->ReturnAddress, Temp)
			Index += 1
			
			Last := Temp
		}
		else {
			i64* MaybeMagic := (Last - 0x8) As i64*
			i8** MaybeName := (Last - 0x10) As i8**
			
			if (Debug && *MaybeMagic = 0x12345678) {
				Print("	^10Stack[%i]^F0 ^B0Fn^F0 = %s\n", Index, *MaybeName)
			}
			else {
				Print("	^10Stack[%i]^F0 ^B0Fn callsite^F0 = %x\n", Index, Last->ReturnAddress, Last->LastFrame)
			}
			
			Index += 1
			
			Last := Last->LastFrame
		}
	}
}

#Require "$/MemoryBase.rlx"

struct EFIAllocation {
	i32 Size
	i32 Dummy
	i8[0] Data
}

define void* Alloc(i32 Size) {
	EFIAllocation* Result := SYSTEM_TABLE->BootServices->AllocatePool(8 + Size)
	
	Result->Size := Size
	
	for (i32 Index := 0, Index < Size, Index++) {
		Result->Data[Index] := 0
	}
	
	return Result~>Data
}
define void Free(void* RawMemory) {
	EFIAllocation* Memory := (RawMemory - 8) As EFIAllocation*

	SYSTEM_TABLE->BootServices->FreePool(Memory As void*)
}
define void EFIFree(void* Memory) {
	SYSTEM_TABLE->BootServices->FreePool(Memory)
}
define void* ReAlloc(void* Old, i32 Size) {
	EFIAllocation* Memory := (Old - 8) As EFIAllocation*
	
	void* New := Alloc(Size)
	MoveMemory(New, Old, Memory->Size)
	Free(Old)
	
	return New
}

define void* CloneMemory(void* Memory, i32 Size) {
	void* New := Alloc(Size)
	
	MoveMemory(New, Memory, Size)
	
	return New
}

declare i64 EFIMain(EFI_HANDLE*, EFI_SYSTEM_TABLE*)

define void OnEFIException(i32 ExceptionType, EFI_SYSTEM_CONTEXT_X64* Context) x64 {
	Print("Unhandled EFI exception %x\n", ExceptionType)
	PrintStackDump(Context->RBP As void*)
}

define i64 Main(EFI_HANDLE* ImageHandle, EFI_SYSTEM_TABLE* SystemTable) x64 {
	IMAGE_HANDLE := ImageHandle
	SYSTEM_TABLE := SystemTable
	
	i32 SizeNeeded := 0
	SystemTable->BootServices->LocateHandle(EFI_LOCATE_SEARCH_TYPE_BY_PROTOCOL, EFI_DEBUG_SUPPORT_PROTOCOL_GUID, null, &SizeNeeded, null)
	EFI_HANDLE** Handles := SystemTable->BootServices->AllocatePool(SizeNeeded)
	SystemTable->BootServices->LocateHandle(EFI_LOCATE_SEARCH_TYPE_BY_PROTOCOL, EFI_DEBUG_SUPPORT_PROTOCOL_GUID, null, &SizeNeeded, Handles)
	i32 Count := SizeNeeded / 8
	
	for (i32 DebugSupportIndex := 0, DebugSupportIndex < Count, DebugSupportIndex++) {
		EFI_HANDLE* Next := Handles[DebugSupportIndex]
		
		EFI_DEBUG_SUPPORT_PROTOCOL* DebugSupport := null
		
		SystemTable->BootServices->HandleProtocol(Next, EFI_DEBUG_SUPPORT_PROTOCOL_GUID, &DebugSupport As void**)
		
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_INVALID_OPCODE, null)
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_INVALID_OPCODE, &OnEFIException)
		
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_PROTECTION_FAULT, null)
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_PROTECTION_FAULT, &OnEFIException)
		
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_PAGE_FAULT, null)
		DebugSupport->RegisterExceptionCallback(EFI_EXCEPTION_X64_PAGE_FAULT, &OnEFIException)
	}
	
	return EFIMain(ImageHandle, SystemTable)
}