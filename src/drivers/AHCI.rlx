namespace AHCI {
    enum DeviceType {
        None
        SATA
        SATAPI
        EnclosureBridge
        PortMultiplier
    }

    enum DeviceSignature {
        ATA := 0x101
        ATAPI := 0xEB140101
        SEMB := 0xC33C0101
        PM := 0x96690101
    }

    enum PowerManagementState {
        DeviceNotPresent := 0
        Active := 1
        Partial := 2
        Slumber := 6
    }

    enum InterfaceSpeed {
        DeviceNotPresent := 0
        Generation1 := 1
        Generation2 := 2
    }

    enum DeviceDetection {
        DeviceNotPresent := 0
        NoPhyCommunication := 1
        DevicePresent := 3
        PhyOffline := 4
    }

    namespace HBA {
        struct PortControl {
            i32 CommandListBaseAddressLow
            i32 CommandListBaseAddressHigh

            i32 FISBaseAddressLow
            i32 FISBaseAddressHigh

            i32 InterruptStatus
            i32 InterruptEnable

            i32 CommandStatus

            i32 Reserved

            i32 TaskFileData
            i32 Signature

            union {
                i32 SATA_Status

                bits As i32 {
                    PowerManagementState [8:11] InterfacePowerManagement
                    InterfaceSpeed [4:7] InterfaceSpeed
                    DeviceDetection [0:3] DeviceDetection
                }
            }

            i32 SATA_Control
            i32 SATA_Error
            i32 SATA_Active

            i32 CommandIssue

            i32 SATA_Notification

            i32 FISBasedSwitchControl

            i8[0x2c] Reserved2

            i8[0x10] VendorSpecific

            define DeviceType GuessType() {
                if (this->DeviceDetection != DeviceDetection::DevicePresent) {
                    return DeviceType::None
                }
                else if (this->InterfacePowerManagement != PowerManagementState::Active) {
                    return DeviceType::None
                }
                
                if (this->Signature = DeviceSignature::ATAPI) {
                    return DeviceType::SATAPI
                }
                else if (this->Signature = DeviceSignature::SEMB) {
                    return DeviceType::EnclosureBridge
                }
                else if (this->Signature = DeviceSignature::PM) {
                    return DeviceType::PortMultiplier
                }
                else {
                    return DeviceType::SATA
                }
            }
        }

        struct HostControl {
            i32 HostCapability
            i32 GlobalHostControl
            i32 InterruptStatus
            i32 PortsImplemented
            i32 Version
            i32 CommandCompletionCoalescingControl
            i32 CommandCompletionCoalescingPorts
            i32 EnclosureManagementLocation
            i32 EnclosureManagementControl
            i32 HostCapabilitiesExtended
            i32 BIOSHandoffControl

            i8[0x74] Reserved
            i8[0x60] VendorSpecific

            PortControl[32] Ports
        }

        struct CommandHeader {
            bits As i16 {
                [0:4] DWORDCount
                [5] UseATAPI
                [6] Direction
                [7] Prefetchable
                [8] Reset
                [9] SelfTest
                [10] ClearBusy
                [12:15] PortMultiplierPort
            }

            i16 PhysicalDescriptorTableLength

            i32 PhysicalDescriptorBytesTransferred

            i32 CommandTableDescriptorBaseAddressLow
            i32 CommandTableDescriptorBaseAddressHigh

            i32[4] Reserved
        }

        struct PhysicalRegionDescriptor {
            i32 BaseAddressLow
            i32 BaseAddressHigh

            i32 Reserved

            bits As i32 {
                [0:22] ByteCount
                [31] InterruptOnCompletion
            }
        }

        struct CommandTable {
            i8[0x40] CommandFIS

            i8[0x10] ATAPICommand

            i8[0x30] Reserved

            PhysicalRegionDescriptor[0] PhysicalRegions
        }

        struct CommandList {
            CommandTable[32] Commands
        }
    }

    ; MMIO -
    ; Controller 0x100
    ; Ports 0x1000
    ;  0x1100

    ; Per Port:
    ;  Command List:
    ;   0x20 * 32 = 0x400
    ;  Recieved FIS:
    ;   0x100
    ; Total: 0x500
    
    ; Per Command List:
    ;  Command Header:
    ;   0x80
    ;  Physical Regions:
    ;   N * 0x10

    ; With 8 physical regions (max) per command:
    ;  Command table: 0x100 bytes per
    ;  0x20 command tables: 0x2000 bytes total (2 pages)

    namespace FIS {
        enum Type As i8 {
            HostToDevice := 0x27
            DeviceToHost := 0x34
            ActivateDMA := 0x39
            SetupDMA := 0x41
            Data := 0x46
            SelfTest := 0x58
            SetupPIO := 0x5F
            SetDeviceBits := 0xA1
        }

        struct SetDeviceRegisters {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [7] CommandOrControl
            }

            i8 Command
            i8 FeatureLow

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
                [24:31] FeatureHigh
            }

            ; DWORD3

            i16 Count
            i8 IsochronousCommandCompletion
            i8 Control

            ; DWORD4

            i32 _
        }

        struct GetDeviceRegisters {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] InterruptBit
            }

            i8 Status
            i8 Error

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
            }

            ; DWORD3

            i16 Count
            i16 _

            ; DWORD4

            i32 _
        }

        struct Data {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
            }

            i16 _

            ; DWORD1 - N
            i32[0] Data
        }

        struct PIOSetup {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] TransferDirection
                [6] InterruptBit
            }

            i8 Status
            i8 Error

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
            }

            ; DWORD3

            i16 Count
            i8 _
            i8 NewStatus

            ; DWORD4

            i16 TransferCount
            i16 _
        }

        struct DMASetup {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] TransferDirection
                [6] InterruptBit
                [7] AutoActivate
            }

            i16 _

            ; DWORD1 + DWORD2

            i32 DMABufferIDLow
            i32 DMABufferIDHigh

            ; DWORD3

            i32 _

            ; DWORD4

            i32 DMABufferOffset

            ; DWORD5

            i32 TransferCount

            ; DWORD6

            i32 _
        }

        struct SetDeviceBits {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier

                [6] InterruptPending
                [7] NotificationPending
            }

            bits as i8 {
                [0:2] StatusLow
                [4:6] StatusHigh
            }

            i8 Error

            ; DWORD1

            i32 _
        }

        struct ReceivedFIS {
            ; 0x0 - 0x20

            DMASetup DMA
            i8[4] _

            PIOSetup PIO
            i32[12] _
        }
    }

    struct HostControl {
        HBA::HostControl* IO
    }

    struct DefaultCommand {
        HBA::CommandTable Command
        HBA::PhysicalRegionDescriptor[8] RegionDescriptors
    }

    struct DefaultCommandList {
        DefaultCommand[32] Commands
    }

    struct PerPortMemory {
        DefaultCommandList CommandList

    }

    struct aPort {
        HBA::PortControl* IO

        DefaultCommandList* Commands


        static self* New(HBA::PortControl* IO) {
            self* this := Alloc(#self)

            this->IO := IO



            return this
        }


    }

    struct Controller {
        PCIeDevice* Device

        void* MemoryBase

        HBA::HostControl* HostControl
        HBA::PortControl* RawPorts

        

        define void Initialize(PCIeDevice* Device) {
            this->Device := Device

            /*Info("AHCI_HBA_HOST_CONTROL: %x\n", #HBA::HostControl)
            Info("AHCI_HBA_PORT_CONTROL: %x\n", #HBA::PortControl)
            Info("AHCI_HBA_COMMAND_HEADER: %x\n", #HBA::CommandHeader)
            Info("AHCI_HBA_COMMAND_TABLE: %x\n", #HBA::CommandTable)
            Info("AHCI_HBA_PHYSICAL_REGION_DESCRIPTOR: %x\n", #HBA::PhysicalRegionDescriptor)
            */

            i64 ControllerPhysicalAddress := Device->ReadBAR(5) & 0xFFFF_FFFF
            i32 Size := Device->GetBARSize(5)

            this->MemoryBase := ControllerPhysicalAddress As void*

            i64 MMIOPage := (ControllerPhysicalAddress & PCI_BAR_MEMORY_MASK) / PAGE_SIZE
            i32 MMIOSize := Size / PAGE_SIZE

            KernelAddressSpace->MapRange(this->MemoryBase, MMIOPage, MMIOSize, PAGE_PRESENT | PAGE_WRITE)

            this->HostControl := this->MemoryBase

            Info("AHCI Version %x\n", this->HostControl->Version)
            Info("AHCI Ports Implemented %b\n", this->HostControl->PortsImplemented)

            for (i32 Index := 0, Index < 32, Index++) {
                i32 Mask := 1 << (Index As i8)

                if (this->HostControl->PortsImplemented & Mask) {
                    Info("Port %i Present\n", Index)

                    HBA::PortControl* Port := this->HostControl->Ports[Index]

                    DeviceType PortType := Port->GuessType()

                    Info("Type %i\n", PortType)
                }
            }
        }
    }
}