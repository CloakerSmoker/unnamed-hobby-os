namespace AHCI {
    enum DeviceType {
        None
        SATA
        SATAPI
        EnclosureBridge
        PortMultiplier
    }

    enum DeviceSignature {
        ATA := 0x101
        ATAPI := 0xEB140101
        SEMB := 0xC33C0101
        PM := 0x96690101
    }

    enum PowerManagementState {
        DeviceNotPresent := 0
        Active := 1
        Partial := 2
        Slumber := 6
    }

    enum InterfaceSpeed {
        DeviceNotPresent := 0
        Generation1 := 1
        Generation2 := 2
    }

    enum DeviceDetection {
        DeviceNotPresent := 0
        NoPhyCommunication := 1
        DevicePresent := 3
        PhyOffline := 4
    }

    namespace HBA {
        bits PortControlCommand As i32 {
            [0] Start
            [4] RecieveEnabled
        }

        bits PortControlStatus As i32 {
            [15] ControllerRunning
            [14] RecieveRunning
        }

        bits _TaskFileData As i32 {
            [0] Error
            [3] DataRequest
            [7] Busy
        }

        struct PortControl {
            i32 CommandListBaseAddressLow
            i32 CommandListBaseAddressHigh

            i32 FISBaseAddressLow
            i32 FISBaseAddressHigh
            
            union {
                i32 InterruptStatus
            }

            i32 InterruptEnable

            union {
                i32 CommandStatus
                PortControlCommand Command
                PortControlStatus Status
            }

            i32 Reserved

            union {
                i32 RawTaskFileData
                _TaskFileData TaskFileData
            }

            i32 Signature

            union {
                i32 SATA_Status

                bits As i32 {
                    PowerManagementState [8:11] InterfacePowerManagement
                    InterfaceSpeed [4:7] InterfaceSpeed
                    DeviceDetection [0:3] DeviceDetection
                }
            }

            i32 SATA_Control
            i32 SATA_Error
            i32 SATA_Active

            i32 CommandIssue

            i32 SATA_Notification

            i32 FISBasedSwitchControl

            i8[0x2c] Reserved2

            i8[0x10] VendorSpecific

            define DeviceType GuessType() {
                if (this->DeviceDetection != DeviceDetection::DevicePresent) {
                    return DeviceType::None
                }
                else if (this->InterfacePowerManagement != PowerManagementState::Active) {
                    return DeviceType::None
                }
                
                if (this->Signature = DeviceSignature::ATAPI) {
                    return DeviceType::SATAPI
                }
                else if (this->Signature = DeviceSignature::SEMB) {
                    return DeviceType::EnclosureBridge
                }
                else if (this->Signature = DeviceSignature::PM) {
                    return DeviceType::PortMultiplier
                }
                else {
                    return DeviceType::SATA
                }
            }
        }

        bits _GlobalHostControl As i32 {
            [0] ControllerReset
            [1] InterruptEnable
            [2] MSINeedsMet
            [31] AHCIEnable
        }

        struct HostControl {
            i32 HostCapability

            union {
                i32 RawGlobalHostControl
                _GlobalHostControl GlobalHostControl
            }

            i32 InterruptStatus
            i32 PortsImplemented
            i32 Version
            i32 CommandCompletionCoalescingControl
            i32 CommandCompletionCoalescingPorts
            i32 EnclosureManagementLocation
            i32 EnclosureManagementControl
            i32 HostCapabilitiesExtended
            i32 BIOSHandoffControl

            i8[0x74] Reserved
            i8[0x60] VendorSpecific

            PortControl[32] Ports
        }

        struct CommandHeader {
            bits As i16 {
                [0:4] DWORDCount
                [5] UseATAPI
                [6] Direction
                [7] Prefetchable
                [8] Reset
                [9] SelfTest
                [10] ClearBusy
                [12:15] PortMultiplierPort
            }

            i16 PhysicalDescriptorTableLength

            i32 PhysicalDescriptorBytesTransferred

            i32 CommandTableDescriptorBaseAddressLow
            i32 CommandTableDescriptorBaseAddressHigh

            i32[4] Reserved
        }

        struct PhysicalRegionDescriptor {
            i32 BaseAddressLow
            i32 BaseAddressHigh

            i32 Reserved

            bits As i32 {
                [0:22] ByteCount
                [31] InterruptOnCompletion
            }
        }

        struct CommandTable {
            i8[0x40] CommandFIS

            i8[0x10] ATAPICommand

            i8[0x30] Reserved

            PhysicalRegionDescriptor[0] PhysicalRegions
        }

        struct CommandList {
            CommandTable[32] Commands
        }
    }

    ; MMIO -
    ; Controller 0x100
    ; Ports 0x1000
    ;  0x1100

    ; Per Port:
    ;  Command List:
    ;   0x20 * 32 = 0x400
    ;  Recieved FIS:
    ;   0x100
    ; Total: 0x500
    
    ; Per Command List:
    ;  Command Header:
    ;   0x80
    ;  Physical Regions:
    ;   N * 0x10

    ; With 8 physical regions (max) per command:
    ;  Command table: 0x100 bytes per
    ;  0x20 command tables: 0x2000 bytes total (2 pages)

    namespace FIS {
        enum Type As i8 {
            HostToDevice := 0x27
            DeviceToHost := 0x34
            ActivateDMA := 0x39
            SetupDMA := 0x41
            Data := 0x46
            SelfTest := 0x58
            SetupPIO := 0x5F
            SetDeviceBits := 0xA1
        }

        struct SetDeviceRegisters {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [7] CommandOrControl
            }

            i8 Command
            i8 FeatureLow

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
                [24:31] FeatureHigh
            }

            ; DWORD3

            i16 Count
            i8 IsochronousCommandCompletion
            i8 Control

            ; DWORD4

            i32 _
        }

        struct GetDeviceRegisters {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] InterruptBit
            }

            i8 Status
            i8 Error

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
            }

            ; DWORD3

            i16 Count
            i16 _

            ; DWORD4

            i32 _
        }

        struct Data {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
            }

            i16 _

            ; DWORD1 - N
            i32[0] Data
        }

        struct PIOSetup {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] TransferDirection
                [6] InterruptBit
            }

            i8 Status
            i8 Error

            ; DWORD1

            bits as i32 {
                [0:23] LBALow
                [24:31] Device
            }

            ; DWORD2

            bits as i32 {
                [0:23] LBAHigh
            }

            ; DWORD3

            i16 Count
            i8 _
            i8 NewStatus

            ; DWORD4

            i16 TransferCount
            i16 _
        }

        struct DMASetup {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier
                [5] TransferDirection
                [6] InterruptBit
                [7] AutoActivate
            }

            i16 _

            ; DWORD1 + DWORD2

            i32 DMABufferIDLow
            i32 DMABufferIDHigh

            ; DWORD3

            i32 _

            ; DWORD4

            i32 DMABufferOffset

            ; DWORD5

            i32 TransferCount

            ; DWORD6

            i32 _
        }

        struct SetDeviceBits {
            ; DWORD0

            Type Type

            bits as i8 {
                [0:3] PortMultiplier

                [6] InterruptPending
                [7] NotificationPending
            }

            bits as i8 {
                [0:2] StatusLow
                [4:6] StatusHigh
            }

            i8 Error

            ; DWORD1

            i32 _
        }

        struct ReceivedFIS {
            ; 0x0 - 0x20

            DMASetup DMA
            i8[4] _

            PIOSetup PIO
            i32[12] _
        }
    }

    struct CommandTableEntry {
        HBA::CommandTable Command
        HBA::PhysicalRegionDescriptor[8] RegionDescriptors
    }

    struct CommandTable {
        CommandTableEntry[32] Commands
    }

    struct CommandHeaderList {
        HBA::CommandHeader[32] Headers
    }

    struct DevicePort {
        i32 Index
        HBA::PortControl* Control
        DeviceType Type

        CommandHeaderList* CommandHeaderList
        i64 PhysicalCommandHeaderList

        FIS::ReceivedFIS* ReceivedFIS
        i64 PhysicalRecievedFIS

        CommandTable* Commands
        i64 PhysicalCommands

        static self* New(i32 Index, HBA::PortControl* Control) {
            self* this := Alloc(#self)

            this->Index := Index
            this->Control := Control
            this->Type := Control->GuessType()

            return this
        }

        define void StartCommands() {
            while (this->Control->Status.ControllerRunning) {}

            this->Control->Command.RecieveEnabled := true
            this->Control->Command.Start := true
        }
        
        define void StopCommands() {
            this->Control->Command.Start := false
            this->Control->Command.RecieveEnabled := false

            loop {
                if (this->Control->Status.RecieveRunning) {
                    continue
                }
                else if (this->Control->Status.ControllerRunning) {
                    continue
                }

                break
            }
        }
    }

    struct Controller {
        PCIeDevice* Device

        void* MemoryBase

        HBA::HostControl* HostControl
        
        PointerArray* Ports ; <DevicePort*>

        define void Log(i8* Format, ... Args) {
            i8[200] Buffer

            i32 Length := RawFormatString(Buffer, 300, Format, Args)
            Buffer[Length] := 0

            Info("%pcie: ICH9: %s\n", this->Device, Buffer)
        }

        define i8* GetDeviceTypeString(DeviceType Type) {
            i8*[5] Strings {
                "None", "SATA", "SATAPI", "EnclosureBridge", "PortMultiplier"
            }

            return Strings[Type]
        }

        define void InitializePorts() {
            i32 Count := this->Ports->Count()

            i32 SizeOfHeaders := Count * #CommandHeaderList
            i32 SizeOfFIS := Count * #FIS::ReceivedFIS
            i32 SizeOfCommands := Count * #CommandTable

            i32 Total := SizeOfHeaders + SizeOfFIS + SizeOfCommands

            void* Buffer := KernelPageAllocator->AllocateVirtual(SizeToPageCount(Total))
            i64 PhysicalBuffer := KernelAddressSpace->VirtualToPhysical(Buffer)

            CommandHeaderList* CommandHeaderLists := Buffer
            FIS::ReceivedFIS* FIS := Buffer + SizeOfHeaders
            CommandTable* Commands := Buffer + SizeOfHeaders + SizeOfFIS

            for (i32 Index := 0, Index < Count, Index++) {
                DevicePort* Port := this->Ports->At(Index)

                Port->CommandHeaderList := CommandHeaderLists[Index]
                Port->Control->CommandListBaseAddressLow := VirtualToPhysical(Port->CommandHeaderList) As i32
                Port->Control->CommandListBaseAddressHigh := 0

                Port->ReceivedFIS := FIS[Index]
                Port->Control->FISBaseAddressLow := VirtualToPhysical(Port->ReceivedFIS) As i32
                Port->Control->FISBaseAddressHigh := 0

                Port->Commands := Commands[Index * 32]

                for (i32 CommandIndex := 0, CommandIndex < 32, CommandIndex++) {
                    HBA::CommandHeader* Header := Port->CommandHeaderList->Headers[CommandIndex]

                    Header->PhysicalDescriptorTableLength := 8
                    Header->CommandTableDescriptorBaseAddressLow := VirtualToPhysical(Port->Commands[CommandIndex]) As i32
                    Header->CommandTableDescriptorBaseAddressHigh := 0
                }
            }
        }

        define void Initialize(PCIeDevice* Device) {
            this->Device := Device

            /*Info("AHCI_HBA_HOST_CONTROL: %x\n", #HBA::HostControl)
            Info("AHCI_HBA_PORT_CONTROL: %x\n", #HBA::PortControl)
            Info("AHCI_HBA_COMMAND_HEADER: %x\n", #HBA::CommandHeader)
            Info("AHCI_HBA_COMMAND_TABLE: %x\n", #HBA::CommandTable)
            Info("AHCI_HBA_PHYSICAL_REGION_DESCRIPTOR: %x\n", #HBA::PhysicalRegionDescriptor)
            */

            i64 ControllerPhysicalAddress := Device->ReadBAR(5) & 0xFFFF_FFFF
            i32 Size := Device->GetBARSize(5)

            this->MemoryBase := ControllerPhysicalAddress As void*

            i64 MMIOPage := (ControllerPhysicalAddress & PCI_BAR_MEMORY_MASK) / PAGE_SIZE
            i32 MMIOSize := Size / PAGE_SIZE

            KernelAddressSpace->MapRange(this->MemoryBase, MMIOPage, MMIOSize, PAGE_PRESENT | PAGE_WRITE)

            this->HostControl := this->MemoryBase

            this->HostControl->GlobalHostControl.ControllerReset := true
            this->HostControl->GlobalHostControl.AHCIEnable := true

            this->Log("Version %x", this->HostControl->Version)

            i32 DeviceCount := 0
            this->Ports := PointerArray:New()

            for (i32 Index := 0, Index < 32, Index++) {
                i32 Mask := 1 << (Index As i8)

                if (this->HostControl->PortsImplemented & Mask) {
                    HBA::PortControl* Port := this->HostControl->Ports[Index]

                    DeviceType Type := Port->GuessType()

                    this->Log("Port %i present, %s type device", Index, this->GetDeviceTypeString(Type))

                    if (Type != DeviceType::None) {
                        this->Ports->Push(DevicePort:New(Index, Port))
                    }
                }
            }

            this->InitializePorts()
        }
    }
}