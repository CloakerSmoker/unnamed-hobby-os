i16* COM_PORT_BASES := i16[0x3F8, 0x2F8, 0x3E8, 0x2E8]

i32 SERIAL_MAJOR := 4
i32 SERIAL_MINOR := 64
i32 SERIAL_COUNT := 4

SerialPort*[4] SerialPorts

#Require "./src/drivers/SerialBase.rlx"

#Require "./src/kernel/core/Interrupts.rlx"

define void SerialInterrupt(AMD64Context* Context) {
	for (i32 Index := 0, Index < 4, Index++) {
		SerialPort* Next := SerialPorts[Index]
		
		if (Next) {
			i8 ISR := Next->PortRead(COM_REGISTER_INTERRUPT_ID)
			
			while !(ISR & COM_INTERRUPT_ID_NOT_PENDING) {
				i8 Cause := ISR & COM_INTERRUPT_ID_CAUSE_MASK
				
				if (Cause = COM_INTERRUPT_ID_DATA || Cause = COM_INTERRUPT_ID_TIMEOUT) {
					Next->ReadInterrupt()
				}
				else if (Cause = COM_INTERRUPT_ID_EMPTY) {
					Next->WriteInterrupt()
				}
				else if (Cause = COM_INTERRUPT_ID_STATUS) {
					Next->PortRead(COM_REGISTER_MODEM_STATUS)
				}
				else if (Cause = COM_INTERRUPT_ID_BREAK) {
					Next->PortRead(COM_REGISTER_LINE_STATUS)
				}
				
				ISR := Next->PortRead(COM_REGISTER_INTERRUPT_ID)
			}
		}
	}
	
	SendEOI(0x3)
}

define void OnSerialInterrupt() asm {
	call, @InterruptSetup
	call, @SerialInterrupt
	jmp, @InterruptReturn
}

define void RegisterSerialInterrupts() {
	InsertIDTEntry(0x23, &OnSerialInterrupt, true)
	EnablePICLine(0x3, true)
	
	InsertIDTEntry(0x24, &OnSerialInterrupt, true)
	EnablePICLine(0x4, true)
}

#Require "./src/kernel/file-system/FileSystem.rlx"

declare FileHandlePrototype* GetSerialPortFileHandlePrototype()

struct SerialPortFileHandle {
	#Include "./src/kernel/file-system/HandleInstance.rlx"
	
	SerialPort* Port

	static FileHandle* New(i32 Number) {
		self* this := Alloc(#self)

		this->Prototype := GetSerialPortFileHandlePrototype()

		this->Port := SerialPorts[Number]

		if !(this->Port) {
			SerialPort* Port := Alloc(#SerialPort)
			Port->Initialize(COM_PORT_BASES[Number], COM_DIVISOR_115200, COM_DATA_BITS_8 | COM_PARITY_NONE | COM_STOP_BITS_1)

			SerialPorts[Number] := Port

			this->Port := Port
		}

		return this As void*
	}
	
	define i32 Poll(i32 Mode) {
		i32 Result := 0
		
		if (Mode & POLL_CAN_READ && this->Port~>ReadBuffer->Available() != 0) {
			Result |= POLL_CAN_READ
		}
		
		if (Mode & POLL_CAN_WRITE && this->Port~>WriteBuffer->Space() != 0) {
			; TODO: bug, `->Space()` is dumb and doesn't properly wrap around
			
			Result |= POLL_CAN_WRITE
		}
		
		return Result
	}
	define i32 Read(void* Buffer, i32 Count) {
		return this->Port->Read(Buffer, Count)
	}
	define i32 Write(void* Buffer, i32 Count) {
		this->Port->Write(Buffer, Count)
		
		return Count
	}
}

FileHandlePrototype SerialPortFileHandlePrototype {
	DataSize: #SerialPortFileHandle,
	
	Poll: &SerialPortFileHandle.Poll,
	Read: &SerialPortFileHandle.Read,
	Write: &SerialPortFileHandle.Write
}

i32 SERIAL_PORT_FILE_HANDLE_PROTOTYPE_ID := RegisterHandlePrototype(&SerialPortFileHandlePrototype)

define FileHandlePrototype* GetSerialPortFileHandlePrototype() {
	return &SerialPortFileHandlePrototype
}