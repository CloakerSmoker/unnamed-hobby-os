

; Loaded with the leftover EFI identity map

; Kernel ELF pointer is passed

/*
We need to get things set up for the kernel, mainly:

* Physical memory allocator (0x1000 onwards)
* Kernel text physical memory
* Kernel page tables
* Kernel Stack
* Kernel Heap
* Kernel page mappings

<128mb all identity mapped

*/

#ImageBase 0x80_0000
void* TRAMPOLINE_ADDRESS := 0x80_0000 As void*

#Require "$/MemoryBase.rlx"

#Require "@/PrintBase.rlx"
#Require "@/ExceptionBase.rlx"

#Require "./src/bootloader/BootInfo.rlx"
#Require "./src/trampoline/Info.rlx"

#Require "./src/kernel/Config.rlx"

#Require "./src/utility/ELF.rlx"

define i64 IdentityVirtualToPhysical(void* Pointer) {
    return Pointer As i64
}

declare void MainContinuation(TrampolineInfo*)

define void Main(BootloaderInfo* RawInfo) {
    ; nuke IDT to kill TianoCore

    asm {
		xor, rax, rax
		push, rax
		push, rax
		mov, rax, rsp
		lidt, {rax} As i64*
		pop, rax
		pop, rax
	}

    FastZeroMemory(&COM_0, #SerialPort)
    FastZeroMemory(&Terminal, #EarlyTerminal)

    COM_0.Initialize(COM_PORT_0, COM_DIVISOR_115200, COM_LINE_8N1)

    Terminal.LoadFON(i8[#File "./misc/fonts/OlivettiThin_8x14.fon"])
    Terminal.SetFrameBuffer(RawInfo->PhysicalFrameBuffer As void*, RGB32, 1024, 768)
    Terminal.Clear()

    ; Usable memory = (TOTAL_MEMORY - FIRST_USABLE_PHYSICAL_ADDRESS)
    i32 UsablePages := SizeToPageCount(TOTAL_MEMORY) - SizeToPageCount(FIRST_USABLE_PHYSICAL_ADDRESS As i32)

    Print("Usable Memory: %x pages\n", UsablePages)

    PageHeap* PhysicalMemory := PageHeap:Adopt(FIRST_USABLE_PHYSICAL_ADDRESS, UsablePages)
    
    Print("Adopted %x as physical memory allocator\n")

    PhysicalMemory->FreeAll()

    Print("Zeroed allocation map\n")

    i64 TrampolineBytes := RawInfo->TrampolineMaxAddress - (TRAMPOLINE_ADDRESS As i64)
    i32 TrampolinePages := SizeToPageCount(TrampolineBytes As i32)

    Print("Reserving %x - %x for trampoline\n", TRAMPOLINE_ADDRESS, TRAMPOLINE_ADDRESS + (TrampolinePages * PAGE_SIZE))

    PhysicalMemory->Reserve(TRAMPOLINE_ADDRESS As i64, TrampolinePages)

    ;PhysicalMemory->Reserve(0xA_0000, SizeToPageCount(0x2_0000))

    ; Allocate the TrampolineInfo (and populate it from the BootInfo)

    TrampolineInfo* Info := PhysicalMemory->AllocateVirtual(1)
    FastZeroMemory(Info, PAGE_SIZE)
    MoveMemory(Info, RawInfo, #BootloaderInfo)
    BootloaderInfo* BootInfo := Info~>BootInfo

    Info->PhysicalMemory := PhysicalMemory

    Print("Instance Info: %x\n", Info)

    ; Relocate kernel data into memory we manage
    ; (We'll end up freeing this once we've mapped the kernel into memory)
    ; (It's just too annoying to map the kernel without virtual memory properly wired up)

    void* NewKernelData := PhysicalMemory->AllocateVirtual(SizeToPageCount(BootInfo->KernelSize))
    MoveMemory(NewKernelData, BootInfo->KernelData, BootInfo->KernelSize)

    BootInfo->KernelData := NewKernelData

    Print("Relocated Kernel File: %x\n", BootInfo->KernelData)

    ; Set up the PhysicalPageAllocator

    PhysicalPageAllocator* Physical := Info~>PhysicalMemoryAllocator
    Physical->Initialize()
    Physical->Heap := PhysicalMemory

    ; Set up the AddressSpaceManager

    void* PML4 := PhysicalMemory->AllocateVirtual(1)
    FastZeroMemory(PML4, PAGE_SIZE)

    Print("PML4: %x\n", PML4)

    AddressSpaceManager* VirtualMemory := Info~>VirtualMemory
    VirtualMemory->Initialize(PML4, IdentityVirtualToPhysical(PML4), Physical)

    ; Identity map the framebuffer
    void* FrameBuffer := Info~>BootInfo->PhysicalFrameBuffer As void*

    VirtualMemory->MapRange(FrameBuffer, IdentityVirtualToPhysical(FrameBuffer) / PAGE_SIZE, SizeToPageCount(1024 * 786 * 4), PAGE_PRESENT | PAGE_WRITE)

    ; Identity map low memory
    VirtualMemory->MapRange(FIRST_USABLE_PHYSICAL_ADDRESS, IdentityVirtualToPhysical(FIRST_USABLE_PHYSICAL_ADDRESS) / PAGE_SIZE, LOW_IDENTITY_MAP_SIZE, PAGE_PRESENT | PAGE_WRITE)

    i64 KernelStackPhysical := PhysicalMemory->Allocate(PAGES_FOR_KERNEL_STACK)
    VirtualMemory->MapRange(ADDRESS_OF_KERNEL_STACK, KernelStackPhysical / PAGE_SIZE, PAGES_FOR_KERNEL_STACK, PAGE_PRESENT | PAGE_WRITE)

    void* KernelStack := ADDRESS_OF_KERNEL_STACK + (PAGE_SIZE * (PAGES_FOR_KERNEL_STACK - 1))

    VirtualMemory->PrintMappings()

    VirtualMemory->Takeover(&MainContinuation, Info, KernelStack)
}

define void SetupHeap(TrampolineInfo* Info, void* VirtualAddress, i32 PageCount) {
    i64 HeapPhysicalPages := Info->PhysicalMemory->Allocate(PageCount)

    Info~>VirtualMemory->MapRange(VirtualAddress, HeapPhysicalPages / PAGE_SIZE, PageCount, PAGE_PRESENT | PAGE_WRITE)
    FastZeroMemory(VirtualAddress, PageCount * PAGE_SIZE)

    Info~>Heap->Initialize(VirtualAddress, PageCount * PAGE_SIZE)

    Print("Heap Initialized\n")
    Info~>Heap->Bootstrap()

    Print("Heap Bootstrapped!\n")
}

define void* MapKernel(TrampolineInfo* Info, void* KernelFileData, i32 KernelFileSize) {
    ELFHeader* Image := KernelFileData
    ELFProgramHeader* ProgramHeaders := Image->GetProgramHeaders()

    for (i32 Index := 0, Index < Image->ProgramHeaderEntryCount, Index++) {
		ELFProgramHeader* Next := ProgramHeaders[Index]
		
		if (Next->Type = ELF_SEGMENT_TYPE_LOAD) {
			void* SectionData := Image + Next->FileOffset
			void* SectionMemory := Next->VirtualAddress As void*
			void* SectionVirtualPage := SectionMemory & 0xFFFF_FFFF_FFFF_F000
			
			;Print("Section %i is %i (%x) bytes\n", Index, Next->MemorySize, Next->MemorySize)
			
			i32 SectionPageCount := (Next->MemorySize As i32) / PAGE_SIZE
			
			if (Next->MemorySize % PAGE_SIZE) {
				SectionPageCount += 1
			}
			
			if (Next->FileOffset % PAGE_SIZE) {
				SectionPageCount += 1
			}
			
			if (SectionPageCount = 0) {
				continue
			}
			
			i64 TempFlags := PAGE_PRESENT | PAGE_WRITE ; Map as PRESENT|WRITE so we can... actually load the section into memory
			i64 FinalFlags := PAGE_PRESENT | PAGE_USER
			
			if (Next->Flags & ELF_SEGMENT_FLAGS_WRITE) {
				FinalFlags |= PAGE_WRITE
			}

            i64 Physical := Info->PhysicalMemory->Allocate(SectionPageCount)
            Info~>VirtualMemory->MapRange(SectionVirtualPage, Physical / PAGE_SIZE, SectionPageCount, TempFlags)
			
			if (Next->MemorySize > Next->FileSize) {
				void* ZeroArea := SectionMemory + Next->FileSize
				i64 ZeroSize := Next->MemorySize - Next->FileSize
				
				FastSetMemory8(ZeroArea, 0, ZeroSize)
			}
			
			FastMoveMemory(SectionMemory, SectionData, Next->FileSize)

            Info~>VirtualMemory->MapRange(SectionVirtualPage, Physical / PAGE_SIZE, SectionPageCount, FinalFlags)
		}
	}

    return Image->EntryPoint As void*
}

define void MainContinuation(TrampolineInfo* Info) {
    Info("Continuation\n")

    SetupHeap(Info, ADDRESS_OF_KERNEL_HEAP, PAGES_FOR_KERNEL_HEAP)
    Info("heap!\n")

    void(TrampolineInfo*) KernelEntryPoint := MapKernel(Info, Info~>BootInfo->KernelData, Info~>BootInfo->KernelSize)

    Info("Kernel Main: %x\n", KernelEntryPoint)

    ELFHeader* KernelELF := Info~>BootInfo->KernelData

    ELFSymbol* PreMainSymbol := KernelELF->FindSymbol("PreMain(TrampolineInfo*)")
    void(TrampolineInfo*) PreMain := KernelELF->GetSymbolAddress(PreMainSymbol)

    Print("Kernel PreMain: %x\n", PreMain)

    PreMain(Info)

    Print("Returned from PreMain\n")

    KernelEntryPoint(Info)

    loop {}
}