IVirtualDirectory* VFSRootDirectory := null

define void MountRoot(IVirtualDirectory* NewRoot) {
    IVirtualDirectory* RootOverlay := VFSDirectory:New()
    IVirtualDirectory* Root := VFSOverlayDirectory:New(NewRoot, RootOverlay, VFSOverlayWriteMode::OnlyEphemeralToOverlay)

    VFSRootDirectory := Root
}

enum FilePathAnchor {
    None := 0,
    Root := 1
}

struct FilePath {
    FilePathAnchor Anchor

    i8*[10] Parts
    i32 Count

    i8[256] Buffer

    i8* FileName

    define void Zero() {
        FastSetMemory8(this, 0, #self)
    }

    define i8* CloneFileName() {
        return CloneMemory(this->FileName, StringLength(this->FileName))
    }

    define i32 Append(i32 Start, i32 End) {
        this->Parts[this->Count++] := this->Buffer + Start
        this->Buffer[End] := 0

        return End + 1
    }

    define self* Seal() {
        this->FileName := this->Parts[this->Count - 1]

        return this
    }

    define void Print() {
        if (this->Anchor = FilePathAnchor::Root) {
            Print("/")
        }

        for (i32 Index := 0, Index < this->Count - 1, Index++) {
            Print("%s/", this->Parts[Index])
        }

        Print("%s", this->FileName)
    }
}

define void ParsePath(i8* Path, i32 Length, FilePath* Out) {
    Out->Zero()

    if (Path[0] = '/') {
        Out->Anchor := FilePathAnchor::Root

        Path += 1
        Length -= 1
    }
    else {
        Out->Anchor := FilePathAnchor::None
    }

    MoveMemory(Out->Buffer, Path, Length)

    i32 Start := 0

    for (i32 Index := 0, Index < Length, Index++) {
        if (Path[Index] = '/') {
            Start := Out->Append(Start, Index)
        }
    }

    Out->Append(Start, Length)

    Out->Seal()
}

define void ParsePath(i8* Path, FilePath* Out) {
    ParsePath(Path, StringLength(Path), Out)
}

define i8 Lookup(IVirtualDirectory* At, FilePath* Path, VirtualDirectoryEntry* Result) {
    IVirtualDirectory* Current := At

    if (Path->Anchor = FilePathAnchor::Root) {
        Current := VFSRootDirectory
    }

    /*if (Path->Count <= 0) {
        Result->Type := VirtualDirectoryEntryType::Directory
        Result->Name := "/"
        Result->Directory := Current

        return true
    }*/

    for (i32 Index := 0, Index < Path->Count - 1, Index++) {
        i8* Part := Path->Parts[Index]

        VirtualDirectoryEntry Next
        
        if !(Current->Lookup(Part, &Next)) {
            return false
        }

        if (Next.Type != VirtualDirectoryEntryType::Directory) {
            return false
        }
        
        Current := Next.Directory
    }

    return Current->Lookup(Path->FileName, Result)
}

define i8 Lookup(IVirtualDirectory* At, i8* RawPath, VirtualDirectoryEntry* Result) {
    FilePath Path
    ParsePath(RawPath, &Path)

    return Lookup(At, &Path, Result)
}

define i8 Mount(IVirtualDirectory* At, i8* RawPath, IVirtualDirectory* Root) {
    IVirtualDirectory* Current := At

    FilePath Path
    ParsePath(RawPath, &Path)

    if (Path.Anchor = FilePathAnchor::Root) {
        At := VFSRootDirectory
    }

    for (i32 Index := 0, Index < Path->Count - 1, Index++) {
        i8* Part := Path->Parts[Index]
        i8 ShouldCreateNew := true

        VirtualDirectoryEntry Next
        if (Current->Lookup(Part, &Next)) {
            if (Next.Type != VirtualDirectoryEntryType::Hole) {
                ShouldCreateNew := false
            }
        }

        if (ShouldCreateNew) {
            IVirtualDirectory* NewChild := VFSDirectory:New()

            VirtualDirectoryEntry NewChildEntry {
                Type: VirtualDirectoryEntryType::Directory,
                Name: CloneString(Part),
                Directory: NewChild
            }

            Current->Insert(&NewChildEntry)

            Current := NewChild
        }
        else {
            ; Entry exists, but we need to make sure it is ephemeral

            IVirtualDirectory* Entry := Next.Directory

            if (Entry->IsEphemeral()) {
                Current := Entry
            }
            else {
                ; Entry isn't ephemeral, we need to replace it with an overlay based on itself

                IVirtualDirectory* Base := Entry
                IVirtualDirectory* Overlay := VFSDirectory:New()
                IVirtualDirectory* Replacement := VFSOverlayDirectory:New(Base, Overlay, VFSOverlayWriteMode::OnlyEphemeralToOverlay)

                VirtualDirectoryEntry OverlayEntry {
                    Type: VirtualDirectoryEntryType::Directory,
                    Name: CloneString(Part),
                    Directory: Replacement
                }

                Current->Insert(&OverlayEntry)

                Current := Replacement
            }
        }
    }

    VirtualDirectoryEntry NewEntry {
        Type: VirtualDirectoryEntryType::Directory,
        Name: CloneString(Path->FileName),
        Directory: Root
    }

    if (Current->Is(GetVFSOverlayDirectoryPrototype())) {
        ; NOTE: Horrible hack

        return (Current As VFSOverlayDirectory*)->Overlay->Insert(&NewEntry)
    }
    else {
        return Current->Insert(&NewEntry)
    }
}

define IVirtualDirectory* LookupParentDirectory(IVirtualDirectory* At, FilePath* Path) {
    Path->Count -= 1

    VirtualDirectoryEntry ParentEntry
    if !(Lookup(At, Path, &ParentEntry)) {
        return null
    }

    Path->Count += 1

    if (ParentEntry.Type != VirtualDirectoryEntryType::Directory) {
        return null
    }

    return ParentEntry.Directory
}

define IVirtualDirectory* CreateDirectory(IVirtualDirectory* At, i8* RawPath) {
    FilePath Path
    ParsePath(RawPath, &Path)

    if (Path.Anchor = FilePathAnchor::Root) {
        At := VFSRootDirectory
    }

    IVirtualDirectory* Parent := LookupParentDirectory(At, &Path)
    IVirtualDirectory* Result := Parent->CreateDirectory()

    VirtualDirectoryEntry Entry {
        Type: VirtualDirectoryEntryType::Directory,
        Name: CloneString(Path.FileName),
        Directory: Result
    }

    Parent->Insert(&Entry)

    return Result
}

define IVirtualFile* CreateFile(IVirtualDirectory* At, i8* RawPath) {
    FilePath Path
    ParsePath(RawPath, &Path)

    if (Path.Anchor = FilePathAnchor::Root) {
        At := VFSRootDirectory
    }

    IVirtualDirectory* Parent := LookupParentDirectory(At, &Path)
    IVirtualFile* Result := Parent->CreateFile()

    VirtualDirectoryEntry Entry {
        Type: VirtualDirectoryEntryType::File,
        Name: CloneString(Path.FileName),
        File: Result
    }

    Parent->Insert(&Entry)

    return Result
}