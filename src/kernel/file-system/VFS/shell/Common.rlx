define void ExecuteLS(i64 ArgC, i8** ArgV) {
    IDirectory* Target := CurrentDirectory

    if (ArgC = 2) {
        i8* Path := ArgV[1]

        VFSDirectoryEntry Entry
        if !(Lookup(CurrentDirectory, Path, &Entry)) {
            Print("'%s' does not exist\n", Path)
            return
        }

        if (Entry.Type != VFSDirectoryEntryType::Directory) {
            Print("'%s' not a directory\n", Path)
            return
        }

        Target := Entry.Directory
    }

    Print("\nListing %i entries:\n", Target->Count())

    void* State := Target->Enumerate()
    i32 Count := 0
    VFSDirectoryEntry Entry

    while (Target->Next(&State, &Entry)) {
        if (Entry.Type = VFSDirectoryEntryType::Directory) {
            Print("%i %s/\n", Count, Entry.Name)
        }
        else if (Entry.Type = VFSDirectoryEntryType::File) {
            Print("%i %s\n", Count, Entry.Name)
        }
        else if (Entry.Type = VFSDirectoryEntryType::Hole) {
            Print("%i %s (hole)\n", Count, Entry.Name)
        }

        Count += 1
    }
}

i32 LS_COMMAND_ID := RegisterCommand("ls", &ExecuteLS)

define void ExecuteCD(i64 ArgC, i8** ArgV) {
    if (ArgC = 2) {
        i8* Path := ArgV[1]

        VFSDirectoryEntry Entry
        if !(Lookup(CurrentDirectory, Path, &Entry)) {
            Print("'%s' does not exist\n", Path)
            return
        }

        if (Entry.Type != VFSDirectoryEntryType::Directory) {
            Print("'%s' is not a directory\n", Path)
            return
        }

        CurrentDirectory := Entry.Directory
    }
}

i32 CD_COMMAND_ID := RegisterCommand("cd", &ExecuteCD)

define void ExecuteTouch(i64 ArgC, i8** ArgV) {
    if (ArgC != 2) {
        return
    }

    VFSDirectoryEntryType Type := VFSDirectoryEntryType::File

    if (StringEquals(ArgV[0], "mkdir")) {
        Type := VFSDirectoryEntryType::Directory
    }

    i8* RawPath := ArgV[1]

    FilePath Path
    ParsePath(RawPath, &Path)

    IDirectory* ParentDirectory := LookupParentDirectory(CurrentDirectory, &Path)

    if !(ParentDirectory) {
        Print("'%s' not found\n", RawPath)
        return
    }

    VFSDirectoryEntry OldEntry
    if (ParentDirectory->Lookup(Path.FileName, &OldEntry)) {
        Print("'%s' already exists\n", RawPath)
        return
    }

    VFSDirectoryEntry NewEntry {
        Type: Type,
        Name: CloneString(Path.FileName)
    }

    if (Type = VFSDirectoryEntryType::File) {
        NewEntry.File := ParentDirectory->CreateFile()
    }
    else if (Type = VFSDirectoryEntryType::Directory) {
        NewEntry.Directory := ParentDirectory->CreateDirectory()
    }

    ParentDirectory->Insert(&NewEntry)
}

i32 TOUCH_COMMAND_ID := RegisterCommand("touch", &ExecuteTouch)
i32 MKDIR_COMMAND_ID := RegisterCommand("mkdir", &ExecuteTouch)

define void ExecuteDD(i64 ArgC, i8** ArgV) {
    ; dd bs=512 if=/dev/loop0p1 of=/host/p1.bin count=512

    i32 InputBase := 0
    i32 OutputBase := 0

    i32 BlockSize := -1
    i32 BlockCount := -1

    i8* InputFilePath := null
    i8* OutputFilePath := null

    for (i32 OptionIndex := 1, OptionIndex < ArgC, OptionIndex++) {
        
        i8* Option := ArgV[OptionIndex]

        i8* Name := Option
        i8* Value := null

        for (i32 Index := 0, Index < StringLength(Option), Index++) {
            if (Option[Index] = '=') {
                Option[Index] := 0
                Value := &Option[Index + 1]
                break
            }
        }

        if (Value != null) {
            if (StringEquals(Name, "bs")) {
                BlockSize := AToI(Value) As i32
            }
            else if (StringEquals(Name, "count")) {
                BlockCount := AToI(Value) As i32
            }
            else if (StringEquals(Name, "skip")) {
                InputBase := AToI(Value) As i32
            }
            else if (StringEquals(Name, "seek")) {
                OutputBase := AToI(Value) As i32
            }
            else if (StringEquals(Name, "if")) {
                InputFilePath := Value
            }
            else if (StringEquals(Name, "of")) {
                OutputFilePath := Value
            }
        }
    }

    if (BlockSize = -1 || BlockCount = -1) {
        Print("Block size and count must be specified\n")
        return
    }
    else if (InputFilePath = null || OutputFilePath = null) {
        Print("Input/output files must be specified\n")
        return
    }

    VFSDirectoryEntry InputEntry
    if !(Lookup(CurrentDirectory, InputFilePath, &InputEntry)) {
        Print("'%s' not found\n", InputFilePath)
        return
    }

    if (InputEntry.Type != VFSDirectoryEntryType::File) {
        Print("'%s' not a file\n", InputFilePath)
        return
    }

    IFile* InputFile := InputEntry.File
    FileHandle* Input := InputFile->Open()
    Input->Seek(InputBase * BlockSize, SeekMode::Set)

    VFSDirectoryEntry OutputEntry
    if !(Lookup(CurrentDirectory, OutputFilePath, &OutputEntry)) {
        i8*[2] FakeTouch {"touch", OutputFilePath}
        ExecuteTouch(2, FakeTouch)

        Lookup(CurrentDirectory, OutputFilePath, &OutputEntry)
    }

    if (OutputEntry.Type != VFSDirectoryEntryType::File) {
        Print("'%s' not a file\n", OutputFilePath)
        return
    }

    IFile* OutputFile := OutputEntry.File
    FileHandle* Output := OutputFile->Open()
    Output->Seek(OutputBase * BlockSize, SeekMode::Set)

    void* BlockBuffer := Alloc(BlockSize)

    for (i32 Index := 0, Index < BlockCount, Index++) {
        Input->Read(BlockBuffer, BlockSize)
        Output->Write(BlockBuffer, BlockSize)
    }

    Input->Close()
    Output->Close()
}

i32 DD_COMMAND_ID := RegisterCommand("dd", &ExecuteDD)