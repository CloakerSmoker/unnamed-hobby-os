
i8 IPV4_PROTOCOL_TCP := 6

struct TCPCounters {
    i32 Final
    i32 Synchronize
    i32 Reset
    i32 Push
    i32 Acknowledge
    i32 Urgent
    i32 CongestionExperienced
    i32 PeerSupportsECN
    i32 CongestionWindowReduced

    i32 Packets
}

struct TCPHeader {
    i16 SourcePort
    i16 DestinationPort

    i32 SequenceNumber
    i32 AcknowledgementNumber

    bits As i8 {
        [4:7] DataOffset
        [0] AccurateECN
    }

    bits As i8 {
        [0] Final
        [1] Synchronize
        [2] Reset
        [3] Push
        [4] Acknowledge
        [5] Urgent
        [6] CongestionExperienced
        [6] PeerSupportsECN
        [7] CongestionWindowReduced
        [0:7] Flags
    }

    i16 WindowSize
    i16 Checksum
    i16 UrgentPointer

    define void FlipEndianess() {
        this->SourcePort := NetworkShort(this->SourcePort)
        this->DestinationPort := NetworkShort(this->DestinationPort)
        this->SequenceNumber := NetworkInt(this->SequenceNumber)
        this->AcknowledgementNumber := NetworkInt(this->AcknowledgementNumber)
        this->WindowSize := NetworkShort(this->WindowSize)
        this->UrgentPointer := NetworkShort(this->UrgentPointer)
    }

    define i32 Size() {
        return this->DataOffset * 4
    }
}

struct TCPPacketOptions {
    i16 SourcePort

    i32 Destination
    i16 DestinationPort
}

i32 PACKET_DATA_TCP_HEADER := RegisterPacketData("TCP Header")
i32 PACKET_DATA_TCP_BODY := RegisterPacketData("TCP Body")

declare NetworkProtocolPrototype* GetTCPSocketProtocolPrototype()


i8 TCP_SOCKET_STATE_LISTEN := 1
i8 TCP_SOCKET_STATE_SYNCHRONIZE_SENT := 2
i8 TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED := 3
i8 TCP_SOCKET_STATE_ESTABLISHED := 4


struct TCPFrame {
    void* Data
    i32 Size

    union {
        i8 Flags
        
        bits As i8 {
            [0] Final
            [1] Synchronize
            [2] Reset
            [3] Push
            [4] Acknowledge
            [5] Urgent
            [6] CongestionExperienced
            [6] PeerSupportsECN
            [7] CongestionWindowReduced
        }
    }

    i32 AcknowledgementNumber
    i32 SequenceNumber
    i32 NextSequenceNumber

    i8 SendCount
    i8 DropCount
    i64 LastSentAt

    i32 SentAtWindowSize

    TCPFrame* Next

    define i32 LastByteSequenceNumber() {
        return this->NextSequenceNumber - 1
    }

    define i32 SequenceSize() {
        return this->NextSequenceNumber - this->SequenceNumber - 1
    }
}

i64 TCP_TIMEOUT_MS := 500

struct TCPSocket {
    ; Bidirectional

    NetworkInterface* Interface
    NetworkProtocol* Transport
    NetworkProtocol* AsProtocol

    i16 LocalPort
    i32 RemoteAddress
    i16 RemotePort

    i8 State

    i64 RoundTripSum
    i64 RoundTripCount

    define i64 GuessRoundTripTime() {
        return this->RoundTripSum / this->RoundTripCount
    }

    i32 SequenceNumberBase
    i32 NextSequenceNumber

    i32 RemoteWindowSize
    i32 LastAcknowledgeNumberSent

    i32 MaximumSegmentSize

    TCPFrame* OldestFrame
    TCPFrame* NewestFrame

    i32 RemoteSequenceBase

    void* RecieveWindow
    i32 RecieveWindowTail
    i32 RecieveWindowSize

    define i32 RecieveWindowCapacity() {
        return this->RecieveWindowSize - this->RecieveWindowTail
    }


    static self* New(NetworkInterface* Interface, NetworkProtocol* Transport) {
        self* this := Alloc(#self)

        this->Interface := Interface
        this->Transport := Transport

        this->AsProtocol := Interface->AddEphemeralProtocol(GetTCPSocketProtocolPrototype(), this)

        return this
    }

    define NetworkPacket* Enter(void* Options) {
        TCPPacketOptions TCPOptions {
            SourcePort: this->LocalPort,
            Destination: this->RemoteAddress,
            DestinationPort: this->RemotePort
        }

        NetworkPacket* Packet := this->Transport->Enter(&TCPOptions)

        return Packet
    }

    TCPCounters SendCounters
    TCPCounters RecieveCounters

    define void UpdateCounters(TCPCounters* Counters, TCPHeader* TCP) {
        Counters->Final += TCP->Final
        Counters->Synchronize += TCP->Synchronize
        Counters->Reset += TCP->Reset
        Counters->Push += TCP->Push
        Counters->Acknowledge += TCP->Acknowledge
        Counters->Urgent += TCP->Urgent
        Counters->CongestionExperienced += TCP->CongestionExperienced
        Counters->CongestionWindowReduced += TCP->CongestionWindowReduced

        Counters->Packets += 1
    }

    define void SendNow(TCPFrame* Frame) {
        NetworkPacket* Packet := this->Enter(null)
        TCPHeader* Header := Packet->Get(PACKET_DATA_TCP_HEADER)

        ;Info("SendNow %i, next = %i\n", Frame->SequenceNumber, Frame->NextSequenceNumber)

        Header->Flags := Frame->Flags
        Header->AcknowledgementNumber := Frame->AcknowledgementNumber
        Header->SequenceNumber := this->SequenceNumberBase + Frame->SequenceNumber
        Header->WindowSize := 8000

        if (Frame->Size) {
            Header->Push := true

            Packet->Seek(Packet->GetEndOffset(PACKET_DATA_TCP_HEADER))
            
            void* Body := Packet->Mark(PACKET_DATA_TCP_BODY, Frame->Size)
            MoveMemory(Body, Frame->Data, Frame->Size)
        }
        
        Frame->LastSentAt := GetUptimeMS()

        this->UpdateCounters(this~>SendCounters, Header)

        /*
        if (this~>SendCounters->Push = 1) {
            ; Drop the very first PSH to ensure that we retransmit it
            return
        }
        ;*/

        /*
        if (this~>SendCounters->Push <= 2) {
            ; Drop the first 2 PSH-s
            return
        }
        ;*/

        this->Transport->Send(Packet)
    }

    define i32 NextFrameSequenceNumber() {
        if (this->NewestFrame) {
            return this->NewestFrame->NextSequenceNumber
        }
        else {
            return this->NextSequenceNumber
        }
    }

    define TCPFrame* EnterFrame() {
        TCPFrame* Result := Alloc(#TCPFrame)

        Result->SequenceNumber := this->NextFrameSequenceNumber()

        return Result
    }

    define void QueueFrame(TCPFrame* Frame) {
        if (this->NewestFrame) {
            this->NewestFrame->Next := Frame
        }
        else if (this->OldestFrame = null) {
            this->OldestFrame := Frame
        }
        
        this->NewestFrame := Frame

        i32 DataSize := Frame->Size
        i32 PhantomSize := Frame->Synchronize ;Frame->Acknowledge || 

        Frame->NextSequenceNumber := Frame->SequenceNumber + DataSize + PhantomSize
    }

    define void DumpQueue() {
        TCPFrame* Current := this->OldestFrame

        while (Current) {
            Info("Frame %i - %i (%i bytes of data), %b\n", Current->SequenceNumber, Current->NextSequenceNumber, Current->Size, Current->Flags)

            Current := Current->Next
        }
    }

    define void SendPump() {
        ; First: figure out what the remote has gotten
        ; Second: figure out what we can send
        ; Third: send it

        ;/*

        if !(this->OldestFrame) {
            return
        }

        Info("SendPump: ")

        i64 Now := GetUptimeMS()
        i64 RTT := this->GuessRoundTripTime()

        Info("RTT(%i), WND(%i)\n", RTT, this->RemoteWindowSize)

        this->DumpQueue()

        TCPFrame* Current := this->OldestFrame

        while (Current) {
            if (Current->SendCount > 0 && Current->SendCount != Current->DropCount) {
                ; If segment has been sent at least once, and hasn't already been marked
                ;  as dropped in all previous transmissions, check the timeout

                i64 Timeout := Current->LastSentAt + RTT + 10

                if (Timeout < Now) {
                    Current->DropCount += 1
                }
            }
            else {
                break
            }

            Current := Current->Next
        }

        i32 Budget := this->RemoteWindowSize

        TCPFrame* Current := this->OldestFrame

        while (Current && Budget != 0) {
            i32 Size := Current->SequenceSize()

            if (Current->SendCount != Current->DropCount) {
                ; Packet has been sent but is not known to be dropped yet
                ; As long as the window has space, we can keep sending following
                ;  segments
            }
            else if (Size <= Budget) {
                Info("Send %i, SIZE(%i), TRY(%i)\n", Current->SequenceNumber, Size, Current->SendCount)

                Current->SendCount += 1

                this->SendNow(Current)

                Budget -= Size
            }
            else {
                break
            }

            Current := Current->Next
        }
        ;*/
    }

    Timer* QuantumTimer

    define void Quantum() {
        loop {
            ;Info("Quantum\n")
			this->SendPump()
			
			SchedulerBlock()
		}
    }

    define void SetSendPumpTimer() {
        Task* QuantumTask := Scheduler->AddLightTask(&self.Quantum)

        QuantumTask~>Context->RDI := this As i64

        this->QuantumTimer := SetTimer(10, QuantumTask)
    }

    define void AbortSendPump() {
        ; Disable send pump timer, pause task

        this->QuantumTimer->Disable()
        this->QuantumTimer->Task->Pause()
    }

    define void ResetSendPump() {
        ; Abort pump timer/task, reset to clean state

        this->AbortSendPump()

        Task* QuantumTask := this->QuantumTimer->Task

        QuantumTask~>Context->RIP := &self.Quantum
        QuantumTask~>Context->RDI := this As i64

        this->QuantumTimer->Enable()
    }

    define void QueueData(void* Data, i32 Size) {
        i32 WindowSegments := this->RemoteWindowSize / this->MaximumSegmentSize
        i32 DataSegments := Size / this->MaximumSegmentSize

        i32 Segments := WindowSegments
        i32 LastSegmentSize := this->MaximumSegmentSize

        if (LastSegmentSize) {
            DataSegments++
        }

        if (DataSegments < WindowSegments) {
            ; We have less data to send than the sliding window 

            Segments := DataSegments
            LastSegmentSize := Size % this->MaximumSegmentSize
        }

        for (i32 SegmentIndex := 0, SegmentIndex < Segments, SegmentIndex++) {
            TCPFrame* Frame := this->EnterFrame()

            Frame->Acknowledge := true
            Frame->AcknowledgementNumber := this->LastAcknowledgeNumberSent

            Frame->Data := Data + (SegmentIndex * this->MaximumSegmentSize)
            Frame->Size := this->MaximumSegmentSize

            if (SegmentIndex + 1 = Segments) {
                Frame->Size := LastSegmentSize
            }

            this->QueueFrame(Frame)
        }
    }

    define void QueueString(i8* Text) {
        this->QueueData(Text, StringLength(Text))
    }

    define TCPFrame* DequeueFrame(TCPFrame* Frame) {
        Info("Clearing frame %i (ack'd)\n", Frame->SequenceNumber)
        ;Info("Next seq: %i\n", this->NextSequenceNumber)

        TCPFrame* Result := Frame->Next

        if (this->OldestFrame = Frame) {
            this->OldestFrame := Frame->Next
        }

        if (this->NewestFrame = Frame) {
            this->NewestFrame := null

            this->NextSequenceNumber := Frame->NextSequenceNumber
        }

        if (Frame->SendCount = 1) {
            i64 Now := GetUptimeMS()

            i64 RoundTrip := Now - Frame->LastSentAt

            Info("RTT For Segment: %ims\n", RoundTrip)

            this->RoundTripSum += RoundTrip
            this->RoundTripCount += 1
        }

        Free(Frame)
        return Result
    }

    i32 LastRemoteAcknowledge

    define void Update(i32 RemoteAcknowledge) {
        RemoteAcknowledge -= this->SequenceNumberBase

        if (RemoteAcknowledge = this->LastRemoteAcknowledge) {
            Info("DUP ACK recieved starting at %i\n", RemoteAcknowledge)

            TCPFrame* Current := this->OldestFrame

            while (Current) {
                if (Current->SendCount = 0) {
                    break
                }

                if (Current->SendCount != Current->DropCount) {
                    ; We're not already aware of this packet being dropped

                    if (Current->SequenceNumber >= RemoteAcknowledge) {
                        ; If this packet is beyond the DUP ACK mark

                        Current->DropCount += 1
                    }
                }

                Current := Current->Next
            }
        }
        else {
            Info("Remote recieved up to %i\n", RemoteAcknowledge)
        }

        this->LastRemoteAcknowledge := RemoteAcknowledge

        this->ResetSendPump()

        TCPFrame* Current := this->OldestFrame

        while (Current != null) {
            if (Current->SendCount = 0) {
                break
            }

            if (Current->LastByteSequenceNumber() <= RemoteAcknowledge) {
                Current := this->DequeueFrame(Current)
            }
            else {
                Current := Current->Next
            }
        }
    }

    define void SendAcknowledge(i32 AcknowledgementNumber) {
        TCPFrame* Frame := this->EnterFrame()

        Frame->SentAtWindowSize := this->RecieveWindowCapacity()

        Frame->Acknowledge := true
        Frame->AcknowledgementNumber := AcknowledgementNumber

        this->LastAcknowledgeNumberSent := Frame->AcknowledgementNumber

        this->SendNow(Frame)
    }

    define void SendAcknowledge(NetworkPacket* Packet) {
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)
        i32 BodySize := Packet->GetSize(PACKET_DATA_TCP_BODY)

        i32 AcknowledgementNumber := TCP->SequenceNumber + BodySize + TCP->Synchronize

        this->SendAcknowledge(AcknowledgementNumber)
    }

    define void SendDuplicateAcknowledge() {
        this->SendAcknowledge(this->LastAcknowledgeNumberSent)
    }

    define void Ingest(NetworkPacket* Packet) {
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)

        this->UpdateCounters(this~>RecieveCounters, TCP)

        ;/*
        if (this~>RecieveCounters->Push = 1) {
            ; Drop the very first PSH to ensure that the second PSH is recieved and
            ;  ignored, and that the retransmission is accepted
            return
        }
        ;*/

        /*
        if (this~>RecieveCounters->Acknowledge = 2) {
            ; Drop the 2nd ACK to ensure that we retransmit correctly
            return
        }
        ;*/

        if (TCP->Acknowledge) {
            this->Update(TCP->AcknowledgementNumber)
        }

        if (TCP->Synchronize) {
            this->RemoteWindowSize := (TCP->WindowSize As i32) & 0xFFFF
            this->RemoteSequenceBase := TCP->SequenceNumber

            this->SendAcknowledge(Packet)
        }
        else if (Packet->GetSize(PACKET_DATA_TCP_BODY) != 0) {
            i32 DataSize := Packet->GetSize(PACKET_DATA_TCP_BODY)

            i32 ExpectedSequenceNumber := this->RemoteSequenceBase + this->RecieveWindowTail + 1

            Info("Got data, seq %i, expected %i\n", TCP->SequenceNumber, ExpectedSequenceNumber)

            if (TCP->SequenceNumber = ExpectedSequenceNumber) {
                MoveMemory(this->RecieveWindow + this->RecieveWindowTail, Packet->Get(PACKET_DATA_TCP_BODY), DataSize)
                this->RecieveWindowTail += DataSize

                Info("Matched, new window size: %i\n", this->RecieveWindowCapacity())

                this->SendAcknowledge(Packet)

                Print("TCP: %s\n", this->RecieveWindow)
            }
            else {
                this->SendDuplicateAcknowledge()
            }
        }

        if (this->State = TCP_SOCKET_STATE_SYNCHRONIZE_SENT) {
            if (TCP->Synchronize && TCP->Acknowledge) {
                Info("Syn Ack\n")

                this->State := TCP_SOCKET_STATE_ESTABLISHED
            }
        }
        else if (this->State = TCP_SOCKET_STATE_ESTABLISHED) {
            
        }
    }

    define void Initialize() {
        this->SequenceNumberBase := 0x1000_0000
        this->NextSequenceNumber := 0
        this->RemoteWindowSize := 1
        this->MaximumSegmentSize := 1200

        this->RoundTripSum := 200
        this->RoundTripCount := 1

        this->RecieveWindow := Alloc(0x1_0000)
        this->RecieveWindowSize := 0x1_0000
    }

    define void Connect(i32 RemoteAddress, i16 RemotePort) {
        this->Initialize()
        this->SetSendPumpTimer()

        this->RemoteAddress := RemoteAddress
        this->RemotePort := RemotePort

        this->State := TCP_SOCKET_STATE_SYNCHRONIZE_SENT

        TCPFrame* Frame := this->EnterFrame()
        Frame->Synchronize := true

        this->QueueFrame(Frame)
        this->SendPump()
    }
}

NetworkProtocolPrototype TCPSocketProtocolPrototype {
    Enter: &TCPSocket.Enter,
    ;Send: &TCPSocket.Send,
    Ingest: &TCPSocket.Ingest
}

define NetworkProtocolPrototype* GetTCPSocketProtocolPrototype() {
    return &TCPSocketProtocolPrototype
}

/*
struct TCPServer {
    ; Unidirectional, accept()-s connections
    ; Multiplexes multiple remote connections to the same port

    AVLTree* Connections ; <i32 Peer, NetworkProtocol* Socket>


    define void Ingest(NetworkPacket* Packet) {
        IPV4Header* IP := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)

        i64 Hash := (IP->Source As i64) + ((TCP->DestinationPort As i64) << 32)

        NetworkProtocol* ExistingSocket := this->Connections->GetPointer(Hash)

        if (ExistingSocket = null) {
            if (TCP->Synchronize) {
                NetworkProtocol* NewSocket := 

                NewSocket->State := TCP_SOCKET_STATE_ACCEPT_WAIT

                this->Connections->InsertPointer(Hash, NewSocket)
            }
        }
        else {
            if (TCP->Acknowledgement && ExistingSocket->State = TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED) {
                ExistingSocket->State := TCP_SOCKET_STATE_ESTABLISHED
            }

        }

    }

    define NetworkProtocol* Accept() {
        NetworkProtocol* Socket := 

        Socket->SendSynchronize()
        Socket->State := TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED
    }
}
*/

struct TCPPseudoHeader {
    i32 Source
    i32 Destination
    i8 Padding
    i8 Protocol
    i16 Length

    define void FlipEndianess() {
        this->Padding := 0

        this->Source := NetworkInt(this->Source)
        this->Destination := NetworkInt(this->Destination)
        this->Length := NetworkShort(this->Length)
    }
}

declare NetworkProtocolPrototype* GetTCPLayerProtocolPrototype()

struct TCPLayer {
    NetworkInterface* Interface
    NetworkProtocol* Transport

    NetworkProtocol* AsProtocol

    AVLTree* Sockets ; <i16, NetworkProtocol*>

	static self* New(NetworkInterface* Interface, NetworkProtocol* Transport) {
		self* this := Alloc(#self)

		this->Interface := Interface
		this->Transport := Transport

        this->AsProtocol := Interface->AddProtocol("TCP", GetTCPLayerProtocolPrototype(), this)

        IPV4Layer* IPV4 := Transport->this
        IPV4->AddProtocol(IPV4_PROTOCOL_TCP, this->AsProtocol)

        this->Sockets := AVLTree:New(#void*)

        return this
    }

    define NetworkPacket* Enter(TCPPacketOptions* Options) {
        IPV4PacketOptions IPOptions {
            Destination: Options->Destination,
            ProtocolNumber: IPV4_PROTOCOL_TCP
        }

        NetworkPacket* Packet := this->Transport->Enter(&IPOptions)

        TCPHeader* Header := Packet->Mark(PACKET_DATA_TCP_HEADER, #TCPHeader)

        Header->SourcePort := Options->SourcePort
        Header->DestinationPort := Options->DestinationPort

        Header->DataOffset := 5

        return Packet
    }

    define i16 Checksum(NetworkPacket* Packet) {
        IPV4Header* IP := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)
        void* Data := Packet->GetEnd(PACKET_DATA_TCP_HEADER)

        i64 State := RFC1071ChecksumStart()

        i32 DataSize := Packet->Tell() - Packet->GetEndOffset(PACKET_DATA_TCP_HEADER)
        i32 TotalSize := DataSize + #TCPHeader

        TCPPseudoHeader PseudoHeader {
            Source: IP->Source,
            Destination: IP->Destination,
            Protocol: IP->Protocol,
            Length: TotalSize As i16
        }

        PseudoHeader.FlipEndianess()
        TCP->FlipEndianess()
 
        State := RFC1071ChecksumUpdate(State, &PseudoHeader, #TCPPseudoHeader)
        State := RFC1071ChecksumUpdate(State, TCP, #TCPHeader)
        State := RFC1071ChecksumUpdate(State, Data, DataSize)

        TCP->FlipEndianess()

        return RFC1071ChecksumFinish(State)
    }

    define void Send(NetworkPacket* Packet) {
        TCPHeader* Header := Packet->Get(PACKET_DATA_TCP_HEADER)

        Header->Checksum := 0
        Header->Checksum := this->Checksum(Packet)

        Header->FlipEndianess()

        this->Transport->Send(Packet)
    }

    define void Ingest(NetworkPacket* Packet) {
        IPV4Header* IPV4 := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->GetEnd(PACKET_DATA_IPV4_HEADER)

        i32 HeaderSize := TCP->Size()
        i32 DataSize := IPV4->TotalLength - #IPV4Header - TCP->Size()

        Packet->Mark(PACKET_DATA_TCP_HEADER, HeaderSize)
        Packet->Mark(PACKET_DATA_TCP_BODY, DataSize)

        Info("TCP Body Size %i\n", DataSize)

        TCP->FlipEndianess()

        NetworkProtocol* Handler := this->Sockets->GetPointer(TCP->DestinationPort)

        if (Handler = null) {
            Info("TCP: Dropping packet from %ipv4:%i -> :%i\n", IPV4->Source, TCP->SourcePort, TCP->DestinationPort)
            return
        }

        Handler->Ingest(Packet)
    }

    define void BindSocket(i16 LocalPort, TCPSocket* Socket) {
        Socket->LocalPort := LocalPort

        this->Sockets->InsertPointer(LocalPort, Socket->AsProtocol)
    }
}

NetworkProtocolPrototype TCPLayerProtocolPrototype {
    Enter: &TCPLayer.Enter,
    Send: &TCPLayer.Send,
    Ingest: &TCPLayer.Ingest
}

define NetworkProtocolPrototype* GetTCPLayerProtocolPrototype() {
    return &TCPLayerProtocolPrototype
}