
i8 IPV4_PROTOCOL_TCP := 6

struct TCPHeader {
    i16 SourcePort
    i16 DestinationPort

    i32 SequenceNumber
    i32 AcknowledgementNumber

    bits As i8 {
        [4:7] DataOffset
        [0] AccurateECN
    }

    bits As i8 {
        [0] Final
        [1] Synchronize
        [2] Reset
        [3] Push
        [4] Acknowledge
        [5] Urgent
        [6] CongestionExperienced
        [6] PeerSupportsECN
        [7] CongestionWindowReduced
        [0:7] Flags
    }

    i16 WindowSize
    i16 Checksum
    i16 UrgentPointer

    define void FlipEndianess() {
        this->SourcePort := NetworkShort(this->SourcePort)
        this->DestinationPort := NetworkShort(this->DestinationPort)
        this->SequenceNumber := NetworkInt(this->SequenceNumber)
        this->AcknowledgementNumber := NetworkInt(this->AcknowledgementNumber)
        this->WindowSize := NetworkShort(this->WindowSize)
        this->UrgentPointer := NetworkShort(this->UrgentPointer)
    }

    define i32 Size() {
        return this->DataOffset * 4
    }
}

struct TCPPacketOptions {
    i16 SourcePort

    i32 Destination
    i16 DestinationPort
}

i32 PACKET_DATA_TCP_HEADER := RegisterPacketData("TCP Header")
i32 PACKET_DATA_TCP_BODY := RegisterPacketData("TCP Body")

declare NetworkProtocolPrototype* GetTCPSocketProtocolPrototype()


i8 TCP_SOCKET_STATE_LISTEN := 1
i8 TCP_SOCKET_STATE_SYNCHRONIZE_SENT := 2
i8 TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED := 3
i8 TCP_SOCKET_STATE_ESTABLISHED := 4


struct TCPFrame {
    void* Data
    i32 Size

    union {
        i8 Flags
        
        bits As i8 {
            [0] Final
            [1] Synchronize
            [2] Reset
            [3] Push
            [4] Acknowledge
            [5] Urgent
            [6] CongestionExperienced
            [6] PeerSupportsECN
            [7] CongestionWindowReduced
        }
    }

    i32 AcknowledgementNumber
    i32 SequenceNumber
    i32 NextSequenceNumber

    i8 SendCount
    i8 DropCount
    i64 LastSentAt

    i32 SentAtWindowSize

    TCPFrame* Next

    define i32 LastByteSequenceNumber() {
        return this->NextSequenceNumber - this->SequenceNumber - 2
    }

    define i32 SequenceSize() {
        return this->NextSequenceNumber - this->SequenceNumber - 1
    }
}

i64 TCP_TIMEOUT_MS := 500

struct TCPSocket {
    ; Bidirectional

    NetworkInterface* Interface
    NetworkProtocol* Transport

    i16 LocalPort

    i32 RemoteAddress
    i16 RemotePort

    i32 SequenceNumberBase
    i32 NextSequenceNumber
    i32 RemoteWindowSize

    i32 CongestionWindow
    i32 MaximumSegmentSize

    TCPFrame* OldestFrame
    TCPFrame* NewestFrame

    i8 State

    NetworkProtocol* AsProtocol

    NetworkPacket* TemplatePacket

    static self* New(NetworkInterface* Interface, NetworkProtocol* Transport) {
        self* this := Alloc(#self)

        this->Interface := Interface
        this->Transport := Transport

        this->AsProtocol := Interface->AddEphemeralProtocol(GetTCPSocketProtocolPrototype(), this)

        return this
    }

    define NetworkPacket* Enter(void* Options) {
        TCPPacketOptions TCPOptions {
            SourcePort: this->LocalPort,
            Destination: this->RemoteAddress,
            DestinationPort: this->RemotePort
        }

        NetworkPacket* Packet := this->Transport->Enter(&TCPOptions)

        return Packet
    }

    define void SendNow(TCPFrame* Frame) {
        NetworkPacket* Packet := this->Enter(null)
        TCPHeader* Header := Packet->Get(PACKET_DATA_TCP_HEADER)

        ;Info("SendNow %i, next = %i\n", Frame->SequenceNumber, Frame->NextSequenceNumber)

        Header->Flags := Frame->Flags
        Header->AcknowledgementNumber := Frame->AcknowledgementNumber
        Header->SequenceNumber := this->SequenceNumberBase + Frame->SequenceNumber
        Header->WindowSize := 8000
        
        this->Transport->Send(Packet)
    }

    define TCPFrame* EnterFrame() {
        TCPFrame* Result := Alloc(#TCPFrame)


        return Result
    }

    define void QueueFrame(TCPFrame* Frame) {
        if (this->NewestFrame) {
            Frame->SequenceNumber := this->NewestFrame->NextSequenceNumber

            this->NewestFrame->Next := Frame
        }
        else {
            Frame->SequenceNumber := this->NextSequenceNumber

            this->OldestFrame := Frame
        }
        
        this->NewestFrame := Frame

        i32 DataSize := Frame->Size
        i32 PhantomSize := 0 ;Frame->Acknowledge || Frame->Synchronize

        Frame->NextSequenceNumber := DataSize + PhantomSize + 1
    }

    define TCPFrame* SendDataSingle(TCPFrame** pNext, void* Data, i32 Size) {
        TCPHeader* TCP := this->TemplatePacket->Get(PACKET_DATA_TCP_HEADER)

        TCP->Flags := 0
        TCP->Acknowledge := 1
        ;TCP->AcknowledgementNumber := this->CalculateAcknowledgement()

        ;TCPFrame* Result := TCPFrame:New(Data, Size)

        ;this->NeedsAcknowledgement(Result)

        ;*pNext := Result
        ;return Result

        return null
    }

    define void SendPump() {
        ; First: figure out what the remote has gotten
        ; Second: figure out what we can send
        ; Third: send it

        ;/*

        i64 Now := GetUptimeMS()

        TCPFrame* Current := this->OldestFrame

        while (Current) {
            if (Current->SendCount > 0) {
                i64 Timeout := Current->LastSentAt + TCP_TIMEOUT_MS

                if (Timeout < Now) {
                    Current->DropCount += 1
                }
            }
            else {
                break
            }
        }

        i32 Budget := this->RemoteWindowSize
        TCPFrame* Current := this->OldestFrame

        while (Current && Budget != 0) {
            i32 Size := Current->SequenceSize()

            Info("Send(), Budget: %i, Current: %i\n", Budget, Size)

            if (Size <= Budget) {
                Current->SendCount += 1

                this->SendNow(Current)

                Budget -= Size
            }
            else {
                break
            }

            Current := Current->Next
        }
        ;*/

    }

    define void SendData(void* Data, i32 Size) {

        while (Size) {
            i32 WindowSegments := this->CongestionWindow / this->MaximumSegmentSize
            i32 DataSegments := Size / this->MaximumSegmentSize

            i32 Segments := WindowSegments
            i32 LastSegmentSize := this->MaximumSegmentSize

            if (DataSegments < WindowSegments) {
                ; We have less data to send than the sliding window 

                Segments := DataSegments
                LastSegmentSize := Size % this->MaximumSegmentSize
            }

            TCPFrame* FirstSegment := null
            TCPFrame** pNext := &FirstSegment

            for (i32 SegmentIndex := 0, SegmentIndex < Segments, SegmentIndex++) {
                void* SegmentData := Data + (SegmentIndex * this->MaximumSegmentSize)

                i32 SegmentSize := this->MaximumSegmentSize

                if (SegmentIndex + 1 = Segments) {
                    SegmentSize := LastSegmentSize
                }

                TCPFrame* Current := this->SendDataSingle(pNext, SegmentData, SegmentSize)

                pNext := Current~>Next
            }
        }
    }

    define void DequeueFrame(TCPFrame* Frame) {
        Info("Clearing frame %i (ack'd)\n", Frame->SequenceNumber)
        Info("Next seq: %i\n", this->NextSequenceNumber)

        if (this->OldestFrame = Frame) {
            if (Frame->Next) {
                this->OldestFrame := Frame->Next
            }
        }

        if (this->NewestFrame = Frame) {
            this->NewestFrame := null
        }

        Free(Frame)
    }

    define void Update(i32 RemoteAcknowledge) {
        RemoteAcknowledge -= this->SequenceNumberBase

        Info("Remote recieved up to %i\n", RemoteAcknowledge)

        TCPFrame* Current := this->OldestFrame

        while (Current != null) {
            if (Current->SendCount = 0) {
                break
            }

            if (Current->LastByteSequenceNumber() <= RemoteAcknowledge) {
                this->NextSequenceNumber := Current->NextSequenceNumber

                this->DequeueFrame(Current)
            }

            Current := Current->Next
        }
    }

    define i32 CalculateAcknowledgementNumber(TCPHeader* Header, i32 BodySize) {
        return Header->SequenceNumber + BodySize + Header->Synchronize
    }

    define void QueueAcknowledge(NetworkPacket* Packet) {
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)
        i32 BodySize := Packet->GetSize(PACKET_DATA_TCP_BODY)

        TCPFrame* Frame := this->EnterFrame()

        Frame->Acknowledge := true
        Frame->AcknowledgementNumber := this->CalculateAcknowledgementNumber(TCP, BodySize)

        this->QueueFrame(Frame)
        this->SendPump()
    }

    define void Ingest(NetworkPacket* Packet) {
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)

        if (TCP->Acknowledge) {
            this->Update(TCP->AcknowledgementNumber)
        }

        if (TCP->Synchronize) {
            this->RemoteWindowSize := TCP->WindowSize

            this->QueueAcknowledge(Packet)
        }
        else if (Packet->GetSize(PACKET_DATA_TCP_BODY) != 0) {
            this->QueueAcknowledge(Packet)
        }

        if (this->State = TCP_SOCKET_STATE_SYNCHRONIZE_SENT) {
            Info("TCP recv\n")

            Info("Flags: %b\n", (TCP->Flags As i64) & 0xFF)

            if (TCP->Synchronize && TCP->Acknowledge) {
                Info("Syn Ack\n")
            }
        }
        else if (this->State = TCP_SOCKET_STATE_ESTABLISHED) {

            if (TCP->Acknowledge) {
                ;this->RemoteReceived := TCP->AcknowledgementNumber - this->SendSequenceBase

                
            }
        }
    }

    define void Quantum() {

    }

    define void Connect(i32 RemoteAddress, i16 RemotePort) {
        this->RemoteAddress := RemoteAddress
        this->RemotePort := RemotePort

        this->State := TCP_SOCKET_STATE_SYNCHRONIZE_SENT

        this->SequenceNumberBase := 0x1000_0000
        this->NextSequenceNumber := 0
        this->RemoteWindowSize := 1

        TCPFrame* Frame := this->EnterFrame()
        Frame->Synchronize := true

        this->QueueFrame(Frame)
        this->SendPump()
    }
}

NetworkProtocolPrototype TCPSocketProtocolPrototype {
    Enter: &TCPSocket.Enter,
    ;Send: &TCPSocket.Send,
    Ingest: &TCPSocket.Ingest
}

define NetworkProtocolPrototype* GetTCPSocketProtocolPrototype() {
    return &TCPSocketProtocolPrototype
}

/*
struct TCPServer {
    ; Unidirectional, accept()-s connections
    ; Multiplexes multiple remote connections to the same port

    AVLTree* Connections ; <i32 Peer, NetworkProtocol* Socket>


    define void Ingest(NetworkPacket* Packet) {
        IPV4Header* IP := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)

        i64 Hash := (IP->Source As i64) + ((TCP->DestinationPort As i64) << 32)

        NetworkProtocol* ExistingSocket := this->Connections->GetPointer(Hash)

        if (ExistingSocket = null) {
            if (TCP->Synchronize) {
                NetworkProtocol* NewSocket := 

                NewSocket->State := TCP_SOCKET_STATE_ACCEPT_WAIT

                this->Connections->InsertPointer(Hash, NewSocket)
            }
        }
        else {
            if (TCP->Acknowledgement && ExistingSocket->State = TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED) {
                ExistingSocket->State := TCP_SOCKET_STATE_ESTABLISHED
            }

        }

    }

    define NetworkProtocol* Accept() {
        NetworkProtocol* Socket := 

        Socket->SendSynchronize()
        Socket->State := TCP_SOCKET_STATE_SYNCHRONIZE_RECEIVED
    }
}
*/

struct TCPPseudoHeader {
    i32 Source
    i32 Destination
    i8 Padding
    i8 Protocol
    i16 Length

    define void FlipEndianess() {
        this->Padding := 0

        this->Source := NetworkInt(this->Source)
        this->Destination := NetworkInt(this->Destination)
        this->Length := NetworkShort(this->Length)
    }
}

declare NetworkProtocolPrototype* GetTCPLayerProtocolPrototype()

struct TCPLayer {
    NetworkInterface* Interface
    NetworkProtocol* Transport

    NetworkProtocol* AsProtocol

    AVLTree* Sockets ; <i16, NetworkProtocol*>

	static self* New(NetworkInterface* Interface, NetworkProtocol* Transport) {
		self* this := Alloc(#self)

		this->Interface := Interface
		this->Transport := Transport

        this->AsProtocol := Interface->AddProtocol("TCP", GetTCPLayerProtocolPrototype(), this)

        IPV4Layer* IPV4 := Transport->this
        IPV4->AddProtocol(IPV4_PROTOCOL_TCP, this->AsProtocol)

        this->Sockets := AVLTree:New(#void*)

        return this
    }

    define NetworkPacket* Enter(TCPPacketOptions* Options) {
        IPV4PacketOptions IPOptions {
            Destination: Options->Destination,
            ProtocolNumber: IPV4_PROTOCOL_TCP
        }

        NetworkPacket* Packet := this->Transport->Enter(&IPOptions)

        TCPHeader* Header := Packet->Mark(PACKET_DATA_TCP_HEADER, #TCPHeader)

        Header->SourcePort := Options->SourcePort
        Header->DestinationPort := Options->DestinationPort

        Header->DataOffset := 5

        return Packet
    }

    define i16 Checksum(NetworkPacket* Packet) {
        IPV4Header* IP := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->Get(PACKET_DATA_TCP_HEADER)
        void* Data := Packet->GetEnd(PACKET_DATA_TCP_HEADER)

        i64 State := RFC1071ChecksumStart()

        i32 DataSize := Packet->Tell() - Packet->GetEndOffset(PACKET_DATA_TCP_HEADER)
        i32 TotalSize := DataSize + #TCPHeader

        TCPPseudoHeader PseudoHeader {
            Source: IP->Source,
            Destination: IP->Destination,
            Protocol: IP->Protocol,
            Length: TotalSize As i16
        }

        PseudoHeader.FlipEndianess()
        TCP->FlipEndianess()
 
        State := RFC1071ChecksumUpdate(State, &PseudoHeader, #TCPPseudoHeader)
        State := RFC1071ChecksumUpdate(State, TCP, #TCPHeader)
        State := RFC1071ChecksumUpdate(State, Data, DataSize)

        TCP->FlipEndianess()

        return RFC1071ChecksumFinish(State)
    }

    define void Send(NetworkPacket* Packet) {
        TCPHeader* Header := Packet->Get(PACKET_DATA_TCP_HEADER)

        Header->Checksum := 0
        Header->Checksum := this->Checksum(Packet)

        Header->FlipEndianess()

        this->Transport->Send(Packet)
    }

    define void Ingest(NetworkPacket* Packet) {
        IPV4Header* IPV4 := Packet->Get(PACKET_DATA_IPV4_HEADER)
        TCPHeader* TCP := Packet->GetEnd(PACKET_DATA_IPV4_HEADER)

        i32 HeaderSize := TCP->Size()
        i32 DataSize := IPV4->TotalLength - #IPV4Header - TCP->Size()

        Packet->Mark(PACKET_DATA_TCP_HEADER, HeaderSize)
        Packet->Mark(PACKET_DATA_TCP_BODY, DataSize)

        Info("TCP Body Size %i\n", DataSize)

        TCP->FlipEndianess()

        NetworkProtocol* Handler := this->Sockets->GetPointer(TCP->DestinationPort)

        if (Handler = null) {
            Info("TCP: Dropping packet from %ipv4:%i -> :%i\n", IPV4->Source, TCP->SourcePort, TCP->DestinationPort)
            return
        }

        Handler->Ingest(Packet)
    }

    define void BindSocket(i16 LocalPort, TCPSocket* Socket) {
        Socket->LocalPort := LocalPort

        this->Sockets->InsertPointer(LocalPort, Socket->AsProtocol)
    }
}

NetworkProtocolPrototype TCPLayerProtocolPrototype {
    Enter: &TCPLayer.Enter,
    Send: &TCPLayer.Send,
    Ingest: &TCPLayer.Ingest
}

define NetworkProtocolPrototype* GetTCPLayerProtocolPrototype() {
    return &TCPLayerProtocolPrototype
}