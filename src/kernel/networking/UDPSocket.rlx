
#Require "./src/kernel/networking/UDP.rlx"

declare NetworkProtocolPrototype* GetUDPSocketProtocolPrototype()

i16 NextUDPConnectionPort := 49152 As i16

struct UDPSocket {
    NetworkInterface* Interface
    NetworkProtocol* Transport

    NetworkProtocol* AsProtocol

    i8 IsServer
    i16 LocalPort
    i16 RemotePort

    AVLTree* RemotePorts ; <i32 Remote, i16 Port>

    AVLTree* ReceiveBuffers ; <i32 From, PointerArray<NetworkPacket*>* Packets>

    static self* New(NetworkInterface* Interface, NetworkProtocol* Transport) {
        self* this := Alloc(#self)

        this->Interface := Interface
        this->Transport := Transport

        this->RemotePorts := AVLTree:New(#void*)
        this->ReceiveBuffers := AVLTree:New(#PointerArray*)

        this->AsProtocol := Interface->AddEphemeralProtocol(GetUDPSocketProtocolPrototype(), this)

        return this
    }

    static self* New(NetworkInterface* Interface) {
        NetworkProtocol* UDP := Interface->GetProtocol("UDP")

        return self:New(Interface, UDP)
    }

    define void BindLocalPort() {
        UDPLayer* UDP := this->Transport->this

        UDP->ListenPort(this->LocalPort, this->AsProtocol)
    }

    define void Listen(i16 LocalPort) {
        this->IsServer := true
        this->LocalPort := LocalPort

        this->BindLocalPort()
    }

    define void Bind(i16 RemotePort) {
        this->IsServer := false
        this->LocalPort := NextUDPConnectionPort++
        this->RemotePort := RemotePort

        this->BindLocalPort()
    }

    define PointerArray* GetRecieveBufferForAddress(i32 Address) {
        PointerArray* Result := this->ReceiveBuffers->GetPointer(Address)

        if !(Result) {
            Result := PointerArray:New()

            this->ReceiveBuffers->InsertPointer(Address, Result)
        }

        return Result
    }

    define void Ingest(NetworkPacket* Packet) {
        IPV4Header* IP := Packet->Get(PACKET_DATA_IPV4_HEADER)

        PointerArray* Received := this->GetRecieveBufferForAddress(IP->Source)

        Received->Push(Packet->Clone())
    }

    define i16 GetDestinationPort(i32 Address) {
        if (this->IsServer) {
            return this->RemotePorts->GetPointer(Address) As i16
        }
        else {
            return this->RemotePort
        }
    }

    define void SendTo(i32 Address, void* Data, i32 Size) {
        UDPPacketOptions Options {
            SourcePort: this->LocalPort,
            Destination: Address,
            DestinationPort: this->GetDestinationPort(Address)
        }

        NetworkPacket* Packet := this->Transport->Enter(&Options)

        MoveMemory(Packet->Bump(Size), Data, Size)

        this->Transport->Send(Packet)
    }

    define i32 ReceiveFrom(i32 Address, void* Buffer, i32 MaxSize) {
        PointerArray* Received := this->GetRecieveBufferForAddress(Address)

        while (Received->Count() = 0) {
            SchedulerYield()
        }

        NetworkPacket* First := Received->At(0)

        UDPHeader* UDP := First->Get(PACKET_DATA_UDP_HEADER)

        void* Data := First->GetEnd(PACKET_DATA_UDP_HEADER)
        i32 DataOffset := First->Tell() - First->GetEndOffset(PACKET_DATA_UDP_HEADER)

        i32 BytesRemaining := UDP->Length - DataOffset - #UDPHeader

        if (BytesRemaining <= MaxSize) {
            MoveMemory(Buffer, Data, BytesRemaining)

            Received->Remove(0)
            First->Release()

            return BytesRemaining
        }
        else {
            MoveMemory(Buffer, Data, MaxSize)

            First->Bump(MaxSize)

            return MaxSize
        }
    }
}

NetworkProtocolPrototype UDPSocketProtocolPrototype {
    Ingest: &UDPSocket.Ingest
}

define NetworkProtocolPrototype* GetUDPSocketProtocolPrototype() {
    return &UDPSocketProtocolPrototype
}