
#Require "./src/kernel/networking/Endianess.rlx"

struct MACAddress {
    i8[6] Bytes

    define i8 Equals(MACAddress* Other) {
        return CompareMemory(this, Other, #self)
    }

    define i64 Hash() {
        return *(this As i64*)
    }

    define void Set(MACAddress* Other) {
        if (Other = null) {
            FastSetMemory8(this, 0, #self)
        }
        else {
            MoveMemory(this, Other, #self)
        }
    }
}

define void DoMACAddressPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
    MACAddress* Address := Parameters[*ParameterIndex] As void*

    this->Print("%B:%B:%B:%B:%B:%B", Address->Bytes[0], Address->Bytes[1], Address->Bytes[2], Address->Bytes[3], Address->Bytes[4], Address->Bytes[5])

    *ParameterIndex += 1
}

PrintFormatPrototype MACAddressFormatPrototype {
	Name: "mac",
	Format: &DoMACAddressPrint
}

i32 MAC_ADDRESS_FORMAT_PROTOTYPE_ID := AddPrintFormat(&MACAddressFormatPrototype)

struct PacketDataInfo {
    i8* Name
    i32 ID

    PacketDataInfo* Next

    static self* New(i8* Name) {
        self* this := Alloc(#self)

        this->Name := Name

        return this
    }
}

PacketDataInfo* FirstPacketData := null
PacketDataInfo* LastPacketData := null

define i32 RegisterPacketData(i8* Name) {
    PacketDataInfo* Info := PacketDataInfo:New(Name)

    if (FirstPacketData = null) {
        Info->ID := 1
        FirstPacketData := Info
    }
    else {
        Info->ID := LastPacketData->ID + 1
        LastPacketData->Next := Info
    }

    LastPacketData := Info

    return Info->ID
}

struct PacketData {
    i32 ID
    i32 Size
    void* Data
}

struct NetworkPacket {
    PacketData[10] Data

    void* Buffer
    void* Tail
    i32 Size
    i32 DataCount

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Tail := Buffer
        this->Size := Size

        return this
    }

    static self* New(i32 Size) {
        i32 Pages := Size / PAGE_SIZE

        if (Size % PAGE_SIZE) {
            Pages += 1
        }

        void* Buffer := KernelPageAllocator->AllocateVirtual(2)

        return self:New(Buffer, Size)
    }

    define void* Mark(i32 ID, i32 Size) {
        void* Result := this->Tail

        PacketData* Data := this->Data[this->DataCount++]

        Data->ID := ID
        Data->Data := this->Tail
        Data->Size := Size

        this->Tail += Size

        return Result
    }

    define void* Get(i32 ID) {
        for (i32 Index := 0, Index < this->DataCount, Index++) {
            PacketData* Data := this->Data[Index]

            if (Data->ID = ID) {
                return Data->Data
            }
        }

        return null
    }
}

struct NetworkInterface {
    MACAddress* MAC
    i32 IP

    define void Send(void* Buffer, i32 Size) {

    }
}

struct NetworkProtocol {
    void* State

    void(void*, NetworkPacket*) _Ingest

    define void Ingest(NetworkPacket* Packet) {
        this->_Ingest(this->State, Packet)
    }

    NetworkPacket*(void*) _Enter

    define NetworkPacket* Enter() {
        return this->_Enter(this->State)
    }

    void(void*, NetworkPacket*) _Send

    define void Send(NetworkPacket* Packet) {
        this->_Send(this->State, Packet)
    }
}

define i16 RFC1071Checksum(void* Data, i32 Size) {
    i64 Sum := 0

    while (Size > 1) {
        i16 Word := NetworkShort(*(Data As i16*))

        Sum += (Word As i32) & 0xFFFF
        Data += 2
        Size -= 2
    }

    if (Size > 0) {
        i16 Word := NetworkShort(*(Data As i8*))

        Sum += (Word As i32) & 0xFFFF
    }

    while (Sum > 0xFFFF) {
        Sum := (Sum >> 16) + (Sum & 0xFFFF)
    }

    return NetworkShort((~Sum) As i16)
}

define i32 PackIPV4(i32 A, i32 B, i32 C, i32 D) {
    return (A << 24) | (B << 16) | (C << 8) | (D << 0)
}