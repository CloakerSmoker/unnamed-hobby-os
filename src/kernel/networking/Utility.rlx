
#Require "./src/kernel/networking/Endianess.rlx"

struct MACAddress {
    i8[6] Bytes

    define i8 Equals(MACAddress* Other) {
        return CompareMemory(this, Other, #self)
    }

    define i64 Hash() {
        return *(this As i64*)
    }

    define void Set(MACAddress* Other) {
        if (Other = null) {
            FastSetMemory8(this, 0, #self)
        }
        else {
            MoveMemory(this, Other, #self)
        }
    }
}

MACAddress* MAC_NULL := i8[0, 0, 0, 0, 0, 0] As MACAddress*
MACAddress* MAC_BROADCAST := i8[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF] As MACAddress*

define void DoMACAddressPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
    MACAddress* Address := Parameters[*ParameterIndex] As void*

    this->Print("%B:%B:%B:%B:%B:%B", Address->Bytes[0], Address->Bytes[1], Address->Bytes[2], Address->Bytes[3], Address->Bytes[4], Address->Bytes[5])

    *ParameterIndex += 1
}

PrintFormatPrototype MACAddressFormatPrototype {
	Name: "mac",
	Format: &DoMACAddressPrint
}

i32 MAC_ADDRESS_FORMAT_PROTOTYPE_ID := AddPrintFormat(&MACAddressFormatPrototype)

i8*[20] PacketDataNames
i32 NextPacketDataID := 0

define i32 RegisterPacketData(i8* Name) {
    i32 ID := NextPacketDataID++

    PacketDataNames[ID] := Name

    return ID
}

struct PacketData {
    i32 ID
    i32 Size
    void* Data
}

struct NetworkPacket {
    PacketData[10] Data

    void* Buffer
    void* Tail
    i32 Size
    i32 DataCount

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Tail := Buffer
        this->Size := Size

        return this
    }

    static self* New(i32 Size) {
        i32 Pages := Size / PAGE_SIZE

        if (Size % PAGE_SIZE) {
            Pages += 1
        }

        void* Buffer := KernelPageAllocator->AllocateVirtual(2)

        return self:New(Buffer, Size)
    }

    define void* Mark(i32 ID, i32 Size) {
        void* Result := this->Tail

        PacketData* Data := this->Data[this->DataCount++]

        Data->ID := ID
        Data->Data := this->Tail
        Data->Size := Size

        this->Tail += Size

        return Result
    }

    define PacketData* Find(i32 ID) {
        for (i32 Index := 0, Index < this->DataCount, Index++) {
            PacketData* Data := this->Data[Index]

            if (Data->ID = ID) {
                return Data
            }
        }

        return null
    }

    define void* Get(i32 ID) {
        return this->Find(ID)->Data
    }

    define void* GetEnd(i32 ID) {
        PacketData* Data := this->Find(ID)

        return Data->Data + Data->Size
    }

    define i32 GetOffset(i32 ID) {
        PacketData* Data := this->Find(ID)

        return ((Data->Data As i64) - (this->Buffer As i64)) As i32
    }

    define i32 GetEndOffset(i32 ID) {
        PacketData* Data := this->Find(ID)

        i32 Offset := ((Data->Data As i64) - (this->Buffer As i64)) As i32

        return Offset + Data->Size
    }

    define void Seek(i32 Offset) {
        this->Tail := this->Buffer + Offset
    }

    define i32 Tell() {
        return ((this->Tail As i64) - (this->Buffer As i64)) As i32
    }

    define void End() {
        this->Size := this->Tell()
    }

    define self* Clone() {
        this->End()

        self* Clone := CloneMemory(this, #self)

        Clone->Buffer := CloneMemory(this->Buffer, this->Size)
        Clone->Tail := Clone->Buffer + this->Size

        return Clone
    }

    define void Free() {
        Free(this->Buffer)
        Free(this)
    }

    define void DumpMarkers() {
        Print("Markers for %x byte packet:\n", this->Size)

        for (i32 Index := 0, Index < this->DataCount, Index++) {
            PacketData* Data := this->Data[Index]

            i8* Name := PacketDataNames[Data->ID]

            Print("%s (%x bytes):\n%hexdump\n", Name, Data->Size, Data->Data, Data->Size)
        }
    }
}

struct NetworkProtocolPrototype {
    NetworkPacket*(void*, void*) Enter
    void(void*, NetworkPacket*) Send
    void(void*, NetworkPacket*) Ingest
}

struct NetworkProtocol {
    NetworkProtocolPrototype* Prototype

    union {
        void* State
        void* this
    }

    static self* New(NetworkProtocolPrototype* Prototype, void* State) {
        self* this := Alloc(#self)

        this->Prototype := Prototype
        this->State := State

        return this
    }

    define NetworkPacket* Enter(void* Options) {
        return this->Prototype->Enter(this->State, Options)
    }

    define void Send(NetworkPacket* Packet) {
        this->Prototype->Send(this->State, Packet)
    }

    define void Ingest(NetworkPacket* Packet) {
        this->Prototype->Ingest(this->State, Packet)
    }
}

struct NetworkInterface {
    MACAddress* MAC
    i32 IP
    i32 MTU

    AVLTree* Protocols ; <FNV1A(Name), NetworkProtocol*>

    NetworkProtocol* SendProtocol
    NetworkProtocol* ReceiveProtocol

    static self* New() {
        self* this := Alloc(#self)

        this->Protocols := AVLTree:New(#void*)

        return this
    }

    define NetworkProtocol* AddProtocol(i8* Name, NetworkProtocolPrototype* Prototype, void* State) {
        NetworkProtocol* Protocol := NetworkProtocol:New(Prototype, State)

        this->Protocols->InsertPointer(FNV1A(Name), Protocol)

        return Protocol
    }

    define NetworkProtocol* GetProtocol(i8* Name) {
        return this->Protocols->GetPointer(FNV1A(Name))
    }

    define void DoSend(NetworkPacket* Packet) {
        this->SendProtocol->Ingest(Packet)
    }

    define void OnReceive(NetworkPacket* Packet) {
        this->ReceiveProtocol->Ingest(Packet)
    }
}

define i16 RFC1071Checksum(void* Data, i32 Size) {
    i64 Sum := 0

    while (Size > 1) {
        i16 Word := NetworkShort(*(Data As i16*))

        Sum += (Word As i32) & 0xFFFF
        Data += 2
        Size -= 2
    }

    if (Size > 0) {
        i16 Word := NetworkShort(*(Data As i8*))

        Sum += (Word As i32) & 0xFFFF
    }

    while (Sum > 0xFFFF) {
        Sum := (Sum >> 16) + (Sum & 0xFFFF)
    }

    return NetworkShort((~Sum) As i16)
}

define i32 PackIPV4(i32 A, i32 B, i32 C, i32 D) {
    return (A << 24) | (B << 16) | (C << 8) | (D << 0)
}