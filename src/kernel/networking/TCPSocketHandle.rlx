
declare FileHandlePrototype* GetTCPSocketHandlePrototype()

struct TCPSocketHandle {
    #Include "./src/kernel/file-system/HandleInstance.rlx"

    TCPSocket* Socket

    static FileHandle* New(TCPSocket* Socket) {
        self* this := Alloc(#self)

        this->Prototype := GetTCPSocketHandlePrototype()

        this->Socket := Socket

        return this->AsHandle()
    }


    static FileHandle* New() {
        return self:New(Network->CreateTCP())
    }

    define void Connect(NetworkAddress* Address) {
        TCPError Error := this->Socket->Connect(Address->IPv4, Address->Port)

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }
        else if (Error != TCPError::Ok) {
            Throw(LINUX_ERROR_INVAL)
        }
    }

    define void Listen() {
        TCPError Error := this->Socket->Listen()

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }
        else if (Error != TCPError::Ok) {
            Throw(LINUX_ERROR_INVAL)
        }
    }

    define void Bind(NetworkAddress* Address) {
        if (Address->Type != NetworkAddressType::IPv4) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }

        TCPError Error := Network->Bind(Address->IPv4, Address->Port, this->Socket)

        if (Error = TCPError::PortBusy) {
            Throw(LINUX_ERROR_ADDRINUSE)
        }
        else if (Error != TCPError::Ok) {
            Throw(LINUX_ERROR_INVAL)
        }
    }

    define FileHandle* Accept(NetworkAddress* Address) {
        TCPSocket* Result := null
        TCPError Error := this->Socket->Accept(&Result)

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }
        else if (Error != TCPError::Ok) {
            Throw(LINUX_ERROR_INVAL)
        }

        return TCPSocketHandle:New(Result)
    }

    define i32 Poll(i32 Mode) {
        i32 Result := 0
        TCPError Error := this->Socket->Poll(Mode, &Result)

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }
        else if (Error != TCPError::Ok) {
            Throw(LINUX_ERROR_INVAL)
        }

        return Result
    }

    define i32 Send(void* Buffer, i32 Size) {
        i32 Result := 0
        TCPError Error := this->Socket->Send(Buffer, Size, &Result)

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }

        return Result
    }

    define i32 Write(void* Buffer, i32 Size) {
        return this->Send(Buffer, Size)
    }

    define i32 Recieve(void* Buffer, i32 Size) {
        i32 Result := 0
        TCPError Error := this->Socket->Recieve(Buffer, Size, &Result)

        if (Error = TCPError::InvalidState) {
            Throw(LINUX_ERROR_OPNOTSUPP)
        }

        return Result
    }

    define i32 Read(void* Buffer, i32 Size) {
        return this->Recieve(Buffer, Size)
    }

    define void Close() {
        
    }
}

FileHandlePrototype TCPSocketHandlePrototype {
    Connect: &TCPSocketHandle.Connect,
    Listen: &TCPSocketHandle.Listen,
    Bind: &TCPSocketHandle.Bind,
    Accept: &TCPSocketHandle.Accept,

    Poll: &TCPSocketHandle.Poll,

	Send: &TCPSocketHandle.Send,
    Write: &TCPSocketHandle.Write,

    Recieve: &TCPSocketHandle.Recieve,
    Read: &TCPSocketHandle.Read
}

i32 TCP_SOCKET_HANDLE_PROTOTYPE_ID := RegisterHandlePrototype(&TCPSocketHandlePrototype)

define FileHandlePrototype* GetTCPSocketHandlePrototype() {
    return &TCPSocketHandlePrototype
}