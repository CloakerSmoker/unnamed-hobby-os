#Require "./src/kernel/core/Paging.rlx"

; Needs to serve as "mmap", including the security boundary entailed
;  not the "can't mmap over the kernel" boundary though, that's somebody
;  else's job, I think.
; So, for each mmap call we need to figure out which actual memory to map it
;  to, and need to keep track of all actual mappings.
; Additionally, we need to keep track of which mappings are anonymous so we
;  can allow the virtual allocator to reclaim them. Although this might not
;  be needed, since the virtual allocator *should* be single use.
; Physical allocations can only be referenced once, but could be referenced
;  more if COW is implemented. COW isn't implemented though, so we're fine.
;
; To cleanup a process:
;  Free all physical allocations
;  Undo all mappings
; To clone a process:
;  Get a new virtual allocator
;  Clone all mappings (metadata only)
;  Re-allocate all mapped addresses in new allocator
;  Clone all phyiscal allocations (size+data)
;  Update mapping with cloned physical memory
;
; We don't need to track virtual allocations since the virtual allocator
;  already does, and is single-tenet. Opposed to the physical allocator,
;  which everyone is sharing and can't be deleted/recreated at will.
;
; We do need a way to enable/disable all mappings in the "collection" at
;  once though.
; TODO: Come up with a better name. MemoryManager? MemoryMapper? 


i32 VIRTUAL_TO_PHYSICAL_MAPPING := 0
i32 PHYSICAL_MEMORY_ALLOCATION := 1
i32 VIRTUAL_MEMORY_ALLOCATION := 2

struct MemoryMapping {
	void* Virtual
	i64 Physical
	i32 Flags
	i32 PageCount
	i32 AllocatorIndex
	i32 ReferenceCount
	MemoryMapping* Next
}

struct AllocationListHead {
	AllocationListHead* Next
}

struct PhysicalAllocation {
	PhysicalAllocation* Next

	i64 Address
	i32 PageCount
	i32 ReferenceCount

	static self* New(i64 Address, i32 Count) {
		self* this := Alloc('MMG_P', #self)

		this->Address := Address
		this->PageCount := Count

		return this
	}
}

struct VirtualAllocation {
	VirtualAllocation* Next

	void* Address
	i32 PageCount
	i8 IsAnonymous

	static self* New(void* Address, i32 PageCount) {
		self* this := Alloc('MMG_V', #self)

		this->Address := Address
		this->PageCount := PageCount

		return this
	}

	static self* NewAnonymous(void* Address, i32 PageCount) {
		self* this := self:New(Address, PageCount)

		this->IsAnonymous := true

		return this
	}

	define self* Clone() {
		return CloneMemory(this, #self)
	}
}

struct VirtualToPhysicalMapping {
	VirtualToPhysicalMapping* Next

	VirtualAllocation* Virtual
	PhysicalAllocation* Physical

	i64 Flags

	static self* New(VirtualAllocation* Virtual, PhysicalAllocation* Physical, i64 Flags) {
		self* this := Alloc('MMG_M', #self)

		this->Virtual := Virtual
		this->Physical := Physical
		this->Flags := Flags

		return this
	}

	define self* Clone() {
		return CloneMemory(this, #self)
	}

	define void Map(AddressSpaceManager* Manager) {
		Manager->MapRange(this->Virtual->Address, this->Physical->Address / PAGE_SIZE, this->Virtual->PageCount, this->Flags)
	}

	define void UnMap(AddressSpaceManager* Manager) {
		Manager->UnmapRange(this->Virtual->Address, this->Virtual->PageCount)
	}
}

#Require "$/PointerArray.rlx"

struct MemoryMappingGroup {
	AddressSpaceManager* AddressSpace
	PageHeap* PhysicalAllocator
	PageHeap* VirtualAllocator

	PointerArray* PhysicalAllocations ; <PhysicalAllocation*>
	PointerArray* VirtualAllocations ; <VirtualAllocation*>
	PointerArray* Mappings ; <VirtualToPhysicalMapping*>
	
	i8 Active
	
	static MemoryMappingGroup* New(AddressSpaceManager* AddressSpace, PageHeap* PhysicalAllocator, PageHeap* VirtualAllocator) {
		MemoryMappingGroup* this := Alloc('MMG', #MemoryMappingGroup)
		
		this->AddressSpace := AddressSpace
		this->PhysicalAllocator := PhysicalAllocator
		this->VirtualAllocator := VirtualAllocator

		this->PhysicalAllocations := PointerArray:New()
		this->VirtualAllocations := PointerArray:New()
		this->Mappings := PointerArray:New()

		this->Active := false
		
		return this
	}

	
	define MemoryMapping* Map(VirtualAllocation* Virtual, PhysicalAllocation* Physical, i64 Flags) {
		Flags |= PAGE_PRESENT
		
		VirtualToPhysicalMapping* New := VirtualToPhysicalMapping:New(Virtual, Physical, Flags)

		this->Mappings->Insert(New)

		return New
	}
	
	define PhysicalAllocation* AllocatePhysical(i32 Count) {
		i64 Physical := this->PhysicalAllocator->Allocate(Count)
		PhysicalAllocation* New := PhysicalAllocation:New(Physical, Count)

		this->PhysicalAllocations->Insert(New)
		
		return New
	}
	
	define VirtualAllocation* AllocateVirtual(i32 Count) {
		void* Virtual := this->VirtualAllocator->Allocate(Count) As void*
		VirtualAllocation* New := VirtualAllocation:New(Virtual, Count)
		
		this->VirtualAllocations->Insert(New)

		return New
	}

	define VirtualAllocation* AllocateAnonymousVirtual(void* Virtual, i32 Count) {
		VirtualAllocation* New := VirtualAllocation:New(Virtual, Count)
		
		this->VirtualAllocations->Insert(New)

		return New
	}
	
	define VirtualToPhysicalMapping* MapAddressAnonymous(void* Address, i32 Count, i64 Flags) {
		VirtualAllocation* Virtual := this->AllocateAnonymousVirtual(Address)
		PhysicalAllocation* Physical := this->AllocatePhysical(Count)
		
		return this->Map(Virtual, Physical, Count, Flags)
	}
	
	define VirtualToPhysicalMapping* MapAnonymous(i32 Count, i64 Flags) {
		VirtualAllocation* Virtual := this->AllocateVirtual(Count)
		PhysicalAllocation* Physical := this->AllocatePhysical(Count)
		
		return this->Map(Virtual, Physical, Count, Flags)
	}
	
	define VirtualToPhysicalMapping* Split(VirtualToPhysicalMapping* Old, i32 SplitPage) {
		i32 SplitOffset := SplitPage * PAGE_SIZE
		
		i64  PhysicalSplit := Old->Physical->Address + SplitOffset
		void* VirtualSplit := Old->Virtual->Address + SplitOffset
		
		i32 NewPages := Old->Virtual->PageCount - SplitPage
		i32 OldPages := Old->Virtual->PageCount - NewPages
		
		Old->PageCount := OldPages

		PhysicalAllocation* Backing := Old->Physical
		Backing->ReferenceCount += 1

		VirtualAllocation* New := this->AllocateAnonymousVirtual(VirtualSplit, NewPages)
		
		return this->Map(New, Backing, NewPages, Old->Flags)
	}
	define void Split(VirtualToPhysicalMapping* Old, i32 SplitPage, i32 PageCount, VirtualToPhysicalMapping** OutMiddle, VirtualToPhysicalMapping** OutEnd) {
		i32 OldPageCount := Old->PageCount
		
		*OutMiddle := this->Split(Old, SplitPage)
		
		if (SplitPage + PageCount = OldPageCount) {
			return
		}
		
		*OutEnd := this->Split(*OutMiddle, PageCount)
	}
	
	define void UpdateFlags(VirtualToPhysicalMapping* Mapping, i64 Flags) {
		Mapping->Flags := Flags
		
		if (this->Active) {
			this->AddressSpace->MapRange(Mapping->Virtual->Address, Mapping->Physical->Address / PAGE_SIZE, Mapping->Virtual->PageCount, Flags | PAGE_PRESENT)
		}
	}
	
	define VirtualToPhysicalMapping* FindVirtualExact(void* Virtual) {
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Current := this->Mappings->At(Index)

			if (Current->Address = Virtual) {
				return Current
			}
		}
		
		return null
	}
	
	define VirtualToPhysicalMapping* FindVirtualContaining(void* Virtual) {
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Current := this->Mappings->At(Index)

			void* Top := Current->Address + (Current->PageCount * PAGE_SIZE)
			
			if (Current->Address <= Virtual && Virtual < Top) {
				return Current
			}
		}
		
		return null
	}
	
	define VirtualToPhysicalMapping* FindVirtual(void* Address, i32 PageCount) {
		Address &= 0x7FFF_FFFF_FFFF_F000
		
		VirtualToPhysicalMapping* Mapping := this->FindVirtualExact(Address)
		
		if (Mapping) {
			if (Mapping->PageCount != PageCount) { 
				; Address is the exact start of a mapping, but with less pages than the
				;  mapping actually has. So we split the mapping into a PageCount sized 
				;   chunk and whatever's left over
				
				this->Split(Mapping, PageCount)
			}
			
			return Mapping
		}
		else {
			Mapping := this->FindVirtualContaining(Address)
			
			if (Mapping) {
				if (Mapping->PageCount != PageCount) {
					; Existing mapping, but not the start of said mapping
					; Which means we need to split it, potentially twice
					; Like         Turns into    by doing two splits
					;  |XXXXXXXX|   |XX|XXX|X|
					;     ^---^
					; Of course, a middle->end segment will only split once
					
					i32 OffsetInMapping := (Address - Mapping->Address) As i32
					i32 PageIndexInMapping := OffsetInMapping / PAGE_SIZE
					
					VirtualToPhysicalMapping* Middle := null
					VirtualToPhysicalMappings* End := null
					
					this->Split(Mapping, PageIndexInMapping, PageCount, &Middle, &End)
					
					if (Mapping->Address = Address) {
						return Mapping
					}
					else if (Middle->Address = Address) {
						return Middle
					}
					else if (End->Address = Address) {
						return End
					}
					else {
						Throw('MAP-SPLT')
					}
				}
			}
		}
		
		return null
	}
	
	define VirtualToPhysicalMapping* MapPages(void* Address, i32 PageCount, i64 Flags) {
		VirtualToPhysicalMapping* Mapping := null
		
		if (Address = null) {
			Mapping := this->MapAnonymous(PageCount, Flags)
		}
		else {
			Mapping := this->FindVirtual(Address, PageCount)
			
			if (Mapping) {
				this->UpdateFlags(Mapping, Flags)
			}
			else {
				Mapping := this->MapAddressAnonymous(Address, PageCount, Flags)
			}
		}
		
		return Mapping
	}
	
	define VirtualToPhysicalMapping* Map(void* Address, i32 Size, i64 Flags) {
		return this->MapPages(Address, SizeToPageCount(Size), Flags)
	}
	
	define void EnableVirtualMappings() {
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Current := this->Mappings->At(Index)

			Current->Enable(this->AddressSpace)
		}
		
		this->Active := true
	}
	
	define void DisableVirtualMappings() {
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Current := this->Mappings->At(Index)

			Current->UnMap(this->AddressSpace)
		}
		
		this->Active := false
	}

	define void DeleteVirtual(VirtualAllocation* Virtual) {
		this->VirtualAllocations->RemoveByValue(Virtual)

		this->VirtualAllocator->Free(Virtual->Address As i64, Target->PageCount)
		Free(Virtual)
	}
	define void DeletePhysical(PhysicalAllocation* Physical) {
		this->PhysicalAllocations->RemoveByValue(Physical)

		if (Physical->ReferenceCount = 1) {
			this->PhysicalAllocator->Free(Physical->Physical, Physical->PageCount)
			Free(Physical)
		}
		else {
			Physical->ReferenceCount -= 1
		}
	}
	define void DeleteMapping(VirtualToPhysicalMapping* Mapping) {
		this->Mappings->RemoveByValue(Mapping)
		
		if (this->Active) {
			Mapping->UnMap(this->AddressSpace)
		}

		Free(Mapping)
	}
	
	define void Free() {
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Mapping := this->Mappings->At(Index)

			this->DeleteMapping(Mapping)
		}

		for (i32 Index := 0, Index < this->VirtualAllocations->Count(), Index++) {
			VirtualAllocation* Virtual := this->VirtualAllocations->At(Index)

			this->DeleteVirtual(Virtual)
		}

		for (i32 Index := 0, Index < this->PhysicalAllocations->Count(), Index++) {
			PhysicalAllocation* Physical := this->PhysicalAllocations->At(Index)

			this->DeletePhysical(Physical)
		}
	}
	
	define MemoryMappingGroup* Clone() {
		MemoryMappingGroup* Result := MemoryMappingGroup:New(this->AddressSpace, this->PhysicalAllocator, this->VirtualAllocator)
		
		for (i32 Index := 0, Index < this->Mappings->Count(), Index++) {
			VirtualToPhysicalMapping* Existing := this->Mappings->At(Index)
			VirtualToPhysicalMapping* New := Existing->Clone()

			New->Physical->ReferenceCount += 1
			New->Virtual := New->Virtual->Clone()

			Result->Mappings->Insert(New)
			Result->VirtualAllocations->Insert(New->Virtual)
		}
		
		return null
	}
}