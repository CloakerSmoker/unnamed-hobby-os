#Require "./src/utility/x64.rlx"
#Require "./src/kernel/core/Descriptors.rlx"

declare AMD64Context* GetCurrentTaskContext()
declare void SchedulerRestart()

define void InterruptCodeSetup() asm {
	cli
	
	push, rax          ; Clobbered by GetCurrentTaskContext
	push, rdi          ; Clobbered by SaveContext(GetCurrentTaskContext())
	
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure interrupted context, with anything extra cleaned up below
	
	; Right now [ SS, RSP, RFLAGS, CS, RIP, ErrorCode, RAX, RDI ] where we need to save:
	;                 ^^^  ^^^^^^      ^^^             ^^^  ^^^
	;  into the current task's context before we can potentially jump to a different task
	;   while handling this interrupt
	
	pop, rax
	mov, {rdi + 0x38} As i64*, rax ; Context.RDI = OldRDI
	
	pop, rax
	mov, {rdi + 0x88} As i64*, rax ; Context.RAX = OldRAX

	pop, rax                       ; Pop original return address

	pop, rbx
	mov, {rdi + AMD64Context.LastInterruptCode} As i64*, rbx
	
	pop, rbx                       ; Pop RIP
	mov, {rdi} As i64*, rbx        ; Context.RIP = rbx
	
	pop, rbx                       ; Pop CS
	mov, {rdi + AMD64Context.CS} As i32*, ebx

	pop, rbx                       ; Pop RFLAGS
	mov, {rdi + 0x80} As i64*, rbx ; Context.Flags = rbx
	
	pop, rbx                       ; Pop RSP
	mov, {rdi + 0x20} As i64*, rbx ; Context.RSP = rbx
	
	pop, rbx                       ; Pop SS
	mov, {rdi + AMD64Context.SS} As i32*, ebx
	
	jmp, rax
}
define void InterruptCodeReturn() asm {
	call, @SchedulerRestart
}

define void InterruptSetup() asm {
	cli
	
	push, rax          ; Clobbered by GetCurrentTaskContext
	push, rdi          ; Clobbered by SaveContext(GetCurrentTaskContext())
	
	call, @GetCurrentTaskContext
	mov, rdi, rax      ; Parameter = CurrentTaskContext
	call, @SaveContext ; Capure interrupted context, with anything extra cleaned up below
	
	; Right now [ SS, RSP, RFLAGS, CS, RIP, RAX, RDI ] where we need to save:
	;                 ^^^  ^^^^^^      ^^^  ^^^  ^^^
	;  into the current task's context before we can potentially jump to a different task
	;   while handling this interrupt
	
	pop, rax
	mov, {rdi + 0x38} As i64*, rax ; Context.RDI = OldRDI
	
	pop, rax
	mov, {rdi + 0x88} As i64*, rax ; Context.RAX = OldRAX

	xor, eax, eax
	mov, {rdi + AMD64Context.LastInterruptCode} As i64*, rax
	
	pop, rax                       ; Pop original return address
	
	pop, rbx                       ; Pop RIP
	mov, {rdi} As i64*, rbx        ; Context.RIP = rax
	
	pop, rbx                       ; Pop CS
	mov, {rdi + AMD64Context.CS} As i32*, ebx
	
	pop, rbx                       ; Pop RFLAGS
	mov, {rdi + 0x80} As i64*, rbx ; Context.Flags = rax
	
	pop, rbx                       ; Pop RSP
	mov, {rdi + 0x20} As i64*, rbx ; Context.RSP = rax

	pop, rbx                       ; Pop SS
	mov, {rdi + AMD64Context.SS} As i32*, ebx
	
	jmp, rax
}
define void InterruptReturn() asm {
	call, @SchedulerRestart
}

struct IDTEntry unaligned {
	i16 OffsetLow16,
	i16 Selector,
	i8 IST,
	i8 Flags,
	i16 OffsetHigh16,
	i32 OffsetHigh32,
	i32 Padding
}

IDTEntry* IDT

i8 IST_NONE := 0
i8 IST_1 := 1
i8 IST_2 := 1
i8 IST_3 := 1
i8 IST_4 := 1
i8 IST_5 := 1
i8 IST_6 := 1
i8 IST_7 := 1

define void InsertIDTEntry(i32 Index, void* Function, i8 Present, i8 IST) {
	IDTEntry* E := IDT[Index]
	
	SetMemory(E As i64*, 0, 2)
	
	E->OffsetLow16 := (Function & 0xFFFF) As i16
	E->OffsetHigh16 := ((Function >> 16) & 0xFFFF) As i16
	E->OffsetHigh32 := ((Function >> 32) & 0xFFFFFFFF) As i32
	
	E->Selector := 0x08
	E->Flags := 0x0E | (Present << 7) As i8
}

define void InsertIDTEntry(i32 Index, void* Function, i8 Present) {
	InsertIDTEntry(Index, Function, Present, IST_NONE)
}

i32 IDT_MAX := 256
i32 IDT_SIZE := IDT_MAX * #IDTEntry

declare void AddHandlerStubs()
declare void AddKernelHandlers()
declare void SetupDeviceInterrupts()

#Require "./src/drivers/APIC.rlx"
#Require "./src/drivers/PIC.rlx"

define void SetupInterrupts() {
	DescriptorTableHeader IDTHeader

	IDT := KernelPageAllocator->AllocateVirtual(1)
	
	IDTHeader.Base := IDT
	IDTHeader.Limit := IDT_SIZE As i16
	
	RemapPIC(0x20)
	
	if (USE_INTERRUPT_STUBS) {
		AddHandlerStubs()
	}
	
	AddKernelHandlers()
	;SetupDeviceInterrupts()
	
	asm (rax := &IDTHeader) {
		lidt, {rax} As i64*
	}

	if (USE_APIC) {
		LocalAPIC->Initialize()
		LocalAPIC->Setup()

		LocalAPIC->MaskAll(true)
		LocalAPIC->DumpLVT()
		
		FirstIOAPIC->Initialize(BootInfo->IOAPICBase, 0)
		FirstIOAPIC->Setup()

		Print("Local APIC ID: %x\n", LocalAPIC->ID)

		FirstIOAPIC->MaskAll(true)
		FirstIOAPIC->DumpMappings()
	}
}

enum AMD64InterruptNumber {
	DivideByZero := 0
	Debug := 1
	NonMaskableInterrupt := 2
	Breakpoint := 3
	Overflow := 4
	BoundRange := 5
	InvalidOpcode := 6
	DeviceNotAvailable := 7
	DoubleFault := 8
	Reserved1 := 9
	InvalidTSS := 10
	SegmentNotPresent := 11
	Stack := 12
	GeneralProtection := 13
	PageFault := 14
	Reserved2 := 15
	FPU := 16
	Alignment := 17
	MachineCheck := 18
	SIMD := 19
	Virtualization := 20
	ControlProtection := 21
	Reserved3 := 22
	Reserved4 := 23
	Reserved5 := 24
	Reserved6 := 25
	Reserved7 := 26
	Reserved8 := 27
	Hypervisor := 28
	VMM := 29
	Security := 30
	Reserved9 := 31
}

i8 INTERRUPT_IS_FIRST_CHANCE := true

define void GenericInterrupt(AMD64Context* Context, i32 RawInterruptNumber) {
	if !(INTERRUPT_IS_FIRST_CHANCE) {
		asm {cli}
		loop {}
	}
	
	INTERRUPT_IS_FIRST_CHANCE := false

	AMD64InterruptNumber InterruptNumber := RawInterruptNumber As AMD64InterruptNumber

	Print("^H1^SF\e[0J                      PANIC!!!! NOW!!!!!!!                  \n")

	if (nameof:(InterruptNumber) = null) {
		Print("              INT%i (%x) (code: %i %x)\n", RawInterruptNumber, RawInterruptNumber, Context->LastInterruptCode, Context->LastInterruptCode)
	}
	else {
		Print("                  %s (code: %i %x)\n", nameof:(InterruptNumber), Context->LastInterruptCode, Context->LastInterruptCode)
	}

	Print("%context", Context)
	Print("Code Bytes (RIP %x):\n%hexdump\n", Context->RIP, Context->RIP, 15)

	Print("GDT:\n%hexdump", GLOBAL_GDT, 64)

	;Print("%stackdump")

	FirstIOAPIC->DumpMappings()

	Halt()
	
	;Context->PrintContext()
	;Context->PrintRegisters()
	;Context->PrintStackDump()
	
	asm {cli}
	
	loop {}
}

#Require "./src/utility/Exception.rlx"
#Require "./src/kernel/core/generated/InterruptStubs.rlx"
#Require "./src/kernel/core/InterruptHandlers.rlx"
